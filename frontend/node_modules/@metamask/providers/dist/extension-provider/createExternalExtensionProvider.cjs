"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createExternalExtensionProvider = createExternalExtensionProvider;
exports.getBuildType = getBuildType;
const object_multiplex_1 = __importDefault(require("@metamask/object-multiplex"));
const detect_browser_1 = require("detect-browser");
const extension_port_stream_1 = require("extension-port-stream");
const readable_stream_1 = require("readable-stream");
const external_extension_config_json_1 = __importDefault(require("./external-extension-config.json"));
const MetaMaskInpageProvider_1 = require("../MetaMaskInpageProvider.cjs");
const StreamProvider_1 = require("../StreamProvider.cjs");
const utils_1 = require("../utils.cjs");
const browser = (0, detect_browser_1.detect)();
/**
 * Creates an external extension provider for the given extension type or ID.
 *
 * @param typeOrId - The extension type or ID.
 * @returns The external extension provider.
 */
function createExternalExtensionProvider(typeOrId = 'stable') {
    let provider;
    try {
        const extensionId = getExtensionId(typeOrId);
        const metamaskPort = chrome.runtime.connect(extensionId);
        const pluginStream = new extension_port_stream_1.PortDuplexStream(metamaskPort);
        const streamName = MetaMaskInpageProvider_1.MetaMaskInpageProviderStreamName;
        const mux = new object_multiplex_1.default();
        (0, readable_stream_1.pipeline)(pluginStream, mux, pluginStream, (error) => {
            let warningMsg = `Lost connection to "${streamName}".`;
            if (error?.stack) {
                warningMsg += `\n${error.stack}`;
            }
            console.warn(warningMsg);
        });
        provider = new StreamProvider_1.StreamProvider(mux.createStream(streamName), {
            logger: console,
            rpcMiddleware: (0, utils_1.getDefaultExternalMiddleware)(console),
        });
        // This is asynchronous but merely logs an error and does not throw upon
        // failure. Previously this just happened as a side-effect in the
        // constructor.
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        provider.initialize();
    }
    catch (error) {
        console.dir(`MetaMask connect error.`, error);
        throw error;
    }
    return provider;
}
/**
 * Gets the extension ID for the given extension type or ID.
 *
 * @param typeOrId - The extension type or ID.
 * @returns The extension ID.
 */
function getExtensionId(typeOrId) {
    let ids;
    switch (browser?.name) {
        case 'edge-chromium':
            ids = external_extension_config_json_1.default.edgeChromiumIds;
            break;
        case 'firefox':
            ids = external_extension_config_json_1.default.firefoxIds;
            break;
        default:
            ids = external_extension_config_json_1.default.chromeIds;
    }
    return ids[typeOrId] ?? typeOrId;
}
/**
 * Gets the build type for the given domain name identifier.
 *
 * @param rdns - The reverse syntax domain name identifier for the wallet.
 * @returns The type or ID.
 */
function getBuildType(rdns) {
    const rndsToIdDefinition = {
        'io.metamask': 'stable',
        'io.metamask.beta': 'beta',
        'io.metamask.flask': 'flask',
    };
    return rndsToIdDefinition[rdns];
}
//# sourceMappingURL=createExternalExtensionProvider.cjs.map