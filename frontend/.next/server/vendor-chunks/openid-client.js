/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openid-client";
exports.ids = ["vendor-chunks/openid-client"];
exports.modules = {

/***/ "(rsc)/../node_modules/openid-client/lib/client.js":
/*!***************************************************!*\
  !*** ../node_modules/openid-client/lib/client.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { inspect } = __webpack_require__(/*! util */ \"util\");\nconst stdhttp = __webpack_require__(/*! http */ \"http\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst { strict: assert } = __webpack_require__(/*! assert */ \"assert\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst { URL, URLSearchParams } = __webpack_require__(/*! url */ \"url\");\nconst jose = __webpack_require__(/*! jose */ \"(rsc)/../node_modules/jose/dist/node/cjs/index.js\");\nconst tokenHash = __webpack_require__(/*! oidc-token-hash */ \"(rsc)/../node_modules/oidc-token-hash/lib/index.js\");\nconst isKeyObject = __webpack_require__(/*! ./helpers/is_key_object */ \"(rsc)/../node_modules/openid-client/lib/helpers/is_key_object.js\");\nconst decodeJWT = __webpack_require__(/*! ./helpers/decode_jwt */ \"(rsc)/../node_modules/openid-client/lib/helpers/decode_jwt.js\");\nconst base64url = __webpack_require__(/*! ./helpers/base64url */ \"(rsc)/../node_modules/openid-client/lib/helpers/base64url.js\");\nconst defaults = __webpack_require__(/*! ./helpers/defaults */ \"(rsc)/../node_modules/openid-client/lib/helpers/defaults.js\");\nconst parseWwwAuthenticate = __webpack_require__(/*! ./helpers/www_authenticate_parser */ \"(rsc)/../node_modules/openid-client/lib/helpers/www_authenticate_parser.js\");\nconst { assertSigningAlgValuesSupport, assertIssuerConfiguration } = __webpack_require__(/*! ./helpers/assert */ \"(rsc)/../node_modules/openid-client/lib/helpers/assert.js\");\nconst pick = __webpack_require__(/*! ./helpers/pick */ \"(rsc)/../node_modules/openid-client/lib/helpers/pick.js\");\nconst isPlainObject = __webpack_require__(/*! ./helpers/is_plain_object */ \"(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js\");\nconst processResponse = __webpack_require__(/*! ./helpers/process_response */ \"(rsc)/../node_modules/openid-client/lib/helpers/process_response.js\");\nconst TokenSet = __webpack_require__(/*! ./token_set */ \"(rsc)/../node_modules/openid-client/lib/token_set.js\");\nconst { OPError, RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nconst { random } = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/../node_modules/openid-client/lib/helpers/generators.js\");\nconst request = __webpack_require__(/*! ./helpers/request */ \"(rsc)/../node_modules/openid-client/lib/helpers/request.js\");\nconst { CLOCK_TOLERANCE } = __webpack_require__(/*! ./helpers/consts */ \"(rsc)/../node_modules/openid-client/lib/helpers/consts.js\");\nconst { keystores } = __webpack_require__(/*! ./helpers/weak_cache */ \"(rsc)/../node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst KeyStore = __webpack_require__(/*! ./helpers/keystore */ \"(rsc)/../node_modules/openid-client/lib/helpers/keystore.js\");\nconst clone = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { authenticatedPost, resolveResponseType, resolveRedirectUri } = __webpack_require__(/*! ./helpers/client */ \"(rsc)/../node_modules/openid-client/lib/helpers/client.js\");\nconst { queryKeyStore } = __webpack_require__(/*! ./helpers/issuer */ \"(rsc)/../node_modules/openid-client/lib/helpers/issuer.js\");\nconst DeviceFlowHandle = __webpack_require__(/*! ./device_flow_handle */ \"(rsc)/../node_modules/openid-client/lib/device_flow_handle.js\");\nconst [major, minor] = process.version.slice(1).split('.').map((str)=>parseInt(str, 10));\nconst rsaPssParams = major >= 17 || major === 16 && minor >= 9;\nconst retryAttempt = Symbol();\nconst skipNonceCheck = Symbol();\nconst skipMaxAgeCheck = Symbol();\nfunction pickCb(input) {\n    return pick(input, 'access_token', 'code', 'error_description', 'error_uri', 'error', 'expires_in', 'id_token', 'iss', 'response', 'session_state', 'state', 'token_type');\n}\nfunction authorizationHeaderValue(token, tokenType = 'Bearer') {\n    return `${tokenType} ${token}`;\n}\nfunction getSearchParams(input) {\n    const parsed = url.parse(input);\n    if (!parsed.search) return {};\n    return querystring.parse(parsed.search.substring(1));\n}\nfunction verifyPresence(payload, jwt, prop) {\n    if (payload[prop] === undefined) {\n        throw new RPError({\n            message: `missing required JWT property ${prop}`,\n            jwt\n        });\n    }\n}\nfunction authorizationParams(params) {\n    const authParams = {\n        client_id: this.client_id,\n        scope: 'openid',\n        response_type: resolveResponseType.call(this),\n        redirect_uri: resolveRedirectUri.call(this),\n        ...params\n    };\n    Object.entries(authParams).forEach(([key, value])=>{\n        if (value === null || value === undefined) {\n            delete authParams[key];\n        } else if (key === 'claims' && typeof value === 'object') {\n            authParams[key] = JSON.stringify(value);\n        } else if (key === 'resource' && Array.isArray(value)) {\n            authParams[key] = value;\n        } else if (typeof value !== 'string') {\n            authParams[key] = String(value);\n        }\n    });\n    return authParams;\n}\nfunction getKeystore(jwks) {\n    if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !('kty' in k))) {\n        throw new TypeError('jwks must be a JSON Web Key Set formatted object');\n    }\n    return KeyStore.fromJWKS(jwks, {\n        onlyPrivate: true\n    });\n}\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, properties) {\n    try {\n        const supported = client.issuer.token_endpoint_auth_methods_supported;\n        if (!supported.includes(properties.token_endpoint_auth_method)) {\n            if (supported.includes('client_secret_post')) {\n                properties.token_endpoint_auth_method = 'client_secret_post';\n            }\n        }\n    } catch (err) {}\n}\nfunction handleCommonMistakes(client, metadata, properties) {\n    if (!metadata.token_endpoint_auth_method) {\n        // if no explicit value was provided\n        checkBasicSupport(client, properties);\n    }\n    // :fp: c'mon people... RTFM\n    if (metadata.redirect_uri) {\n        if (metadata.redirect_uris) {\n            throw new TypeError('provide a redirect_uri or redirect_uris, not both');\n        }\n        properties.redirect_uris = [\n            metadata.redirect_uri\n        ];\n        delete properties.redirect_uri;\n    }\n    if (metadata.response_type) {\n        if (metadata.response_types) {\n            throw new TypeError('provide a response_type or response_types, not both');\n        }\n        properties.response_types = [\n            metadata.response_type\n        ];\n        delete properties.response_type;\n    }\n}\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n    if (!issuer[`${endpoint}_endpoint`]) return;\n    const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n    const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n    const eam = `${endpoint}_endpoint_auth_method`;\n    const easa = `${endpoint}_endpoint_auth_signing_alg`;\n    if (properties[eam] === undefined && properties[easa] === undefined) {\n        if (tokenEndpointAuthMethod !== undefined) {\n            properties[eam] = tokenEndpointAuthMethod;\n        }\n        if (tokenEndpointAuthSigningAlg !== undefined) {\n            properties[easa] = tokenEndpointAuthSigningAlg;\n        }\n    }\n}\nclass BaseClient {\n    #metadata;\n    #issuer;\n    #aadIssValidation;\n    #additionalAuthorizedParties;\n    constructor(issuer, aadIssValidation, metadata = {}, jwks, options){\n        this.#metadata = new Map();\n        this.#issuer = issuer;\n        this.#aadIssValidation = aadIssValidation;\n        if (typeof metadata.client_id !== 'string' || !metadata.client_id) {\n            throw new TypeError('client_id is required');\n        }\n        const properties = {\n            grant_types: [\n                'authorization_code'\n            ],\n            id_token_signed_response_alg: 'RS256',\n            authorization_signed_response_alg: 'RS256',\n            response_types: [\n                'code'\n            ],\n            token_endpoint_auth_method: 'client_secret_basic',\n            ...this.fapi1() ? {\n                grant_types: [\n                    'authorization_code',\n                    'implicit'\n                ],\n                id_token_signed_response_alg: 'PS256',\n                authorization_signed_response_alg: 'PS256',\n                response_types: [\n                    'code id_token'\n                ],\n                tls_client_certificate_bound_access_tokens: true,\n                token_endpoint_auth_method: undefined\n            } : undefined,\n            ...this.fapi2() ? {\n                id_token_signed_response_alg: 'PS256',\n                authorization_signed_response_alg: 'PS256',\n                token_endpoint_auth_method: undefined\n            } : undefined,\n            ...metadata\n        };\n        if (this.fapi()) {\n            switch(properties.token_endpoint_auth_method){\n                case 'self_signed_tls_client_auth':\n                case 'tls_client_auth':\n                    break;\n                case 'private_key_jwt':\n                    if (!jwks) {\n                        throw new TypeError('jwks is required');\n                    }\n                    break;\n                case undefined:\n                    throw new TypeError('token_endpoint_auth_method is required');\n                default:\n                    throw new TypeError('invalid or unsupported token_endpoint_auth_method');\n            }\n        }\n        if (this.fapi2()) {\n            if (properties.tls_client_certificate_bound_access_tokens && properties.dpop_bound_access_tokens) {\n                throw new TypeError('either tls_client_certificate_bound_access_tokens or dpop_bound_access_tokens must be set to true');\n            }\n            if (!properties.tls_client_certificate_bound_access_tokens && !properties.dpop_bound_access_tokens) {\n                throw new TypeError('either tls_client_certificate_bound_access_tokens or dpop_bound_access_tokens must be set to true');\n            }\n        }\n        handleCommonMistakes(this, metadata, properties);\n        assertSigningAlgValuesSupport('token', this.issuer, properties);\n        [\n            'introspection',\n            'revocation'\n        ].forEach((endpoint)=>{\n            getDefaultsForEndpoint(endpoint, this.issuer, properties);\n            assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n        });\n        Object.entries(properties).forEach(([key, value])=>{\n            this.#metadata.set(key, value);\n            if (!this[key]) {\n                Object.defineProperty(this, key, {\n                    get () {\n                        return this.#metadata.get(key);\n                    },\n                    enumerable: true\n                });\n            }\n        });\n        if (jwks !== undefined) {\n            const keystore = getKeystore.call(this, jwks);\n            keystores.set(this, keystore);\n        }\n        if (options != null && options.additionalAuthorizedParties) {\n            this.#additionalAuthorizedParties = clone(options.additionalAuthorizedParties);\n        }\n        this[CLOCK_TOLERANCE] = 0;\n    }\n    authorizationUrl(params = {}) {\n        if (!isPlainObject(params)) {\n            throw new TypeError('params must be a plain object');\n        }\n        assertIssuerConfiguration(this.issuer, 'authorization_endpoint');\n        const target = new URL(this.issuer.authorization_endpoint);\n        for (const [name, value] of Object.entries(authorizationParams.call(this, params))){\n            if (Array.isArray(value)) {\n                target.searchParams.delete(name);\n                for (const member of value){\n                    target.searchParams.append(name, member);\n                }\n            } else {\n                target.searchParams.set(name, value);\n            }\n        }\n        // TODO: is the replace needed?\n        return target.href.replace(/\\+/g, '%20');\n    }\n    authorizationPost(params = {}) {\n        if (!isPlainObject(params)) {\n            throw new TypeError('params must be a plain object');\n        }\n        const inputs = authorizationParams.call(this, params);\n        const formInputs = Object.keys(inputs).map((name)=>`<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join('\\n');\n        return `<!DOCTYPE html>\n<head>\n<title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n<form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n  ${formInputs}\n</form>\n</body>\n</html>`;\n    }\n    endSessionUrl(params = {}) {\n        assertIssuerConfiguration(this.issuer, 'end_session_endpoint');\n        const { 0: postLogout, length } = this.post_logout_redirect_uris || [];\n        const { post_logout_redirect_uri = length === 1 ? postLogout : undefined } = params;\n        let id_token_hint;\n        ({ id_token_hint, ...params } = params);\n        if (id_token_hint instanceof TokenSet) {\n            if (!id_token_hint.id_token) {\n                throw new TypeError('id_token not present in TokenSet');\n            }\n            id_token_hint = id_token_hint.id_token;\n        }\n        const target = url.parse(this.issuer.end_session_endpoint);\n        const query = defaults(getSearchParams(this.issuer.end_session_endpoint), params, {\n            post_logout_redirect_uri,\n            client_id: this.client_id\n        }, {\n            id_token_hint\n        });\n        Object.entries(query).forEach(([key, value])=>{\n            if (value === null || value === undefined) {\n                delete query[key];\n            }\n        });\n        target.search = null;\n        target.query = query;\n        return url.format(target);\n    }\n    callbackParams(input) {\n        const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;\n        const isString = typeof input === 'string';\n        if (!isString && !isIncomingMessage) {\n            throw new TypeError('#callbackParams only accepts string urls, http.IncomingMessage or a lookalike');\n        }\n        if (isIncomingMessage) {\n            switch(input.method){\n                case 'GET':\n                    return pickCb(getSearchParams(input.url));\n                case 'POST':\n                    if (input.body === undefined) {\n                        throw new TypeError('incoming message body missing, include a body parser prior to this method call');\n                    }\n                    switch(typeof input.body){\n                        case 'object':\n                        case 'string':\n                            if (Buffer.isBuffer(input.body)) {\n                                return pickCb(querystring.parse(input.body.toString('utf-8')));\n                            }\n                            if (typeof input.body === 'string') {\n                                return pickCb(querystring.parse(input.body));\n                            }\n                            return pickCb(input.body);\n                        default:\n                            throw new TypeError('invalid IncomingMessage body object');\n                    }\n                default:\n                    throw new TypeError('invalid IncomingMessage method');\n            }\n        } else {\n            return pickCb(getSearchParams(input));\n        }\n    }\n    async callback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let params = pickCb(parameters);\n        if (checks.jarm && !('response' in parameters)) {\n            throw new RPError({\n                message: 'expected a JARM response',\n                checks,\n                params\n            });\n        } else if ('response' in parameters) {\n            const decrypted = await this.decryptJARM(params.response);\n            params = await this.validateJARM(decrypted);\n        }\n        if (this.default_max_age && !checks.max_age) {\n            checks.max_age = this.default_max_age;\n        }\n        if (params.state && !checks.state) {\n            throw new TypeError('checks.state argument is missing');\n        }\n        if (!params.state && checks.state) {\n            throw new RPError({\n                message: 'state missing from the response',\n                checks,\n                params\n            });\n        }\n        if (checks.state !== params.state) {\n            throw new RPError({\n                printf: [\n                    'state mismatch, expected %s, got: %s',\n                    checks.state,\n                    params.state\n                ],\n                checks,\n                params\n            });\n        }\n        if ('iss' in params) {\n            assertIssuerConfiguration(this.issuer, 'issuer');\n            if (params.iss !== this.issuer.issuer) {\n                throw new RPError({\n                    printf: [\n                        'iss mismatch, expected %s, got: %s',\n                        this.issuer.issuer,\n                        params.iss\n                    ],\n                    params\n                });\n            }\n        } else if (this.issuer.authorization_response_iss_parameter_supported && !('id_token' in params) && !('response' in parameters)) {\n            throw new RPError({\n                message: 'iss missing from the response',\n                params\n            });\n        }\n        if (params.error) {\n            throw new OPError(params);\n        }\n        const RESPONSE_TYPE_REQUIRED_PARAMS = {\n            code: [\n                'code'\n            ],\n            id_token: [\n                'id_token'\n            ],\n            token: [\n                'access_token',\n                'token_type'\n            ]\n        };\n        if (checks.response_type) {\n            for (const type of checks.response_type.split(' ')){\n                if (type === 'none') {\n                    if (params.code || params.id_token || params.access_token) {\n                        throw new RPError({\n                            message: 'unexpected params encountered for \"none\" response',\n                            checks,\n                            params\n                        });\n                    }\n                } else {\n                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){\n                        if (!params[param]) {\n                            throw new RPError({\n                                message: `${param} missing from response`,\n                                checks,\n                                params\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if (params.id_token) {\n            const tokenset = new TokenSet(params);\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state);\n            if (!params.code) {\n                return tokenset;\n            }\n        }\n        if (params.code) {\n            const tokenset = await this.grant({\n                ...exchangeBody,\n                grant_type: 'authorization_code',\n                code: params.code,\n                redirect_uri: redirectUri,\n                code_verifier: checks.code_verifier\n            }, {\n                clientAssertionPayload,\n                DPoP\n            });\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age);\n            if (params.session_state) {\n                tokenset.session_state = params.session_state;\n            }\n            return tokenset;\n        }\n        return new TokenSet(params);\n    }\n    async oauthCallback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let params = pickCb(parameters);\n        if (checks.jarm && !('response' in parameters)) {\n            throw new RPError({\n                message: 'expected a JARM response',\n                checks,\n                params\n            });\n        } else if ('response' in parameters) {\n            const decrypted = await this.decryptJARM(params.response);\n            params = await this.validateJARM(decrypted);\n        }\n        if (params.state && !checks.state) {\n            throw new TypeError('checks.state argument is missing');\n        }\n        if (!params.state && checks.state) {\n            throw new RPError({\n                message: 'state missing from the response',\n                checks,\n                params\n            });\n        }\n        if (checks.state !== params.state) {\n            throw new RPError({\n                printf: [\n                    'state mismatch, expected %s, got: %s',\n                    checks.state,\n                    params.state\n                ],\n                checks,\n                params\n            });\n        }\n        if ('iss' in params) {\n            assertIssuerConfiguration(this.issuer, 'issuer');\n            if (params.iss !== this.issuer.issuer) {\n                throw new RPError({\n                    printf: [\n                        'iss mismatch, expected %s, got: %s',\n                        this.issuer.issuer,\n                        params.iss\n                    ],\n                    params\n                });\n            }\n        } else if (this.issuer.authorization_response_iss_parameter_supported && !('id_token' in params) && !('response' in parameters)) {\n            throw new RPError({\n                message: 'iss missing from the response',\n                params\n            });\n        }\n        if (params.error) {\n            throw new OPError(params);\n        }\n        if (typeof params.id_token === 'string' && params.id_token.length) {\n            throw new RPError({\n                message: 'id_token detected in the response, you must use client.callback() instead of client.oauthCallback()',\n                params\n            });\n        }\n        delete params.id_token;\n        const RESPONSE_TYPE_REQUIRED_PARAMS = {\n            code: [\n                'code'\n            ],\n            token: [\n                'access_token',\n                'token_type'\n            ]\n        };\n        if (checks.response_type) {\n            for (const type of checks.response_type.split(' ')){\n                if (type === 'none') {\n                    if (params.code || params.id_token || params.access_token) {\n                        throw new RPError({\n                            message: 'unexpected params encountered for \"none\" response',\n                            checks,\n                            params\n                        });\n                    }\n                }\n                if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){\n                        if (!params[param]) {\n                            throw new RPError({\n                                message: `${param} missing from response`,\n                                checks,\n                                params\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if (params.code) {\n            const tokenset = await this.grant({\n                ...exchangeBody,\n                grant_type: 'authorization_code',\n                code: params.code,\n                redirect_uri: redirectUri,\n                code_verifier: checks.code_verifier\n            }, {\n                clientAssertionPayload,\n                DPoP\n            });\n            if (typeof tokenset.id_token === 'string' && tokenset.id_token.length) {\n                throw new RPError({\n                    message: 'id_token detected in the response, you must use client.callback() instead of client.oauthCallback()',\n                    params\n                });\n            }\n            delete tokenset.id_token;\n            return tokenset;\n        }\n        return new TokenSet(params);\n    }\n    async decryptIdToken(token) {\n        if (!this.id_token_encrypted_response_alg) {\n            return token;\n        }\n        let idToken = token;\n        if (idToken instanceof TokenSet) {\n            if (!idToken.id_token) {\n                throw new TypeError('id_token not present in TokenSet');\n            }\n            idToken = idToken.id_token;\n        }\n        const expectedAlg = this.id_token_encrypted_response_alg;\n        const expectedEnc = this.id_token_encrypted_response_enc;\n        const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);\n        if (token instanceof TokenSet) {\n            token.id_token = result;\n            return token;\n        }\n        return result;\n    }\n    async validateJWTUserinfo(body) {\n        const expectedAlg = this.userinfo_signed_response_alg;\n        return this.validateJWT(body, expectedAlg, []);\n    }\n    async decryptJARM(response) {\n        if (!this.authorization_encrypted_response_alg) {\n            return response;\n        }\n        const expectedAlg = this.authorization_encrypted_response_alg;\n        const expectedEnc = this.authorization_encrypted_response_enc;\n        return this.decryptJWE(response, expectedAlg, expectedEnc);\n    }\n    async decryptJWTUserinfo(body) {\n        if (!this.userinfo_encrypted_response_alg) {\n            return body;\n        }\n        const expectedAlg = this.userinfo_encrypted_response_alg;\n        const expectedEnc = this.userinfo_encrypted_response_enc;\n        return this.decryptJWE(body, expectedAlg, expectedEnc);\n    }\n    async decryptJWE(jwe, expectedAlg, expectedEnc = 'A128CBC-HS256') {\n        const header = JSON.parse(base64url.decode(jwe.split('.')[0]));\n        if (header.alg !== expectedAlg) {\n            throw new RPError({\n                printf: [\n                    'unexpected JWE alg received, expected %s, got: %s',\n                    expectedAlg,\n                    header.alg\n                ],\n                jwt: jwe\n            });\n        }\n        if (header.enc !== expectedEnc) {\n            throw new RPError({\n                printf: [\n                    'unexpected JWE enc received, expected %s, got: %s',\n                    expectedEnc,\n                    header.enc\n                ],\n                jwt: jwe\n            });\n        }\n        const getPlaintext = (result)=>new TextDecoder().decode(result.plaintext);\n        let plaintext;\n        if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n            const keystore = await keystores.get(this);\n            const protectedHeader = jose.decodeProtectedHeader(jwe);\n            for (const key of keystore.all({\n                ...protectedHeader,\n                use: 'enc'\n            })){\n                plaintext = await jose.compactDecrypt(jwe, await key.keyObject(protectedHeader.alg)).then(getPlaintext, ()=>{});\n                if (plaintext) break;\n            }\n        } else {\n            plaintext = await jose.compactDecrypt(jwe, this.secretForAlg(expectedAlg === 'dir' ? expectedEnc : expectedAlg)).then(getPlaintext, ()=>{});\n        }\n        if (!plaintext) {\n            throw new RPError({\n                message: 'failed to decrypt JWE',\n                jwt: jwe\n            });\n        }\n        return plaintext;\n    }\n    async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n        let idToken = tokenSet;\n        const expectedAlg = this.id_token_signed_response_alg;\n        const isTokenSet = idToken instanceof TokenSet;\n        if (isTokenSet) {\n            if (!idToken.id_token) {\n                throw new TypeError('id_token not present in TokenSet');\n            }\n            idToken = idToken.id_token;\n        }\n        idToken = String(idToken);\n        const timestamp = now();\n        const { protected: header, payload, key } = await this.validateJWT(idToken, expectedAlg);\n        if (typeof maxAge === 'number' || maxAge !== skipMaxAgeCheck && this.require_auth_time) {\n            if (!payload.auth_time) {\n                throw new RPError({\n                    message: 'missing required JWT property auth_time',\n                    jwt: idToken\n                });\n            }\n            if (typeof payload.auth_time !== 'number') {\n                throw new RPError({\n                    message: 'JWT auth_time claim must be a JSON numeric value',\n                    jwt: idToken\n                });\n            }\n        }\n        if (typeof maxAge === 'number' && payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]) {\n            throw new RPError({\n                printf: [\n                    'too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i',\n                    maxAge,\n                    payload.auth_time,\n                    timestamp - this[CLOCK_TOLERANCE]\n                ],\n                now: timestamp,\n                tolerance: this[CLOCK_TOLERANCE],\n                auth_time: payload.auth_time,\n                jwt: idToken\n            });\n        }\n        if (nonce !== skipNonceCheck && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {\n            throw new RPError({\n                printf: [\n                    'nonce mismatch, expected %s, got: %s',\n                    nonce,\n                    payload.nonce\n                ],\n                jwt: idToken\n            });\n        }\n        if (returnedBy === 'authorization') {\n            if (!payload.at_hash && tokenSet.access_token) {\n                throw new RPError({\n                    message: 'missing required property at_hash',\n                    jwt: idToken\n                });\n            }\n            if (!payload.c_hash && tokenSet.code) {\n                throw new RPError({\n                    message: 'missing required property c_hash',\n                    jwt: idToken\n                });\n            }\n            if (this.fapi1()) {\n                if (!payload.s_hash && (tokenSet.state || state)) {\n                    throw new RPError({\n                        message: 'missing required property s_hash',\n                        jwt: idToken\n                    });\n                }\n            }\n            if (payload.s_hash) {\n                if (!state) {\n                    throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n                }\n                try {\n                    tokenHash.validate({\n                        claim: 's_hash',\n                        source: 'state'\n                    }, payload.s_hash, state, header.alg, key.jwk && key.jwk.crv);\n                } catch (err) {\n                    throw new RPError({\n                        message: err.message,\n                        jwt: idToken\n                    });\n                }\n            }\n        }\n        if (this.fapi() && payload.iat < timestamp - 3600) {\n            throw new RPError({\n                printf: [\n                    'JWT issued too far in the past, now %i, iat %i',\n                    timestamp,\n                    payload.iat\n                ],\n                now: timestamp,\n                tolerance: this[CLOCK_TOLERANCE],\n                iat: payload.iat,\n                jwt: idToken\n            });\n        }\n        if (tokenSet.access_token && payload.at_hash !== undefined) {\n            try {\n                tokenHash.validate({\n                    claim: 'at_hash',\n                    source: 'access_token'\n                }, payload.at_hash, tokenSet.access_token, header.alg, key.jwk && key.jwk.crv);\n            } catch (err) {\n                throw new RPError({\n                    message: err.message,\n                    jwt: idToken\n                });\n            }\n        }\n        if (tokenSet.code && payload.c_hash !== undefined) {\n            try {\n                tokenHash.validate({\n                    claim: 'c_hash',\n                    source: 'code'\n                }, payload.c_hash, tokenSet.code, header.alg, key.jwk && key.jwk.crv);\n            } catch (err) {\n                throw new RPError({\n                    message: err.message,\n                    jwt: idToken\n                });\n            }\n        }\n        return tokenSet;\n    }\n    async validateJWT(jwt, expectedAlg, required = [\n        'iss',\n        'sub',\n        'aud',\n        'exp',\n        'iat'\n    ]) {\n        const isSelfIssued = this.issuer.issuer === 'https://self-issued.me';\n        const timestamp = now();\n        let header;\n        let payload;\n        try {\n            ({ header, payload } = decodeJWT(jwt, {\n                complete: true\n            }));\n        } catch (err) {\n            throw new RPError({\n                printf: [\n                    'failed to decode JWT (%s: %s)',\n                    err.name,\n                    err.message\n                ],\n                jwt\n            });\n        }\n        if (header.alg !== expectedAlg) {\n            throw new RPError({\n                printf: [\n                    'unexpected JWT alg received, expected %s, got: %s',\n                    expectedAlg,\n                    header.alg\n                ],\n                jwt\n            });\n        }\n        if (isSelfIssued) {\n            required = [\n                ...required,\n                'sub_jwk'\n            ];\n        }\n        required.forEach(verifyPresence.bind(undefined, payload, jwt));\n        if (payload.iss !== undefined) {\n            let expectedIss = this.issuer.issuer;\n            if (this.#aadIssValidation) {\n                expectedIss = this.issuer.issuer.replace('{tenantid}', payload.tid);\n            }\n            if (payload.iss !== expectedIss) {\n                throw new RPError({\n                    printf: [\n                        'unexpected iss value, expected %s, got: %s',\n                        expectedIss,\n                        payload.iss\n                    ],\n                    jwt\n                });\n            }\n        }\n        if (payload.iat !== undefined) {\n            if (typeof payload.iat !== 'number') {\n                throw new RPError({\n                    message: 'JWT iat claim must be a JSON numeric value',\n                    jwt\n                });\n            }\n        }\n        if (payload.nbf !== undefined) {\n            if (typeof payload.nbf !== 'number') {\n                throw new RPError({\n                    message: 'JWT nbf claim must be a JSON numeric value',\n                    jwt\n                });\n            }\n            if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n                throw new RPError({\n                    printf: [\n                        'JWT not active yet, now %i, nbf %i',\n                        timestamp + this[CLOCK_TOLERANCE],\n                        payload.nbf\n                    ],\n                    now: timestamp,\n                    tolerance: this[CLOCK_TOLERANCE],\n                    nbf: payload.nbf,\n                    jwt\n                });\n            }\n        }\n        if (payload.exp !== undefined) {\n            if (typeof payload.exp !== 'number') {\n                throw new RPError({\n                    message: 'JWT exp claim must be a JSON numeric value',\n                    jwt\n                });\n            }\n            if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n                throw new RPError({\n                    printf: [\n                        'JWT expired, now %i, exp %i',\n                        timestamp - this[CLOCK_TOLERANCE],\n                        payload.exp\n                    ],\n                    now: timestamp,\n                    tolerance: this[CLOCK_TOLERANCE],\n                    exp: payload.exp,\n                    jwt\n                });\n            }\n        }\n        if (payload.aud !== undefined) {\n            if (Array.isArray(payload.aud)) {\n                if (payload.aud.length > 1 && !payload.azp) {\n                    throw new RPError({\n                        message: 'missing required JWT property azp',\n                        jwt\n                    });\n                }\n                if (!payload.aud.includes(this.client_id)) {\n                    throw new RPError({\n                        printf: [\n                            'aud is missing the client_id, expected %s to be included in %j',\n                            this.client_id,\n                            payload.aud\n                        ],\n                        jwt\n                    });\n                }\n            } else if (payload.aud !== this.client_id) {\n                throw new RPError({\n                    printf: [\n                        'aud mismatch, expected %s, got: %s',\n                        this.client_id,\n                        payload.aud\n                    ],\n                    jwt\n                });\n            }\n        }\n        if (payload.azp !== undefined) {\n            let additionalAuthorizedParties = this.#additionalAuthorizedParties;\n            if (typeof additionalAuthorizedParties === 'string') {\n                additionalAuthorizedParties = [\n                    this.client_id,\n                    additionalAuthorizedParties\n                ];\n            } else if (Array.isArray(additionalAuthorizedParties)) {\n                additionalAuthorizedParties = [\n                    this.client_id,\n                    ...additionalAuthorizedParties\n                ];\n            } else {\n                additionalAuthorizedParties = [\n                    this.client_id\n                ];\n            }\n            if (!additionalAuthorizedParties.includes(payload.azp)) {\n                throw new RPError({\n                    printf: [\n                        'azp mismatch, got: %s',\n                        payload.azp\n                    ],\n                    jwt\n                });\n            }\n        }\n        let keys;\n        if (isSelfIssued) {\n            try {\n                assert(isPlainObject(payload.sub_jwk));\n                const key = await jose.importJWK(payload.sub_jwk, header.alg);\n                assert.equal(key.type, 'public');\n                keys = [\n                    {\n                        keyObject () {\n                            return key;\n                        }\n                    }\n                ];\n            } catch (err) {\n                throw new RPError({\n                    message: 'failed to use sub_jwk claim as an asymmetric JSON Web Key',\n                    jwt\n                });\n            }\n            if (await jose.calculateJwkThumbprint(payload.sub_jwk) !== payload.sub) {\n                throw new RPError({\n                    message: 'failed to match the subject with sub_jwk',\n                    jwt\n                });\n            }\n        } else if (header.alg.startsWith('HS')) {\n            keys = [\n                this.secretForAlg(header.alg)\n            ];\n        } else if (header.alg !== 'none') {\n            keys = await queryKeyStore.call(this.issuer, {\n                ...header,\n                use: 'sig'\n            });\n        }\n        if (!keys && header.alg === 'none') {\n            return {\n                protected: header,\n                payload\n            };\n        }\n        for (const key of keys){\n            const verified = await jose.compactVerify(jwt, key instanceof Uint8Array ? key : await key.keyObject(header.alg)).catch(()=>{});\n            if (verified) {\n                return {\n                    payload,\n                    protected: verified.protectedHeader,\n                    key\n                };\n            }\n        }\n        throw new RPError({\n            message: 'failed to validate JWT signature',\n            jwt\n        });\n    }\n    async refresh(refreshToken, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let token = refreshToken;\n        if (token instanceof TokenSet) {\n            if (!token.refresh_token) {\n                throw new TypeError('refresh_token not present in TokenSet');\n            }\n            token = token.refresh_token;\n        }\n        const tokenset = await this.grant({\n            ...exchangeBody,\n            grant_type: 'refresh_token',\n            refresh_token: String(token)\n        }, {\n            clientAssertionPayload,\n            DPoP\n        });\n        if (tokenset.id_token) {\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, skipNonceCheck, 'token', skipMaxAgeCheck);\n            if (refreshToken instanceof TokenSet && refreshToken.id_token) {\n                const expectedSub = refreshToken.claims().sub;\n                const actualSub = tokenset.claims().sub;\n                if (actualSub !== expectedSub) {\n                    throw new RPError({\n                        printf: [\n                            'sub mismatch, expected %s, got: %s',\n                            expectedSub,\n                            actualSub\n                        ],\n                        jwt: tokenset.id_token\n                    });\n                }\n            }\n        }\n        return tokenset;\n    }\n    async requestResource(resourceUrl, accessToken, { method, headers, body, DPoP, tokenType = DPoP ? 'DPoP' : accessToken instanceof TokenSet ? accessToken.token_type : 'Bearer' } = {}, retry) {\n        if (accessToken instanceof TokenSet) {\n            if (!accessToken.access_token) {\n                throw new TypeError('access_token not present in TokenSet');\n            }\n            accessToken = accessToken.access_token;\n        }\n        if (!accessToken) {\n            throw new TypeError('no access token provided');\n        } else if (typeof accessToken !== 'string') {\n            throw new TypeError('invalid access token provided');\n        }\n        const requestOpts = {\n            headers: {\n                Authorization: authorizationHeaderValue(accessToken, tokenType),\n                ...headers\n            },\n            body\n        };\n        const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n        const response = await request.call(this, {\n            ...requestOpts,\n            responseType: 'buffer',\n            method,\n            url: resourceUrl\n        }, {\n            accessToken,\n            mTLS,\n            DPoP\n        });\n        const wwwAuthenticate = response.headers['www-authenticate'];\n        if (retry !== retryAttempt && wwwAuthenticate && wwwAuthenticate.toLowerCase().startsWith('dpop ') && parseWwwAuthenticate(wwwAuthenticate).error === 'use_dpop_nonce') {\n            return this.requestResource(resourceUrl, accessToken, {\n                method,\n                headers,\n                body,\n                DPoP,\n                tokenType\n            });\n        }\n        return response;\n    }\n    async userinfo(accessToken, { method = 'GET', via = 'header', tokenType, params, DPoP } = {}) {\n        assertIssuerConfiguration(this.issuer, 'userinfo_endpoint');\n        const options = {\n            tokenType,\n            method: String(method).toUpperCase(),\n            DPoP\n        };\n        if (options.method !== 'GET' && options.method !== 'POST') {\n            throw new TypeError('#userinfo() method can only be POST or a GET');\n        }\n        if (via === 'body' && options.method !== 'POST') {\n            throw new TypeError('can only send body on POST');\n        }\n        const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);\n        if (jwt) {\n            options.headers = {\n                Accept: 'application/jwt'\n            };\n        } else {\n            options.headers = {\n                Accept: 'application/json'\n            };\n        }\n        const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n        let targetUrl;\n        if (mTLS && this.issuer.mtls_endpoint_aliases) {\n            targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n        }\n        targetUrl = new URL(targetUrl || this.issuer.userinfo_endpoint);\n        if (via === 'body') {\n            options.headers.Authorization = undefined;\n            options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            options.body = new URLSearchParams();\n            options.body.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n        }\n        // handle additional parameters, GET via querystring, POST via urlencoded body\n        if (params) {\n            if (options.method === 'GET') {\n                Object.entries(params).forEach(([key, value])=>{\n                    targetUrl.searchParams.append(key, value);\n                });\n            } else if (options.body) {\n                // POST && via body\n                Object.entries(params).forEach(([key, value])=>{\n                    options.body.append(key, value);\n                });\n            } else {\n                // POST && via header\n                options.body = new URLSearchParams();\n                options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n                Object.entries(params).forEach(([key, value])=>{\n                    options.body.append(key, value);\n                });\n            }\n        }\n        if (options.body) {\n            options.body = options.body.toString();\n        }\n        const response = await this.requestResource(targetUrl, accessToken, options);\n        let parsed = processResponse(response, {\n            bearer: true\n        });\n        if (jwt) {\n            if (!/^application\\/jwt/.test(response.headers['content-type'])) {\n                throw new RPError({\n                    message: 'expected application/jwt response from the userinfo_endpoint',\n                    response\n                });\n            }\n            const body = response.body.toString();\n            const userinfo = await this.decryptJWTUserinfo(body);\n            if (!this.userinfo_signed_response_alg) {\n                try {\n                    parsed = JSON.parse(userinfo);\n                    assert(isPlainObject(parsed));\n                } catch (err) {\n                    throw new RPError({\n                        message: 'failed to parse userinfo JWE payload as JSON',\n                        jwt: userinfo\n                    });\n                }\n            } else {\n                ({ payload: parsed } = await this.validateJWTUserinfo(userinfo));\n            }\n        } else {\n            try {\n                parsed = JSON.parse(response.body);\n            } catch (err) {\n                Object.defineProperty(err, 'response', {\n                    value: response\n                });\n                throw err;\n            }\n        }\n        if (accessToken instanceof TokenSet && accessToken.id_token) {\n            const expectedSub = accessToken.claims().sub;\n            if (parsed.sub !== expectedSub) {\n                throw new RPError({\n                    printf: [\n                        'userinfo sub mismatch, expected %s, got: %s',\n                        expectedSub,\n                        parsed.sub\n                    ],\n                    body: parsed,\n                    jwt: accessToken.id_token\n                });\n            }\n        }\n        return parsed;\n    }\n    encryptionSecret(len) {\n        const hash = len <= 256 ? 'sha256' : len <= 384 ? 'sha384' : len <= 512 ? 'sha512' : false;\n        if (!hash) {\n            throw new Error('unsupported symmetric encryption key derivation');\n        }\n        return crypto.createHash(hash).update(this.client_secret).digest().slice(0, len / 8);\n    }\n    secretForAlg(alg) {\n        if (!this.client_secret) {\n            throw new TypeError('client_secret is required');\n        }\n        if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n            return this.encryptionSecret(parseInt(RegExp.$1, 10));\n        }\n        if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n            return this.encryptionSecret(parseInt(RegExp.$2 || RegExp.$1, 10));\n        }\n        return new TextEncoder().encode(this.client_secret);\n    }\n    async grant(body, { clientAssertionPayload, DPoP } = {}, retry) {\n        assertIssuerConfiguration(this.issuer, 'token_endpoint');\n        const response = await authenticatedPost.call(this, 'token', {\n            form: body,\n            responseType: 'json'\n        }, {\n            clientAssertionPayload,\n            DPoP\n        });\n        let responseBody;\n        try {\n            responseBody = processResponse(response);\n        } catch (err) {\n            if (retry !== retryAttempt && err instanceof OPError && err.error === 'use_dpop_nonce') {\n                return this.grant(body, {\n                    clientAssertionPayload,\n                    DPoP\n                }, retryAttempt);\n            }\n            throw err;\n        }\n        return new TokenSet(responseBody);\n    }\n    async deviceAuthorization(params = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        assertIssuerConfiguration(this.issuer, 'device_authorization_endpoint');\n        assertIssuerConfiguration(this.issuer, 'token_endpoint');\n        const body = authorizationParams.call(this, {\n            client_id: this.client_id,\n            redirect_uri: null,\n            response_type: null,\n            ...params\n        });\n        const response = await authenticatedPost.call(this, 'device_authorization', {\n            responseType: 'json',\n            form: body\n        }, {\n            clientAssertionPayload,\n            endpointAuthMethod: 'token'\n        });\n        const responseBody = processResponse(response);\n        return new DeviceFlowHandle({\n            client: this,\n            exchangeBody,\n            clientAssertionPayload,\n            response: responseBody,\n            maxAge: params.max_age,\n            DPoP\n        });\n    }\n    async revoke(token, hint, { revokeBody, clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, 'revocation_endpoint');\n        if (hint !== undefined && typeof hint !== 'string') {\n            throw new TypeError('hint must be a string');\n        }\n        const form = {\n            ...revokeBody,\n            token\n        };\n        if (hint) {\n            form.token_type_hint = hint;\n        }\n        const response = await authenticatedPost.call(this, 'revocation', {\n            form\n        }, {\n            clientAssertionPayload\n        });\n        processResponse(response, {\n            body: false\n        });\n    }\n    async introspect(token, hint, { introspectBody, clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, 'introspection_endpoint');\n        if (hint !== undefined && typeof hint !== 'string') {\n            throw new TypeError('hint must be a string');\n        }\n        const form = {\n            ...introspectBody,\n            token\n        };\n        if (hint) {\n            form.token_type_hint = hint;\n        }\n        const response = await authenticatedPost.call(this, 'introspection', {\n            form,\n            responseType: 'json'\n        }, {\n            clientAssertionPayload\n        });\n        const responseBody = processResponse(response);\n        return responseBody;\n    }\n    static async register(metadata, options = {}) {\n        const { initialAccessToken, jwks, ...clientOptions } = options;\n        assertIssuerConfiguration(this.issuer, 'registration_endpoint');\n        if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {\n            const keystore = await getKeystore.call(this, jwks);\n            metadata.jwks = keystore.toJWKS();\n        }\n        const response = await request.call(this, {\n            headers: {\n                Accept: 'application/json',\n                ...initialAccessToken ? {\n                    Authorization: authorizationHeaderValue(initialAccessToken)\n                } : undefined\n            },\n            responseType: 'json',\n            json: metadata,\n            url: this.issuer.registration_endpoint,\n            method: 'POST'\n        });\n        const responseBody = processResponse(response, {\n            statusCode: 201,\n            bearer: true\n        });\n        return new this(responseBody, jwks, clientOptions);\n    }\n    get metadata() {\n        return clone(Object.fromEntries(this.#metadata.entries()));\n    }\n    static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {\n        const response = await request.call(this, {\n            method: 'GET',\n            url: registrationClientUri,\n            responseType: 'json',\n            headers: {\n                Authorization: authorizationHeaderValue(registrationAccessToken),\n                Accept: 'application/json'\n            }\n        });\n        const responseBody = processResponse(response, {\n            bearer: true\n        });\n        return new this(responseBody, jwks, clientOptions);\n    }\n    async requestObject(requestObject = {}, { sign: signingAlgorithm = this.request_object_signing_alg || 'none', encrypt: { alg: eKeyManagement = this.request_object_encryption_alg, enc: eContentEncryption = this.request_object_encryption_enc || 'A128CBC-HS256' } = {} } = {}) {\n        if (!isPlainObject(requestObject)) {\n            throw new TypeError('requestObject must be a plain object');\n        }\n        let signed;\n        let key;\n        const unix = now();\n        const header = {\n            alg: signingAlgorithm,\n            typ: 'oauth-authz-req+jwt'\n        };\n        const payload = JSON.stringify(defaults({}, requestObject, {\n            iss: this.client_id,\n            aud: this.issuer.issuer,\n            client_id: this.client_id,\n            jti: random(),\n            iat: unix,\n            exp: unix + 300,\n            ...this.fapi() ? {\n                nbf: unix\n            } : undefined\n        }));\n        if (signingAlgorithm === 'none') {\n            signed = [\n                base64url.encode(JSON.stringify(header)),\n                base64url.encode(payload),\n                ''\n            ].join('.');\n        } else {\n            const symmetric = signingAlgorithm.startsWith('HS');\n            if (symmetric) {\n                key = this.secretForAlg(signingAlgorithm);\n            } else {\n                const keystore = await keystores.get(this);\n                if (!keystore) {\n                    throw new TypeError(`no keystore present for client, cannot sign using alg ${signingAlgorithm}`);\n                }\n                key = keystore.get({\n                    alg: signingAlgorithm,\n                    use: 'sig'\n                });\n                if (!key) {\n                    throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);\n                }\n            }\n            signed = await new jose.CompactSign(new TextEncoder().encode(payload)).setProtectedHeader({\n                ...header,\n                kid: symmetric ? undefined : key.jwk.kid\n            }).sign(symmetric ? key : await key.keyObject(signingAlgorithm));\n        }\n        if (!eKeyManagement) {\n            return signed;\n        }\n        const fields = {\n            alg: eKeyManagement,\n            enc: eContentEncryption,\n            cty: 'oauth-authz-req+jwt'\n        };\n        if (fields.alg.match(/^(RSA|ECDH)/)) {\n            [key] = await queryKeyStore.call(this.issuer, {\n                alg: fields.alg,\n                use: 'enc'\n            }, {\n                allowMulti: true\n            });\n        } else {\n            key = this.secretForAlg(fields.alg === 'dir' ? fields.enc : fields.alg);\n        }\n        return new jose.CompactEncrypt(new TextEncoder().encode(signed)).setProtectedHeader({\n            ...fields,\n            kid: key instanceof Uint8Array ? undefined : key.jwk.kid\n        }).encrypt(key instanceof Uint8Array ? key : await key.keyObject(fields.alg));\n    }\n    async pushedAuthorizationRequest(params = {}, { clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, 'pushed_authorization_request_endpoint');\n        const body = {\n            ...'request' in params ? params : authorizationParams.call(this, params),\n            client_id: this.client_id\n        };\n        const response = await authenticatedPost.call(this, 'pushed_authorization_request', {\n            responseType: 'json',\n            form: body\n        }, {\n            clientAssertionPayload,\n            endpointAuthMethod: 'token'\n        });\n        const responseBody = processResponse(response, {\n            statusCode: 201\n        });\n        if (!('expires_in' in responseBody)) {\n            throw new RPError({\n                message: 'expected expires_in in Pushed Authorization Successful Response',\n                response\n            });\n        }\n        if (typeof responseBody.expires_in !== 'number') {\n            throw new RPError({\n                message: 'invalid expires_in value in Pushed Authorization Successful Response',\n                response\n            });\n        }\n        if (!('request_uri' in responseBody)) {\n            throw new RPError({\n                message: 'expected request_uri in Pushed Authorization Successful Response',\n                response\n            });\n        }\n        if (typeof responseBody.request_uri !== 'string') {\n            throw new RPError({\n                message: 'invalid request_uri value in Pushed Authorization Successful Response',\n                response\n            });\n        }\n        return responseBody;\n    }\n    get issuer() {\n        return this.#issuer;\n    }\n    /* istanbul ignore next */ [inspect.custom]() {\n        return `${this.constructor.name} ${inspect(this.metadata, {\n            depth: Infinity,\n            colors: process.stdout.isTTY,\n            compact: false,\n            sorted: true\n        })}`;\n    }\n    fapi() {\n        return this.fapi1() || this.fapi2();\n    }\n    fapi1() {\n        return this.constructor.name === 'FAPI1Client';\n    }\n    fapi2() {\n        return this.constructor.name === 'FAPI2Client';\n    }\n    async validateJARM(response) {\n        const expectedAlg = this.authorization_signed_response_alg;\n        const { payload } = await this.validateJWT(response, expectedAlg, [\n            'iss',\n            'exp',\n            'aud'\n        ]);\n        return pickCb(payload);\n    }\n    /**\n   * @name dpopProof\n   * @api private\n   */ async dpopProof(payload, privateKeyInput, accessToken) {\n        if (!isPlainObject(payload)) {\n            throw new TypeError('payload must be a plain object');\n        }\n        let privateKey;\n        if (isKeyObject(privateKeyInput)) {\n            privateKey = privateKeyInput;\n        } else if (privateKeyInput[Symbol.toStringTag] === 'CryptoKey') {\n            privateKey = privateKeyInput;\n        } else if (jose.cryptoRuntime === 'node:crypto') {\n            privateKey = crypto.createPrivateKey(privateKeyInput);\n        } else {\n            throw new TypeError('unrecognized crypto runtime');\n        }\n        if (privateKey.type !== 'private') {\n            throw new TypeError('\"DPoP\" option must be a private key');\n        }\n        let alg = determineDPoPAlgorithm.call(this, privateKey, privateKeyInput);\n        if (!alg) {\n            throw new TypeError('could not determine DPoP JWS Algorithm');\n        }\n        return new jose.SignJWT({\n            ath: accessToken ? base64url.encode(crypto.createHash('sha256').update(accessToken).digest()) : undefined,\n            ...payload\n        }).setProtectedHeader({\n            alg,\n            typ: 'dpop+jwt',\n            jwk: await getJwk(privateKey, privateKeyInput)\n        }).setIssuedAt().setJti(random()).sign(privateKey);\n    }\n}\nfunction determineDPoPAlgorithmFromCryptoKey(cryptoKey) {\n    switch(cryptoKey.algorithm.name){\n        case 'Ed25519':\n        case 'Ed448':\n            return 'EdDSA';\n        case 'ECDSA':\n            {\n                switch(cryptoKey.algorithm.namedCurve){\n                    case 'P-256':\n                        return 'ES256';\n                    case 'P-384':\n                        return 'ES384';\n                    case 'P-521':\n                        return 'ES512';\n                    default:\n                        break;\n                }\n                break;\n            }\n        case 'RSASSA-PKCS1-v1_5':\n            return `RS${cryptoKey.algorithm.hash.name.slice(4)}`;\n        case 'RSA-PSS':\n            return `PS${cryptoKey.algorithm.hash.name.slice(4)}`;\n        default:\n            throw new TypeError('unsupported DPoP private key');\n    }\n}\nlet determineDPoPAlgorithm;\nif (jose.cryptoRuntime === 'node:crypto') {\n    determineDPoPAlgorithm = function(privateKey, privateKeyInput) {\n        if (privateKeyInput[Symbol.toStringTag] === 'CryptoKey') {\n            return determineDPoPAlgorithmFromCryptoKey(privateKey);\n        }\n        switch(privateKey.asymmetricKeyType){\n            case 'ed25519':\n            case 'ed448':\n                return 'EdDSA';\n            case 'ec':\n                return determineEcAlgorithm(privateKey, privateKeyInput);\n            case 'rsa':\n            case rsaPssParams && 'rsa-pss':\n                return determineRsaAlgorithm(privateKey, privateKeyInput, this.issuer.dpop_signing_alg_values_supported);\n            default:\n                throw new TypeError('unsupported DPoP private key');\n        }\n    };\n    const RSPS = /^(?:RS|PS)(?:256|384|512)$/;\n    function determineRsaAlgorithm(privateKey, privateKeyInput, valuesSupported) {\n        if (typeof privateKeyInput === 'object' && privateKeyInput.format === 'jwk' && privateKeyInput.key && privateKeyInput.key.alg) {\n            return privateKeyInput.key.alg;\n        }\n        if (Array.isArray(valuesSupported)) {\n            let candidates = valuesSupported.filter(RegExp.prototype.test.bind(RSPS));\n            if (privateKey.asymmetricKeyType === 'rsa-pss') {\n                candidates = candidates.filter((value)=>value.startsWith('PS'));\n            }\n            return [\n                'PS256',\n                'PS384',\n                'PS512',\n                'RS256',\n                'RS384',\n                'RS384'\n            ].find((preferred)=>candidates.includes(preferred));\n        }\n        return 'PS256';\n    }\n    const p256 = Buffer.from([\n        42,\n        134,\n        72,\n        206,\n        61,\n        3,\n        1,\n        7\n    ]);\n    const p384 = Buffer.from([\n        43,\n        129,\n        4,\n        0,\n        34\n    ]);\n    const p521 = Buffer.from([\n        43,\n        129,\n        4,\n        0,\n        35\n    ]);\n    const secp256k1 = Buffer.from([\n        43,\n        129,\n        4,\n        0,\n        10\n    ]);\n    function determineEcAlgorithm(privateKey, privateKeyInput) {\n        // If input was a JWK\n        switch(typeof privateKeyInput === 'object' && typeof privateKeyInput.key === 'object' && privateKeyInput.key.crv){\n            case 'P-256':\n                return 'ES256';\n            case 'secp256k1':\n                return 'ES256K';\n            case 'P-384':\n                return 'ES384';\n            case 'P-512':\n                return 'ES512';\n            default:\n                break;\n        }\n        const buf = privateKey.export({\n            format: 'der',\n            type: 'pkcs8'\n        });\n        const i = buf[1] < 128 ? 17 : 18;\n        const len = buf[i];\n        const curveOid = buf.slice(i + 1, i + 1 + len);\n        if (curveOid.equals(p256)) {\n            return 'ES256';\n        }\n        if (curveOid.equals(p384)) {\n            return 'ES384';\n        }\n        if (curveOid.equals(p521)) {\n            return 'ES512';\n        }\n        if (curveOid.equals(secp256k1)) {\n            return 'ES256K';\n        }\n        throw new TypeError('unsupported DPoP private key curve');\n    }\n} else {\n    determineDPoPAlgorithm = determineDPoPAlgorithmFromCryptoKey;\n}\nconst jwkCache = new WeakMap();\nasync function getJwk(keyObject, privateKeyInput) {\n    if (jose.cryptoRuntime === 'node:crypto' && typeof privateKeyInput === 'object' && typeof privateKeyInput.key === 'object' && privateKeyInput.format === 'jwk') {\n        return pick(privateKeyInput.key, 'kty', 'crv', 'x', 'y', 'e', 'n');\n    }\n    if (jwkCache.has(privateKeyInput)) {\n        return jwkCache.get(privateKeyInput);\n    }\n    const jwk = pick(await jose.exportJWK(keyObject), 'kty', 'crv', 'x', 'y', 'e', 'n');\n    if (isKeyObject(privateKeyInput) || jose.cryptoRuntime === 'WebCryptoAPI') {\n        jwkCache.set(privateKeyInput, jwk);\n    }\n    return jwk;\n}\nmodule.exports = (issuer, aadIssValidation = false)=>class Client extends BaseClient {\n        constructor(...args){\n            super(issuer, aadIssValidation, ...args);\n        }\n        static get issuer() {\n            return issuer;\n        }\n    };\nmodule.exports.BaseClient = BaseClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxPQUFPLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsa0JBQU07QUFDbEMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsa0JBQU07QUFDOUIsTUFBTUUsU0FBU0YsbUJBQU9BLENBQUMsc0JBQVE7QUFDL0IsTUFBTSxFQUFFRyxRQUFRQyxNQUFNLEVBQUUsR0FBR0osbUJBQU9BLENBQUMsc0JBQVE7QUFDM0MsTUFBTUssY0FBY0wsbUJBQU9BLENBQUMsZ0NBQWE7QUFDekMsTUFBTU0sTUFBTU4sbUJBQU9BLENBQUMsZ0JBQUs7QUFDekIsTUFBTSxFQUFFTyxHQUFHLEVBQUVDLGVBQWUsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQyxnQkFBSztBQUU5QyxNQUFNUyxPQUFPVCxtQkFBT0EsQ0FBQywrREFBTTtBQUMzQixNQUFNVSxZQUFZVixtQkFBT0EsQ0FBQywyRUFBaUI7QUFFM0MsTUFBTVcsY0FBY1gsbUJBQU9BLENBQUMsaUdBQXlCO0FBQ3JELE1BQU1ZLFlBQVlaLG1CQUFPQSxDQUFDLDJGQUFzQjtBQUNoRCxNQUFNYSxZQUFZYixtQkFBT0EsQ0FBQyx5RkFBcUI7QUFDL0MsTUFBTWMsV0FBV2QsbUJBQU9BLENBQUMsdUZBQW9CO0FBQzdDLE1BQU1lLHVCQUF1QmYsbUJBQU9BLENBQUMscUhBQW1DO0FBQ3hFLE1BQU0sRUFBRWdCLDZCQUE2QixFQUFFQyx5QkFBeUIsRUFBRSxHQUFHakIsbUJBQU9BLENBQUMsbUZBQWtCO0FBQy9GLE1BQU1rQixPQUFPbEIsbUJBQU9BLENBQUMsK0VBQWdCO0FBQ3JDLE1BQU1tQixnQkFBZ0JuQixtQkFBT0EsQ0FBQyxxR0FBMkI7QUFDekQsTUFBTW9CLGtCQUFrQnBCLG1CQUFPQSxDQUFDLHVHQUE0QjtBQUM1RCxNQUFNcUIsV0FBV3JCLG1CQUFPQSxDQUFDLHlFQUFhO0FBQ3RDLE1BQU0sRUFB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QUNuQixLQUFLLENBQUNyVCxRQUFRa0IscUJBQXFCbVM7UUFDckM7UUFFQSxXQUFXclQsU0FBUztZQUNsQixPQUFPQTtRQUNUO0lBQ0Y7QUFFRmtULHlCQUF5QixHQUFHbFMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYW1hbHdhcmQvYXhpcy5wb2ludC9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgaW5zcGVjdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3Qgc3RkaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBzdHJpY3Q6IGFzc2VydCB9ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHsgVVJMLCBVUkxTZWFyY2hQYXJhbXMgfSA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBqb3NlID0gcmVxdWlyZSgnam9zZScpO1xuY29uc3QgdG9rZW5IYXNoID0gcmVxdWlyZSgnb2lkYy10b2tlbi1oYXNoJyk7XG5cbmNvbnN0IGlzS2V5T2JqZWN0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzX2tleV9vYmplY3QnKTtcbmNvbnN0IGRlY29kZUpXVCA9IHJlcXVpcmUoJy4vaGVscGVycy9kZWNvZGVfand0Jyk7XG5jb25zdCBiYXNlNjR1cmwgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmFzZTY0dXJsJyk7XG5jb25zdCBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vaGVscGVycy9kZWZhdWx0cycpO1xuY29uc3QgcGFyc2VXd3dBdXRoZW50aWNhdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvd3d3X2F1dGhlbnRpY2F0ZV9wYXJzZXInKTtcbmNvbnN0IHsgYXNzZXJ0U2lnbmluZ0FsZ1ZhbHVlc1N1cHBvcnQsIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24gfSA9IHJlcXVpcmUoJy4vaGVscGVycy9hc3NlcnQnKTtcbmNvbnN0IHBpY2sgPSByZXF1aXJlKCcuL2hlbHBlcnMvcGljaycpO1xuY29uc3QgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc19wbGFpbl9vYmplY3QnKTtcbmNvbnN0IHByb2Nlc3NSZXNwb25zZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9jZXNzX3Jlc3BvbnNlJyk7XG5jb25zdCBUb2tlblNldCA9IHJlcXVpcmUoJy4vdG9rZW5fc2V0Jyk7XG5jb25zdCB7IE9QRXJyb3IsIFJQRXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBub3cgPSByZXF1aXJlKCcuL2hlbHBlcnMvdW5peF90aW1lc3RhbXAnKTtcbmNvbnN0IHsgcmFuZG9tIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2VuZXJhdG9ycycpO1xuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJy4vaGVscGVycy9yZXF1ZXN0Jyk7XG5jb25zdCB7IENMT0NLX1RPTEVSQU5DRSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2NvbnN0cycpO1xuY29uc3QgeyBrZXlzdG9yZXMgfSA9IHJlcXVpcmUoJy4vaGVscGVycy93ZWFrX2NhY2hlJyk7XG5jb25zdCBLZXlTdG9yZSA9IHJlcXVpcmUoJy4vaGVscGVycy9rZXlzdG9yZScpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVlcF9jbG9uZScpO1xuY29uc3QgeyBhdXRoZW50aWNhdGVkUG9zdCwgcmVzb2x2ZVJlc3BvbnNlVHlwZSwgcmVzb2x2ZVJlZGlyZWN0VXJpIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xpZW50Jyk7XG5jb25zdCB7IHF1ZXJ5S2V5U3RvcmUgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc3N1ZXInKTtcbmNvbnN0IERldmljZUZsb3dIYW5kbGUgPSByZXF1aXJlKCcuL2RldmljZV9mbG93X2hhbmRsZScpO1xuXG5jb25zdCBbbWFqb3IsIG1pbm9yXSA9IHByb2Nlc3MudmVyc2lvblxuICAuc2xpY2UoMSlcbiAgLnNwbGl0KCcuJylcbiAgLm1hcCgoc3RyKSA9PiBwYXJzZUludChzdHIsIDEwKSk7XG5cbmNvbnN0IHJzYVBzc1BhcmFtcyA9IG1ham9yID49IDE3IHx8IChtYWpvciA9PT0gMTYgJiYgbWlub3IgPj0gOSk7XG5jb25zdCByZXRyeUF0dGVtcHQgPSBTeW1ib2woKTtcbmNvbnN0IHNraXBOb25jZUNoZWNrID0gU3ltYm9sKCk7XG5jb25zdCBza2lwTWF4QWdlQ2hlY2sgPSBTeW1ib2woKTtcblxuZnVuY3Rpb24gcGlja0NiKGlucHV0KSB7XG4gIHJldHVybiBwaWNrKFxuICAgIGlucHV0LFxuICAgICdhY2Nlc3NfdG9rZW4nLCAvLyBPQXV0aCAyLjBcbiAgICAnY29kZScsIC8vIE9BdXRoIDIuMFxuICAgICdlcnJvcl9kZXNjcmlwdGlvbicsIC8vIE9BdXRoIDIuMFxuICAgICdlcnJvcl91cmknLCAvLyBPQXV0aCAyLjBcbiAgICAnZXJyb3InLCAvLyBPQXV0aCAyLjBcbiAgICAnZXhwaXJlc19pbicsIC8vIE9BdXRoIDIuMFxuICAgICdpZF90b2tlbicsIC8vIE9JREMgQ29yZSAxLjBcbiAgICAnaXNzJywgLy8gZHJhZnQtaWV0Zi1vYXV0aC1pc3MtYXV0aC1yZXNwXG4gICAgJ3Jlc3BvbnNlJywgLy8gRkFQSSBKQVJNXG4gICAgJ3Nlc3Npb25fc3RhdGUnLCAvLyBPSURDIFNlc3Npb24gTWFuYWdlbWVudFxuICAgICdzdGF0ZScsIC8vIE9BdXRoIDIuMFxuICAgICd0b2tlbl90eXBlJywgLy8gT0F1dGggMi4wXG4gICk7XG59XG5cbmZ1bmN0aW9uIGF1dGhvcml6YXRpb25IZWFkZXJWYWx1ZSh0b2tlbiwgdG9rZW5UeXBlID0gJ0JlYXJlcicpIHtcbiAgcmV0dXJuIGAke3Rva2VuVHlwZX0gJHt0b2tlbn1gO1xufVxuXG5mdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXMoaW5wdXQpIHtcbiAgY29uc3QgcGFyc2VkID0gdXJsLnBhcnNlKGlucHV0KTtcbiAgaWYgKCFwYXJzZWQuc2VhcmNoKSByZXR1cm4ge307XG4gIHJldHVybiBxdWVyeXN0cmluZy5wYXJzZShwYXJzZWQuc2VhcmNoLnN1YnN0cmluZygxKSk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVByZXNlbmNlKHBheWxvYWQsIGp3dCwgcHJvcCkge1xuICBpZiAocGF5bG9hZFtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYG1pc3NpbmcgcmVxdWlyZWQgSldUIHByb3BlcnR5ICR7cHJvcH1gLFxuICAgICAgand0LFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF1dGhvcml6YXRpb25QYXJhbXMocGFyYW1zKSB7XG4gIGNvbnN0IGF1dGhQYXJhbXMgPSB7XG4gICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudF9pZCxcbiAgICBzY29wZTogJ29wZW5pZCcsXG4gICAgcmVzcG9uc2VfdHlwZTogcmVzb2x2ZVJlc3BvbnNlVHlwZS5jYWxsKHRoaXMpLFxuICAgIHJlZGlyZWN0X3VyaTogcmVzb2x2ZVJlZGlyZWN0VXJpLmNhbGwodGhpcyksXG4gICAgLi4ucGFyYW1zLFxuICB9O1xuXG4gIE9iamVjdC5lbnRyaWVzKGF1dGhQYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgYXV0aFBhcmFtc1trZXldO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnY2xhaW1zJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBhdXRoUGFyYW1zW2tleV0gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdyZXNvdXJjZScgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGF1dGhQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgYXV0aFBhcmFtc1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhdXRoUGFyYW1zO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlzdG9yZShqd2tzKSB7XG4gIGlmIChcbiAgICAhaXNQbGFpbk9iamVjdChqd2tzKSB8fFxuICAgICFBcnJheS5pc0FycmF5KGp3a3Mua2V5cykgfHxcbiAgICBqd2tzLmtleXMuc29tZSgoaykgPT4gIWlzUGxhaW5PYmplY3QoaykgfHwgISgna3R5JyBpbiBrKSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignandrcyBtdXN0IGJlIGEgSlNPTiBXZWIgS2V5IFNldCBmb3JtYXR0ZWQgb2JqZWN0Jyk7XG4gIH1cblxuICByZXR1cm4gS2V5U3RvcmUuZnJvbUpXS1MoandrcywgeyBvbmx5UHJpdmF0ZTogdHJ1ZSB9KTtcbn1cblxuLy8gaWYgYW4gT1AgZG9lc250IHN1cHBvcnQgY2xpZW50X3NlY3JldF9iYXNpYyBidXQgc3VwcG9ydHMgY2xpZW50X3NlY3JldF9wb3N0LCB1c2UgaXQgaW5zdGVhZFxuLy8gdGhpcyBpcyBpbiBwbGFjZSB0byB0YWtlIGNhcmUgb2YgbW9zdCBjb21tb24gcGl0ZmFsbHMgd2hlbiBmaXJzdCB1c2luZyBkaXNjb3ZlcmVkIElzc3VlcnMgd2l0aG91dFxuLy8gdGhlIHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzIGRlZmluZWQgYnkgRGlzY292ZXJ5IDEuMFxuZnVuY3Rpb24gY2hlY2tCYXNpY1N1cHBvcnQoY2xpZW50LCBwcm9wZXJ0aWVzKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkID0gY2xpZW50Lmlzc3Vlci50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkO1xuICAgIGlmICghc3VwcG9ydGVkLmluY2x1ZGVzKHByb3BlcnRpZXMudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QpKSB7XG4gICAgICBpZiAoc3VwcG9ydGVkLmluY2x1ZGVzKCdjbGllbnRfc2VjcmV0X3Bvc3QnKSkge1xuICAgICAgICBwcm9wZXJ0aWVzLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kID0gJ2NsaWVudF9zZWNyZXRfcG9zdCc7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHt9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbW1vbk1pc3Rha2VzKGNsaWVudCwgbWV0YWRhdGEsIHByb3BlcnRpZXMpIHtcbiAgaWYgKCFtZXRhZGF0YS50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCkge1xuICAgIC8vIGlmIG5vIGV4cGxpY2l0IHZhbHVlIHdhcyBwcm92aWRlZFxuICAgIGNoZWNrQmFzaWNTdXBwb3J0KGNsaWVudCwgcHJvcGVydGllcyk7XG4gIH1cblxuICAvLyA6ZnA6IGMnbW9uIHBlb3BsZS4uLiBSVEZNXG4gIGlmIChtZXRhZGF0YS5yZWRpcmVjdF91cmkpIHtcbiAgICBpZiAobWV0YWRhdGEucmVkaXJlY3RfdXJpcykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvdmlkZSBhIHJlZGlyZWN0X3VyaSBvciByZWRpcmVjdF91cmlzLCBub3QgYm90aCcpO1xuICAgIH1cbiAgICBwcm9wZXJ0aWVzLnJlZGlyZWN0X3VyaXMgPSBbbWV0YWRhdGEucmVkaXJlY3RfdXJpXTtcbiAgICBkZWxldGUgcHJvcGVydGllcy5yZWRpcmVjdF91cmk7XG4gIH1cblxuICBpZiAobWV0YWRhdGEucmVzcG9uc2VfdHlwZSkge1xuICAgIGlmIChtZXRhZGF0YS5yZXNwb25zZV90eXBlcykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvdmlkZSBhIHJlc3BvbnNlX3R5cGUgb3IgcmVzcG9uc2VfdHlwZXMsIG5vdCBib3RoJyk7XG4gICAgfVxuICAgIHByb3BlcnRpZXMucmVzcG9uc2VfdHlwZXMgPSBbbWV0YWRhdGEucmVzcG9uc2VfdHlwZV07XG4gICAgZGVsZXRlIHByb3BlcnRpZXMucmVzcG9uc2VfdHlwZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0c0ZvckVuZHBvaW50KGVuZHBvaW50LCBpc3N1ZXIsIHByb3BlcnRpZXMpIHtcbiAgaWYgKCFpc3N1ZXJbYCR7ZW5kcG9pbnR9X2VuZHBvaW50YF0pIHJldHVybjtcblxuICBjb25zdCB0b2tlbkVuZHBvaW50QXV0aE1ldGhvZCA9IHByb3BlcnRpZXMudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2Q7XG4gIGNvbnN0IHRva2VuRW5kcG9pbnRBdXRoU2lnbmluZ0FsZyA9IHByb3BlcnRpZXMudG9rZW5fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZztcblxuICBjb25zdCBlYW0gPSBgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgO1xuICBjb25zdCBlYXNhID0gYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdgO1xuXG4gIGlmIChwcm9wZXJ0aWVzW2VhbV0gPT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzW2Vhc2FdID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodG9rZW5FbmRwb2ludEF1dGhNZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvcGVydGllc1tlYW1dID0gdG9rZW5FbmRwb2ludEF1dGhNZXRob2Q7XG4gICAgfVxuICAgIGlmICh0b2tlbkVuZHBvaW50QXV0aFNpZ25pbmdBbGcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvcGVydGllc1tlYXNhXSA9IHRva2VuRW5kcG9pbnRBdXRoU2lnbmluZ0FsZztcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgQmFzZUNsaWVudCB7XG4gICNtZXRhZGF0YTtcbiAgI2lzc3VlcjtcbiAgI2FhZElzc1ZhbGlkYXRpb247XG4gICNhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXM7XG4gIGNvbnN0cnVjdG9yKGlzc3VlciwgYWFkSXNzVmFsaWRhdGlvbiwgbWV0YWRhdGEgPSB7fSwgandrcywgb3B0aW9ucykge1xuICAgIHRoaXMuI21ldGFkYXRhID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuI2lzc3VlciA9IGlzc3VlcjtcbiAgICB0aGlzLiNhYWRJc3NWYWxpZGF0aW9uID0gYWFkSXNzVmFsaWRhdGlvbjtcblxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuY2xpZW50X2lkICE9PSAnc3RyaW5nJyB8fCAhbWV0YWRhdGEuY2xpZW50X2lkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjbGllbnRfaWQgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgZ3JhbnRfdHlwZXM6IFsnYXV0aG9yaXphdGlvbl9jb2RlJ10sXG4gICAgICBpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnOiAnUlMyNTYnLFxuICAgICAgYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnOiAnUlMyNTYnLFxuICAgICAgcmVzcG9uc2VfdHlwZXM6IFsnY29kZSddLFxuICAgICAgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2Q6ICdjbGllbnRfc2VjcmV0X2Jhc2ljJyxcbiAgICAgIC4uLih0aGlzLmZhcGkxKClcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBncmFudF90eXBlczogWydhdXRob3JpemF0aW9uX2NvZGUnLCAnaW1wbGljaXQnXSxcbiAgICAgICAgICAgIGlkX3Rva2VuX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdQUzI1NicsXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdQUzI1NicsXG4gICAgICAgICAgICByZXNwb25zZV90eXBlczogWydjb2RlIGlkX3Rva2VuJ10sXG4gICAgICAgICAgICB0bHNfY2xpZW50X2NlcnRpZmljYXRlX2JvdW5kX2FjY2Vzc190b2tlbnM6IHRydWUsXG4gICAgICAgICAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQpLFxuICAgICAgLi4uKHRoaXMuZmFwaTIoKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGlkX3Rva2VuX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdQUzI1NicsXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdQUzI1NicsXG4gICAgICAgICAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQpLFxuICAgICAgLi4ubWV0YWRhdGEsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmZhcGkoKSkge1xuICAgICAgc3dpdGNoIChwcm9wZXJ0aWVzLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ3NlbGZfc2lnbmVkX3Rsc19jbGllbnRfYXV0aCc6XG4gICAgICAgIGNhc2UgJ3Rsc19jbGllbnRfYXV0aCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ByaXZhdGVfa2V5X2p3dCc6XG4gICAgICAgICAgaWYgKCFqd2tzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdqd2tzIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgb3IgdW5zdXBwb3J0ZWQgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5mYXBpMigpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHByb3BlcnRpZXMudGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zICYmXG4gICAgICAgIHByb3BlcnRpZXMuZHBvcF9ib3VuZF9hY2Nlc3NfdG9rZW5zXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnZWl0aGVyIHRsc19jbGllbnRfY2VydGlmaWNhdGVfYm91bmRfYWNjZXNzX3Rva2VucyBvciBkcG9wX2JvdW5kX2FjY2Vzc190b2tlbnMgbXVzdCBiZSBzZXQgdG8gdHJ1ZScsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgIXByb3BlcnRpZXMudGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zICYmXG4gICAgICAgICFwcm9wZXJ0aWVzLmRwb3BfYm91bmRfYWNjZXNzX3Rva2Vuc1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ2VpdGhlciB0bHNfY2xpZW50X2NlcnRpZmljYXRlX2JvdW5kX2FjY2Vzc190b2tlbnMgb3IgZHBvcF9ib3VuZF9hY2Nlc3NfdG9rZW5zIG11c3QgYmUgc2V0IHRvIHRydWUnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUNvbW1vbk1pc3Rha2VzKHRoaXMsIG1ldGFkYXRhLCBwcm9wZXJ0aWVzKTtcblxuICAgIGFzc2VydFNpZ25pbmdBbGdWYWx1ZXNTdXBwb3J0KCd0b2tlbicsIHRoaXMuaXNzdWVyLCBwcm9wZXJ0aWVzKTtcbiAgICBbJ2ludHJvc3BlY3Rpb24nLCAncmV2b2NhdGlvbiddLmZvckVhY2goKGVuZHBvaW50KSA9PiB7XG4gICAgICBnZXREZWZhdWx0c0ZvckVuZHBvaW50KGVuZHBvaW50LCB0aGlzLmlzc3VlciwgcHJvcGVydGllcyk7XG4gICAgICBhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydChlbmRwb2ludCwgdGhpcy5pc3N1ZXIsIHByb3BlcnRpZXMpO1xuICAgIH0pO1xuXG4gICAgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICB0aGlzLiNtZXRhZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIXRoaXNba2V5XSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21ldGFkYXRhLmdldChrZXkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoandrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBrZXlzdG9yZSA9IGdldEtleXN0b3JlLmNhbGwodGhpcywgandrcyk7XG4gICAgICBrZXlzdG9yZXMuc2V0KHRoaXMsIGtleXN0b3JlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzKSB7XG4gICAgICB0aGlzLiNhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSBjbG9uZShvcHRpb25zLmFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyk7XG4gICAgfVxuXG4gICAgdGhpc1tDTE9DS19UT0xFUkFOQ0VdID0gMDtcbiAgfVxuXG4gIGF1dGhvcml6YXRpb25VcmwocGFyYW1zID0ge30pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QocGFyYW1zKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1zIG11c3QgYmUgYSBwbGFpbiBvYmplY3QnKTtcbiAgICB9XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ2F1dGhvcml6YXRpb25fZW5kcG9pbnQnKTtcbiAgICBjb25zdCB0YXJnZXQgPSBuZXcgVVJMKHRoaXMuaXNzdWVyLmF1dGhvcml6YXRpb25fZW5kcG9pbnQpO1xuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF1dGhvcml6YXRpb25QYXJhbXMuY2FsbCh0aGlzLCBwYXJhbXMpKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRhcmdldC5zZWFyY2hQYXJhbXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB2YWx1ZSkge1xuICAgICAgICAgIHRhcmdldC5zZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIG1lbWJlcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5zZWFyY2hQYXJhbXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBpcyB0aGUgcmVwbGFjZSBuZWVkZWQ/XG4gICAgcmV0dXJuIHRhcmdldC5ocmVmLnJlcGxhY2UoL1xcKy9nLCAnJTIwJyk7XG4gIH1cblxuICBhdXRob3JpemF0aW9uUG9zdChwYXJhbXMgPSB7fSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMgbXVzdCBiZSBhIHBsYWluIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dHMgPSBhdXRob3JpemF0aW9uUGFyYW1zLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICBjb25zdCBmb3JtSW5wdXRzID0gT2JqZWN0LmtleXMoaW5wdXRzKVxuICAgICAgLm1hcCgobmFtZSkgPT4gYDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cIiR7bmFtZX1cIiB2YWx1ZT1cIiR7aW5wdXRzW25hbWVdfVwiLz5gKVxuICAgICAgLmpvaW4oJ1xcbicpO1xuXG4gICAgcmV0dXJuIGA8IURPQ1RZUEUgaHRtbD5cbjxoZWFkPlxuPHRpdGxlPlJlcXVlc3RpbmcgQXV0aG9yaXphdGlvbjwvdGl0bGU+XG48L2hlYWQ+XG48Ym9keSBvbmxvYWQ9XCJqYXZhc2NyaXB0OmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpXCI+XG48Zm9ybSBtZXRob2Q9XCJwb3N0XCIgYWN0aW9uPVwiJHt0aGlzLmlzc3Vlci5hdXRob3JpemF0aW9uX2VuZHBvaW50fVwiPlxuICAke2Zvcm1JbnB1dHN9XG48L2Zvcm0+XG48L2JvZHk+XG48L2h0bWw+YDtcbiAgfVxuXG4gIGVuZFNlc3Npb25VcmwocGFyYW1zID0ge30pIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnZW5kX3Nlc3Npb25fZW5kcG9pbnQnKTtcblxuICAgIGNvbnN0IHsgMDogcG9zdExvZ291dCwgbGVuZ3RoIH0gPSB0aGlzLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaXMgfHwgW107XG5cbiAgICBjb25zdCB7IHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IGxlbmd0aCA9PT0gMSA/IHBvc3RMb2dvdXQgOiB1bmRlZmluZWQgfSA9IHBhcmFtcztcblxuICAgIGxldCBpZF90b2tlbl9oaW50O1xuICAgICh7IGlkX3Rva2VuX2hpbnQsIC4uLnBhcmFtcyB9ID0gcGFyYW1zKTtcbiAgICBpZiAoaWRfdG9rZW5faGludCBpbnN0YW5jZW9mIFRva2VuU2V0KSB7XG4gICAgICBpZiAoIWlkX3Rva2VuX2hpbnQuaWRfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWRfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcbiAgICAgIH1cbiAgICAgIGlkX3Rva2VuX2hpbnQgPSBpZF90b2tlbl9oaW50LmlkX3Rva2VuO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IHVybC5wYXJzZSh0aGlzLmlzc3Vlci5lbmRfc2Vzc2lvbl9lbmRwb2ludCk7XG4gICAgY29uc3QgcXVlcnkgPSBkZWZhdWx0cyhcbiAgICAgIGdldFNlYXJjaFBhcmFtcyh0aGlzLmlzc3Vlci5lbmRfc2Vzc2lvbl9lbmRwb2ludCksXG4gICAgICBwYXJhbXMsXG4gICAgICB7XG4gICAgICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgIH0sXG4gICAgICB7IGlkX3Rva2VuX2hpbnQgfSxcbiAgICApO1xuXG4gICAgT2JqZWN0LmVudHJpZXMocXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIHF1ZXJ5W2tleV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0YXJnZXQuc2VhcmNoID0gbnVsbDtcbiAgICB0YXJnZXQucXVlcnkgPSBxdWVyeTtcblxuICAgIHJldHVybiB1cmwuZm9ybWF0KHRhcmdldCk7XG4gIH1cblxuICBjYWxsYmFja1BhcmFtcyhpbnB1dCkge1xuICAgIGNvbnN0IGlzSW5jb21pbmdNZXNzYWdlID1cbiAgICAgIGlucHV0IGluc3RhbmNlb2Ygc3RkaHR0cC5JbmNvbWluZ01lc3NhZ2UgfHwgKGlucHV0ICYmIGlucHV0Lm1ldGhvZCAmJiBpbnB1dC51cmwpO1xuICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJztcblxuICAgIGlmICghaXNTdHJpbmcgJiYgIWlzSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnI2NhbGxiYWNrUGFyYW1zIG9ubHkgYWNjZXB0cyBzdHJpbmcgdXJscywgaHR0cC5JbmNvbWluZ01lc3NhZ2Ugb3IgYSBsb29rYWxpa2UnLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICBzd2l0Y2ggKGlucHV0Lm1ldGhvZCkge1xuICAgICAgICBjYXNlICdHRVQnOlxuICAgICAgICAgIHJldHVybiBwaWNrQ2IoZ2V0U2VhcmNoUGFyYW1zKGlucHV0LnVybCkpO1xuICAgICAgICBjYXNlICdQT1NUJzpcbiAgICAgICAgICBpZiAoaW5wdXQuYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAnaW5jb21pbmcgbWVzc2FnZSBib2R5IG1pc3NpbmcsIGluY2x1ZGUgYSBib2R5IHBhcnNlciBwcmlvciB0byB0aGlzIG1ldGhvZCBjYWxsJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGlucHV0LmJvZHkpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0LmJvZHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tDYihxdWVyeXN0cmluZy5wYXJzZShpbnB1dC5ib2R5LnRvU3RyaW5nKCd1dGYtOCcpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5ib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwaWNrQ2IocXVlcnlzdHJpbmcucGFyc2UoaW5wdXQuYm9keSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHBpY2tDYihpbnB1dC5ib2R5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgSW5jb21pbmdNZXNzYWdlIGJvZHkgb2JqZWN0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgSW5jb21pbmdNZXNzYWdlIG1ldGhvZCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGlja0NiKGdldFNlYXJjaFBhcmFtcyhpbnB1dCkpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNhbGxiYWNrKFxuICAgIHJlZGlyZWN0VXJpLFxuICAgIHBhcmFtZXRlcnMsXG4gICAgY2hlY2tzID0ge30sXG4gICAgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9LFxuICApIHtcbiAgICBsZXQgcGFyYW1zID0gcGlja0NiKHBhcmFtZXRlcnMpO1xuXG4gICAgaWYgKGNoZWNrcy5qYXJtICYmICEoJ3Jlc3BvbnNlJyBpbiBwYXJhbWV0ZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgYSBKQVJNIHJlc3BvbnNlJyxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdyZXNwb25zZScgaW4gcGFyYW1ldGVycykge1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgdGhpcy5kZWNyeXB0SkFSTShwYXJhbXMucmVzcG9uc2UpO1xuICAgICAgcGFyYW1zID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpBUk0oZGVjcnlwdGVkKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kZWZhdWx0X21heF9hZ2UgJiYgIWNoZWNrcy5tYXhfYWdlKSB7XG4gICAgICBjaGVja3MubWF4X2FnZSA9IHRoaXMuZGVmYXVsdF9tYXhfYWdlO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuc3RhdGUgJiYgIWNoZWNrcy5zdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2hlY2tzLnN0YXRlIGFyZ3VtZW50IGlzIG1pc3NpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5zdGF0ZSAmJiBjaGVja3Muc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ3N0YXRlIG1pc3NpbmcgZnJvbSB0aGUgcmVzcG9uc2UnLFxuICAgICAgICBjaGVja3MsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjaGVja3Muc3RhdGUgIT09IHBhcmFtcy5zdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBwcmludGY6IFsnc3RhdGUgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgY2hlY2tzLnN0YXRlLCBwYXJhbXMuc3RhdGVdLFxuICAgICAgICBjaGVja3MsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICgnaXNzJyBpbiBwYXJhbXMpIHtcbiAgICAgIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24odGhpcy5pc3N1ZXIsICdpc3N1ZXInKTtcbiAgICAgIGlmIChwYXJhbXMuaXNzICE9PSB0aGlzLmlzc3Vlci5pc3N1ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIHByaW50ZjogWydpc3MgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgdGhpcy5pc3N1ZXIuaXNzdWVyLCBwYXJhbXMuaXNzXSxcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLmlzc3Vlci5hdXRob3JpemF0aW9uX3Jlc3BvbnNlX2lzc19wYXJhbWV0ZXJfc3VwcG9ydGVkICYmXG4gICAgICAhKCdpZF90b2tlbicgaW4gcGFyYW1zKSAmJlxuICAgICAgISgncmVzcG9uc2UnIGluIHBhcmFtZXRlcnMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdpc3MgbWlzc2luZyBmcm9tIHRoZSByZXNwb25zZScsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBPUEVycm9yKHBhcmFtcyk7XG4gICAgfVxuXG4gICAgY29uc3QgUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVMgPSB7XG4gICAgICBjb2RlOiBbJ2NvZGUnXSxcbiAgICAgIGlkX3Rva2VuOiBbJ2lkX3Rva2VuJ10sXG4gICAgICB0b2tlbjogWydhY2Nlc3NfdG9rZW4nLCAndG9rZW5fdHlwZSddLFxuICAgIH07XG5cbiAgICBpZiAoY2hlY2tzLnJlc3BvbnNlX3R5cGUpIHtcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBjaGVja3MucmVzcG9uc2VfdHlwZS5zcGxpdCgnICcpKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnbm9uZScpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmNvZGUgfHwgcGFyYW1zLmlkX3Rva2VuIHx8IHBhcmFtcy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ3VuZXhwZWN0ZWQgcGFyYW1zIGVuY291bnRlcmVkIGZvciBcIm5vbmVcIiByZXNwb25zZScsXG4gICAgICAgICAgICAgIGNoZWNrcyxcbiAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVNbdHlwZV0pIHtcbiAgICAgICAgICAgIGlmICghcGFyYW1zW3BhcmFtXSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7cGFyYW19IG1pc3NpbmcgZnJvbSByZXNwb25zZWAsXG4gICAgICAgICAgICAgICAgY2hlY2tzLFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5pZF90b2tlbikge1xuICAgICAgY29uc3QgdG9rZW5zZXQgPSBuZXcgVG9rZW5TZXQocGFyYW1zKTtcbiAgICAgIGF3YWl0IHRoaXMuZGVjcnlwdElkVG9rZW4odG9rZW5zZXQpO1xuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUlkVG9rZW4oXG4gICAgICAgIHRva2Vuc2V0LFxuICAgICAgICBjaGVja3Mubm9uY2UsXG4gICAgICAgICdhdXRob3JpemF0aW9uJyxcbiAgICAgICAgY2hlY2tzLm1heF9hZ2UsXG4gICAgICAgIGNoZWNrcy5zdGF0ZSxcbiAgICAgICk7XG5cbiAgICAgIGlmICghcGFyYW1zLmNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRva2Vuc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuY29kZSkge1xuICAgICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLmdyYW50KFxuICAgICAgICB7XG4gICAgICAgICAgLi4uZXhjaGFuZ2VCb2R5LFxuICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgICAgICAgIHJlZGlyZWN0X3VyaTogcmVkaXJlY3RVcmksXG4gICAgICAgICAgY29kZV92ZXJpZmllcjogY2hlY2tzLmNvZGVfdmVyaWZpZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgRFBvUCB9LFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgdGhpcy5kZWNyeXB0SWRUb2tlbih0b2tlbnNldCk7XG4gICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlSWRUb2tlbih0b2tlbnNldCwgY2hlY2tzLm5vbmNlLCAndG9rZW4nLCBjaGVja3MubWF4X2FnZSk7XG5cbiAgICAgIGlmIChwYXJhbXMuc2Vzc2lvbl9zdGF0ZSkge1xuICAgICAgICB0b2tlbnNldC5zZXNzaW9uX3N0YXRlID0gcGFyYW1zLnNlc3Npb25fc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbnNldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRva2VuU2V0KHBhcmFtcyk7XG4gIH1cblxuICBhc3luYyBvYXV0aENhbGxiYWNrKFxuICAgIHJlZGlyZWN0VXJpLFxuICAgIHBhcmFtZXRlcnMsXG4gICAgY2hlY2tzID0ge30sXG4gICAgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9LFxuICApIHtcbiAgICBsZXQgcGFyYW1zID0gcGlja0NiKHBhcmFtZXRlcnMpO1xuXG4gICAgaWYgKGNoZWNrcy5qYXJtICYmICEoJ3Jlc3BvbnNlJyBpbiBwYXJhbWV0ZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgYSBKQVJNIHJlc3BvbnNlJyxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdyZXNwb25zZScgaW4gcGFyYW1ldGVycykge1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgdGhpcy5kZWNyeXB0SkFSTShwYXJhbXMucmVzcG9uc2UpO1xuICAgICAgcGFyYW1zID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpBUk0oZGVjcnlwdGVkKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnN0YXRlICYmICFjaGVja3Muc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NoZWNrcy5zdGF0ZSBhcmd1bWVudCBpcyBtaXNzaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuc3RhdGUgJiYgY2hlY2tzLnN0YXRlKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdzdGF0ZSBtaXNzaW5nIGZyb20gdGhlIHJlc3BvbnNlJyxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLnN0YXRlICE9PSBwYXJhbXMuc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgcHJpbnRmOiBbJ3N0YXRlIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIGNoZWNrcy5zdGF0ZSwgcGFyYW1zLnN0YXRlXSxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoJ2lzcycgaW4gcGFyYW1zKSB7XG4gICAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnaXNzdWVyJyk7XG4gICAgICBpZiAocGFyYW1zLmlzcyAhPT0gdGhpcy5pc3N1ZXIuaXNzdWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBwcmludGY6IFsnaXNzIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIHRoaXMuaXNzdWVyLmlzc3VlciwgcGFyYW1zLmlzc10sXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5pc3N1ZXIuYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCAmJlxuICAgICAgISgnaWRfdG9rZW4nIGluIHBhcmFtcykgJiZcbiAgICAgICEoJ3Jlc3BvbnNlJyBpbiBwYXJhbWV0ZXJzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnaXNzIG1pc3NpbmcgZnJvbSB0aGUgcmVzcG9uc2UnLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgT1BFcnJvcihwYXJhbXMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyYW1zLmlkX3Rva2VuID09PSAnc3RyaW5nJyAmJiBwYXJhbXMuaWRfdG9rZW4ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgJ2lkX3Rva2VuIGRldGVjdGVkIGluIHRoZSByZXNwb25zZSwgeW91IG11c3QgdXNlIGNsaWVudC5jYWxsYmFjaygpIGluc3RlYWQgb2YgY2xpZW50Lm9hdXRoQ2FsbGJhY2soKScsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUgcGFyYW1zLmlkX3Rva2VuO1xuXG4gICAgY29uc3QgUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVMgPSB7XG4gICAgICBjb2RlOiBbJ2NvZGUnXSxcbiAgICAgIHRva2VuOiBbJ2FjY2Vzc190b2tlbicsICd0b2tlbl90eXBlJ10sXG4gICAgfTtcblxuICAgIGlmIChjaGVja3MucmVzcG9uc2VfdHlwZSkge1xuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGNoZWNrcy5yZXNwb25zZV90eXBlLnNwbGl0KCcgJykpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgIGlmIChwYXJhbXMuY29kZSB8fCBwYXJhbXMuaWRfdG9rZW4gfHwgcGFyYW1zLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgICBtZXNzYWdlOiAndW5leHBlY3RlZCBwYXJhbXMgZW5jb3VudGVyZWQgZm9yIFwibm9uZVwiIHJlc3BvbnNlJyxcbiAgICAgICAgICAgICAgY2hlY2tzLFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVNbdHlwZV0pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIFJFU1BPTlNFX1RZUEVfUkVRVUlSRURfUEFSQU1TW3R5cGVdKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtc1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3BhcmFtfSBtaXNzaW5nIGZyb20gcmVzcG9uc2VgLFxuICAgICAgICAgICAgICAgIGNoZWNrcyxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuY29kZSkge1xuICAgICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLmdyYW50KFxuICAgICAgICB7XG4gICAgICAgICAgLi4uZXhjaGFuZ2VCb2R5LFxuICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgICAgICAgIHJlZGlyZWN0X3VyaTogcmVkaXJlY3RVcmksXG4gICAgICAgICAgY29kZV92ZXJpZmllcjogY2hlY2tzLmNvZGVfdmVyaWZpZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgRFBvUCB9LFxuICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbnNldC5pZF90b2tlbiA9PT0gJ3N0cmluZycgJiYgdG9rZW5zZXQuaWRfdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJ2lkX3Rva2VuIGRldGVjdGVkIGluIHRoZSByZXNwb25zZSwgeW91IG11c3QgdXNlIGNsaWVudC5jYWxsYmFjaygpIGluc3RlYWQgb2YgY2xpZW50Lm9hdXRoQ2FsbGJhY2soKScsXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0b2tlbnNldC5pZF90b2tlbjtcblxuICAgICAgcmV0dXJuIHRva2Vuc2V0O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVG9rZW5TZXQocGFyYW1zKTtcbiAgfVxuXG4gIGFzeW5jIGRlY3J5cHRJZFRva2VuKHRva2VuKSB7XG4gICAgaWYgKCF0aGlzLmlkX3Rva2VuX2VuY3J5cHRlZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICBsZXQgaWRUb2tlbiA9IHRva2VuO1xuXG4gICAgaWYgKGlkVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldCkge1xuICAgICAgaWYgKCFpZFRva2VuLmlkX3Rva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lkX3Rva2VuIG5vdCBwcmVzZW50IGluIFRva2VuU2V0Jyk7XG4gICAgICB9XG4gICAgICBpZFRva2VuID0gaWRUb2tlbi5pZF90b2tlbjtcbiAgICB9XG5cbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMuaWRfdG9rZW5fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZztcbiAgICBjb25zdCBleHBlY3RlZEVuYyA9IHRoaXMuaWRfdG9rZW5fZW5jcnlwdGVkX3Jlc3BvbnNlX2VuYztcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZGVjcnlwdEpXRShpZFRva2VuLCBleHBlY3RlZEFsZywgZXhwZWN0ZWRFbmMpO1xuXG4gICAgaWYgKHRva2VuIGluc3RhbmNlb2YgVG9rZW5TZXQpIHtcbiAgICAgIHRva2VuLmlkX3Rva2VuID0gcmVzdWx0O1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUpXVFVzZXJpbmZvKGJvZHkpIHtcbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZztcblxuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlSldUKGJvZHksIGV4cGVjdGVkQWxnLCBbXSk7XG4gIH1cblxuICBhc3luYyBkZWNyeXB0SkFSTShyZXNwb25zZSkge1xuICAgIGlmICghdGhpcy5hdXRob3JpemF0aW9uX2VuY3J5cHRlZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMuYXV0aG9yaXphdGlvbl9lbmNyeXB0ZWRfcmVzcG9uc2VfYWxnO1xuICAgIGNvbnN0IGV4cGVjdGVkRW5jID0gdGhpcy5hdXRob3JpemF0aW9uX2VuY3J5cHRlZF9yZXNwb25zZV9lbmM7XG5cbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0SldFKHJlc3BvbnNlLCBleHBlY3RlZEFsZywgZXhwZWN0ZWRFbmMpO1xuICB9XG5cbiAgYXN5bmMgZGVjcnlwdEpXVFVzZXJpbmZvKGJvZHkpIHtcbiAgICBpZiAoIXRoaXMudXNlcmluZm9fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZykge1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhwZWN0ZWRBbGcgPSB0aGlzLnVzZXJpbmZvX2VuY3J5cHRlZF9yZXNwb25zZV9hbGc7XG4gICAgY29uc3QgZXhwZWN0ZWRFbmMgPSB0aGlzLnVzZXJpbmZvX2VuY3J5cHRlZF9yZXNwb25zZV9lbmM7XG5cbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0SldFKGJvZHksIGV4cGVjdGVkQWxnLCBleHBlY3RlZEVuYyk7XG4gIH1cblxuICBhc3luYyBkZWNyeXB0SldFKGp3ZSwgZXhwZWN0ZWRBbGcsIGV4cGVjdGVkRW5jID0gJ0ExMjhDQkMtSFMyNTYnKSB7XG4gICAgY29uc3QgaGVhZGVyID0gSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKGp3ZS5zcGxpdCgnLicpWzBdKSk7XG5cbiAgICBpZiAoaGVhZGVyLmFsZyAhPT0gZXhwZWN0ZWRBbGcpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgcHJpbnRmOiBbJ3VuZXhwZWN0ZWQgSldFIGFsZyByZWNlaXZlZCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCBleHBlY3RlZEFsZywgaGVhZGVyLmFsZ10sXG4gICAgICAgIGp3dDogandlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlci5lbmMgIT09IGV4cGVjdGVkRW5jKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIHByaW50ZjogWyd1bmV4cGVjdGVkIEpXRSBlbmMgcmVjZWl2ZWQsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgZXhwZWN0ZWRFbmMsIGhlYWRlci5lbmNdLFxuICAgICAgICBqd3Q6IGp3ZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGdldFBsYWludGV4dCA9IChyZXN1bHQpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShyZXN1bHQucGxhaW50ZXh0KTtcbiAgICBsZXQgcGxhaW50ZXh0O1xuICAgIGlmIChleHBlY3RlZEFsZy5tYXRjaCgvXig/OlJTQXxFQ0RIKS8pKSB7XG4gICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGtleXN0b3Jlcy5nZXQodGhpcyk7XG5cbiAgICAgIGNvbnN0IHByb3RlY3RlZEhlYWRlciA9IGpvc2UuZGVjb2RlUHJvdGVjdGVkSGVhZGVyKGp3ZSk7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXN0b3JlLmFsbCh7XG4gICAgICAgIC4uLnByb3RlY3RlZEhlYWRlcixcbiAgICAgICAgdXNlOiAnZW5jJyxcbiAgICAgIH0pKSB7XG4gICAgICAgIHBsYWludGV4dCA9IGF3YWl0IGpvc2VcbiAgICAgICAgICAuY29tcGFjdERlY3J5cHQoandlLCBhd2FpdCBrZXkua2V5T2JqZWN0KHByb3RlY3RlZEhlYWRlci5hbGcpKVxuICAgICAgICAgIC50aGVuKGdldFBsYWludGV4dCwgKCkgPT4ge30pO1xuICAgICAgICBpZiAocGxhaW50ZXh0KSBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGxhaW50ZXh0ID0gYXdhaXQgam9zZVxuICAgICAgICAuY29tcGFjdERlY3J5cHQoandlLCB0aGlzLnNlY3JldEZvckFsZyhleHBlY3RlZEFsZyA9PT0gJ2RpcicgPyBleHBlY3RlZEVuYyA6IGV4cGVjdGVkQWxnKSlcbiAgICAgICAgLnRoZW4oZ2V0UGxhaW50ZXh0LCAoKSA9PiB7fSk7XG4gICAgfVxuXG4gICAgaWYgKCFwbGFpbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ2ZhaWxlZCB0byBkZWNyeXB0IEpXRScsXG4gICAgICAgIGp3dDogandlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwbGFpbnRleHQ7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUlkVG9rZW4odG9rZW5TZXQsIG5vbmNlLCByZXR1cm5lZEJ5LCBtYXhBZ2UsIHN0YXRlKSB7XG4gICAgbGV0IGlkVG9rZW4gPSB0b2tlblNldDtcblxuICAgIGNvbnN0IGV4cGVjdGVkQWxnID0gdGhpcy5pZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnO1xuXG4gICAgY29uc3QgaXNUb2tlblNldCA9IGlkVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldDtcblxuICAgIGlmIChpc1Rva2VuU2V0KSB7XG4gICAgICBpZiAoIWlkVG9rZW4uaWRfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWRfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcbiAgICAgIH1cbiAgICAgIGlkVG9rZW4gPSBpZFRva2VuLmlkX3Rva2VuO1xuICAgIH1cblxuICAgIGlkVG9rZW4gPSBTdHJpbmcoaWRUb2tlbik7XG5cbiAgICBjb25zdCB0aW1lc3RhbXAgPSBub3coKTtcbiAgICBjb25zdCB7IHByb3RlY3RlZDogaGVhZGVyLCBwYXlsb2FkLCBrZXkgfSA9IGF3YWl0IHRoaXMudmFsaWRhdGVKV1QoaWRUb2tlbiwgZXhwZWN0ZWRBbGcpO1xuXG4gICAgaWYgKHR5cGVvZiBtYXhBZ2UgPT09ICdudW1iZXInIHx8IChtYXhBZ2UgIT09IHNraXBNYXhBZ2VDaGVjayAmJiB0aGlzLnJlcXVpcmVfYXV0aF90aW1lKSkge1xuICAgICAgaWYgKCFwYXlsb2FkLmF1dGhfdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcmVxdWlyZWQgSldUIHByb3BlcnR5IGF1dGhfdGltZScsXG4gICAgICAgICAgand0OiBpZFRva2VuLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5hdXRoX3RpbWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnSldUIGF1dGhfdGltZSBjbGFpbSBtdXN0IGJlIGEgSlNPTiBudW1lcmljIHZhbHVlJyxcbiAgICAgICAgICBqd3Q6IGlkVG9rZW4sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBtYXhBZ2UgPT09ICdudW1iZXInICYmXG4gICAgICBwYXlsb2FkLmF1dGhfdGltZSArIG1heEFnZSA8IHRpbWVzdGFtcCAtIHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBwcmludGY6IFtcbiAgICAgICAgICAndG9vIG11Y2ggdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBFbmQtVXNlciBhdXRoZW50aWNhdGlvbiwgbWF4X2FnZSAlaSwgYXV0aF90aW1lOiAlaSwgbm93ICVpJyxcbiAgICAgICAgICBtYXhBZ2UsXG4gICAgICAgICAgcGF5bG9hZC5hdXRoX3RpbWUsXG4gICAgICAgICAgdGltZXN0YW1wIC0gdGhpc1tDTE9DS19UT0xFUkFOQ0VdLFxuICAgICAgICBdLFxuICAgICAgICBub3c6IHRpbWVzdGFtcCxcbiAgICAgICAgdG9sZXJhbmNlOiB0aGlzW0NMT0NLX1RPTEVSQU5DRV0sXG4gICAgICAgIGF1dGhfdGltZTogcGF5bG9hZC5hdXRoX3RpbWUsXG4gICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG5vbmNlICE9PSBza2lwTm9uY2VDaGVjayAmJlxuICAgICAgKHBheWxvYWQubm9uY2UgfHwgbm9uY2UgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgIHBheWxvYWQubm9uY2UgIT09IG5vbmNlXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIHByaW50ZjogWydub25jZSBtaXNtYXRjaCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCBub25jZSwgcGF5bG9hZC5ub25jZV0sXG4gICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXR1cm5lZEJ5ID09PSAnYXV0aG9yaXphdGlvbicpIHtcbiAgICAgIGlmICghcGF5bG9hZC5hdF9oYXNoICYmIHRva2VuU2V0LmFjY2Vzc190b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgYXRfaGFzaCcsXG4gICAgICAgICAgand0OiBpZFRva2VuLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXlsb2FkLmNfaGFzaCAmJiB0b2tlblNldC5jb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBjX2hhc2gnLFxuICAgICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZhcGkxKCkpIHtcbiAgICAgICAgaWYgKCFwYXlsb2FkLnNfaGFzaCAmJiAodG9rZW5TZXQuc3RhdGUgfHwgc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgc19oYXNoJyxcbiAgICAgICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF5bG9hZC5zX2hhc2gpIHtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCB2ZXJpZnkgc19oYXNoLCBcImNoZWNrcy5zdGF0ZVwiIHByb3BlcnR5IG5vdCBwcm92aWRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0b2tlbkhhc2gudmFsaWRhdGUoXG4gICAgICAgICAgICB7IGNsYWltOiAnc19oYXNoJywgc291cmNlOiAnc3RhdGUnIH0sXG4gICAgICAgICAgICBwYXlsb2FkLnNfaGFzaCxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgaGVhZGVyLmFsZyxcbiAgICAgICAgICAgIGtleS5qd2sgJiYga2V5Lmp3ay5jcnYsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoeyBtZXNzYWdlOiBlcnIubWVzc2FnZSwgand0OiBpZFRva2VuIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmFwaSgpICYmIHBheWxvYWQuaWF0IDwgdGltZXN0YW1wIC0gMzYwMCkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBwcmludGY6IFsnSldUIGlzc3VlZCB0b28gZmFyIGluIHRoZSBwYXN0LCBub3cgJWksIGlhdCAlaScsIHRpbWVzdGFtcCwgcGF5bG9hZC5pYXRdLFxuICAgICAgICBub3c6IHRpbWVzdGFtcCxcbiAgICAgICAgdG9sZXJhbmNlOiB0aGlzW0NMT0NLX1RPTEVSQU5DRV0sXG4gICAgICAgIGlhdDogcGF5bG9hZC5pYXQsXG4gICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0b2tlblNldC5hY2Nlc3NfdG9rZW4gJiYgcGF5bG9hZC5hdF9oYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRva2VuSGFzaC52YWxpZGF0ZShcbiAgICAgICAgICB7IGNsYWltOiAnYXRfaGFzaCcsIHNvdXJjZTogJ2FjY2Vzc190b2tlbicgfSxcbiAgICAgICAgICBwYXlsb2FkLmF0X2hhc2gsXG4gICAgICAgICAgdG9rZW5TZXQuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgIGhlYWRlci5hbGcsXG4gICAgICAgICAga2V5Lmp3ayAmJiBrZXkuandrLmNydixcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7IG1lc3NhZ2U6IGVyci5tZXNzYWdlLCBqd3Q6IGlkVG9rZW4gfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuU2V0LmNvZGUgJiYgcGF5bG9hZC5jX2hhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW5IYXNoLnZhbGlkYXRlKFxuICAgICAgICAgIHsgY2xhaW06ICdjX2hhc2gnLCBzb3VyY2U6ICdjb2RlJyB9LFxuICAgICAgICAgIHBheWxvYWQuY19oYXNoLFxuICAgICAgICAgIHRva2VuU2V0LmNvZGUsXG4gICAgICAgICAgaGVhZGVyLmFsZyxcbiAgICAgICAgICBrZXkuandrICYmIGtleS5qd2suY3J2LFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHsgbWVzc2FnZTogZXJyLm1lc3NhZ2UsIGp3dDogaWRUb2tlbiB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW5TZXQ7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUpXVChqd3QsIGV4cGVjdGVkQWxnLCByZXF1aXJlZCA9IFsnaXNzJywgJ3N1YicsICdhdWQnLCAnZXhwJywgJ2lhdCddKSB7XG4gICAgY29uc3QgaXNTZWxmSXNzdWVkID0gdGhpcy5pc3N1ZXIuaXNzdWVyID09PSAnaHR0cHM6Ly9zZWxmLWlzc3VlZC5tZSc7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbm93KCk7XG4gICAgbGV0IGhlYWRlcjtcbiAgICBsZXQgcGF5bG9hZDtcbiAgICB0cnkge1xuICAgICAgKHsgaGVhZGVyLCBwYXlsb2FkIH0gPSBkZWNvZGVKV1Qoand0LCB7IGNvbXBsZXRlOiB0cnVlIH0pKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgcHJpbnRmOiBbJ2ZhaWxlZCB0byBkZWNvZGUgSldUICglczogJXMpJywgZXJyLm5hbWUsIGVyci5tZXNzYWdlXSxcbiAgICAgICAgand0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlci5hbGcgIT09IGV4cGVjdGVkQWxnKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIHByaW50ZjogWyd1bmV4cGVjdGVkIEpXVCBhbGcgcmVjZWl2ZWQsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgZXhwZWN0ZWRBbGcsIGhlYWRlci5hbGddLFxuICAgICAgICBqd3QsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTZWxmSXNzdWVkKSB7XG4gICAgICByZXF1aXJlZCA9IFsuLi5yZXF1aXJlZCwgJ3N1Yl9qd2snXTtcbiAgICB9XG5cbiAgICByZXF1aXJlZC5mb3JFYWNoKHZlcmlmeVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCBwYXlsb2FkLCBqd3QpKTtcblxuICAgIGlmIChwYXlsb2FkLmlzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgZXhwZWN0ZWRJc3MgPSB0aGlzLmlzc3Vlci5pc3N1ZXI7XG5cbiAgICAgIGlmICh0aGlzLiNhYWRJc3NWYWxpZGF0aW9uKSB7XG4gICAgICAgIGV4cGVjdGVkSXNzID0gdGhpcy5pc3N1ZXIuaXNzdWVyLnJlcGxhY2UoJ3t0ZW5hbnRpZH0nLCBwYXlsb2FkLnRpZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXlsb2FkLmlzcyAhPT0gZXhwZWN0ZWRJc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIHByaW50ZjogWyd1bmV4cGVjdGVkIGlzcyB2YWx1ZSwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCBleHBlY3RlZElzcywgcGF5bG9hZC5pc3NdLFxuICAgICAgICAgIGp3dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQuaWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5pYXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnSldUIGlhdCBjbGFpbSBtdXN0IGJlIGEgSlNPTiBudW1lcmljIHZhbHVlJyxcbiAgICAgICAgICBqd3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXlsb2FkLm5iZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQubmJmICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogJ0pXVCBuYmYgY2xhaW0gbXVzdCBiZSBhIEpTT04gbnVtZXJpYyB2YWx1ZScsXG4gICAgICAgICAgand0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXlsb2FkLm5iZiA+IHRpbWVzdGFtcCArIHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXSkge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgcHJpbnRmOiBbXG4gICAgICAgICAgICAnSldUIG5vdCBhY3RpdmUgeWV0LCBub3cgJWksIG5iZiAlaScsXG4gICAgICAgICAgICB0aW1lc3RhbXAgKyB0aGlzW0NMT0NLX1RPTEVSQU5DRV0sXG4gICAgICAgICAgICBwYXlsb2FkLm5iZixcbiAgICAgICAgICBdLFxuICAgICAgICAgIG5vdzogdGltZXN0YW1wLFxuICAgICAgICAgIHRvbGVyYW5jZTogdGhpc1tDTE9DS19UT0xFUkFOQ0VdLFxuICAgICAgICAgIG5iZjogcGF5bG9hZC5uYmYsXG4gICAgICAgICAgand0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF5bG9hZC5leHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLmV4cCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdKV1QgZXhwIGNsYWltIG11c3QgYmUgYSBKU09OIG51bWVyaWMgdmFsdWUnLFxuICAgICAgICAgIGp3dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXN0YW1wIC0gdGhpc1tDTE9DS19UT0xFUkFOQ0VdID49IHBheWxvYWQuZXhwKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBwcmludGY6IFsnSldUIGV4cGlyZWQsIG5vdyAlaSwgZXhwICVpJywgdGltZXN0YW1wIC0gdGhpc1tDTE9DS19UT0xFUkFOQ0VdLCBwYXlsb2FkLmV4cF0sXG4gICAgICAgICAgbm93OiB0aW1lc3RhbXAsXG4gICAgICAgICAgdG9sZXJhbmNlOiB0aGlzW0NMT0NLX1RPTEVSQU5DRV0sXG4gICAgICAgICAgZXhwOiBwYXlsb2FkLmV4cCxcbiAgICAgICAgICBqd3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXlsb2FkLmF1ZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkLmF1ZCkpIHtcbiAgICAgICAgaWYgKHBheWxvYWQuYXVkLmxlbmd0aCA+IDEgJiYgIXBheWxvYWQuYXpwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcmVxdWlyZWQgSldUIHByb3BlcnR5IGF6cCcsXG4gICAgICAgICAgICBqd3QsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBheWxvYWQuYXVkLmluY2x1ZGVzKHRoaXMuY2xpZW50X2lkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICAgIHByaW50ZjogW1xuICAgICAgICAgICAgICAnYXVkIGlzIG1pc3NpbmcgdGhlIGNsaWVudF9pZCwgZXhwZWN0ZWQgJXMgdG8gYmUgaW5jbHVkZWQgaW4gJWonLFxuICAgICAgICAgICAgICB0aGlzLmNsaWVudF9pZCxcbiAgICAgICAgICAgICAgcGF5bG9hZC5hdWQsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgand0LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBheWxvYWQuYXVkICE9PSB0aGlzLmNsaWVudF9pZCkge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgcHJpbnRmOiBbJ2F1ZCBtaXNtYXRjaCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCB0aGlzLmNsaWVudF9pZCwgcGF5bG9hZC5hdWRdLFxuICAgICAgICAgIGp3dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQuYXpwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSB0aGlzLiNhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXM7XG5cbiAgICAgIGlmICh0eXBlb2YgYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzID09PSAnc3RyaW5nJykge1xuICAgICAgICBhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSBbdGhpcy5jbGllbnRfaWQsIGFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllc107XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzKSkge1xuICAgICAgICBhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSBbdGhpcy5jbGllbnRfaWQsIC4uLmFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSBbdGhpcy5jbGllbnRfaWRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcy5pbmNsdWRlcyhwYXlsb2FkLmF6cCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIHByaW50ZjogWydhenAgbWlzbWF0Y2gsIGdvdDogJXMnLCBwYXlsb2FkLmF6cF0sXG4gICAgICAgICAgand0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQga2V5cztcblxuICAgIGlmIChpc1NlbGZJc3N1ZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChpc1BsYWluT2JqZWN0KHBheWxvYWQuc3ViX2p3aykpO1xuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBqb3NlLmltcG9ydEpXSyhwYXlsb2FkLnN1Yl9qd2ssIGhlYWRlci5hbGcpO1xuICAgICAgICBhc3NlcnQuZXF1YWwoa2V5LnR5cGUsICdwdWJsaWMnKTtcbiAgICAgICAga2V5cyA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXlPYmplY3QoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdmYWlsZWQgdG8gdXNlIHN1Yl9qd2sgY2xhaW0gYXMgYW4gYXN5bW1ldHJpYyBKU09OIFdlYiBLZXknLFxuICAgICAgICAgIGp3dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoKGF3YWl0IGpvc2UuY2FsY3VsYXRlSndrVGh1bWJwcmludChwYXlsb2FkLnN1Yl9qd2spKSAhPT0gcGF5bG9hZC5zdWIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdmYWlsZWQgdG8gbWF0Y2ggdGhlIHN1YmplY3Qgd2l0aCBzdWJfandrJyxcbiAgICAgICAgICBqd3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVyLmFsZy5zdGFydHNXaXRoKCdIUycpKSB7XG4gICAgICBrZXlzID0gW3RoaXMuc2VjcmV0Rm9yQWxnKGhlYWRlci5hbGcpXTtcbiAgICB9IGVsc2UgaWYgKGhlYWRlci5hbGcgIT09ICdub25lJykge1xuICAgICAga2V5cyA9IGF3YWl0IHF1ZXJ5S2V5U3RvcmUuY2FsbCh0aGlzLmlzc3VlciwgeyAuLi5oZWFkZXIsIHVzZTogJ3NpZycgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFrZXlzICYmIGhlYWRlci5hbGcgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuIHsgcHJvdGVjdGVkOiBoZWFkZXIsIHBheWxvYWQgfTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGpvc2VcbiAgICAgICAgLmNvbXBhY3RWZXJpZnkoand0LCBrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8ga2V5IDogYXdhaXQga2V5LmtleU9iamVjdChoZWFkZXIuYWxnKSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgIGlmICh2ZXJpZmllZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgcHJvdGVjdGVkOiB2ZXJpZmllZC5wcm90ZWN0ZWRIZWFkZXIsXG4gICAgICAgICAga2V5LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6ICdmYWlsZWQgdG8gdmFsaWRhdGUgSldUIHNpZ25hdHVyZScsXG4gICAgICBqd3QsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZWZyZXNoKHJlZnJlc2hUb2tlbiwgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9KSB7XG4gICAgbGV0IHRva2VuID0gcmVmcmVzaFRva2VuO1xuXG4gICAgaWYgKHRva2VuIGluc3RhbmNlb2YgVG9rZW5TZXQpIHtcbiAgICAgIGlmICghdG9rZW4ucmVmcmVzaF90b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWZyZXNoX3Rva2VuIG5vdCBwcmVzZW50IGluIFRva2VuU2V0Jyk7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRva2VuLnJlZnJlc2hfdG9rZW47XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLmdyYW50KFxuICAgICAge1xuICAgICAgICAuLi5leGNoYW5nZUJvZHksXG4gICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgcmVmcmVzaF90b2tlbjogU3RyaW5nKHRva2VuKSxcbiAgICAgIH0sXG4gICAgICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSxcbiAgICApO1xuXG4gICAgaWYgKHRva2Vuc2V0LmlkX3Rva2VuKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlY3J5cHRJZFRva2VuKHRva2Vuc2V0KTtcbiAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVJZFRva2VuKHRva2Vuc2V0LCBza2lwTm9uY2VDaGVjaywgJ3Rva2VuJywgc2tpcE1heEFnZUNoZWNrKTtcblxuICAgICAgaWYgKHJlZnJlc2hUb2tlbiBpbnN0YW5jZW9mIFRva2VuU2V0ICYmIHJlZnJlc2hUb2tlbi5pZF90b2tlbikge1xuICAgICAgICBjb25zdCBleHBlY3RlZFN1YiA9IHJlZnJlc2hUb2tlbi5jbGFpbXMoKS5zdWI7XG4gICAgICAgIGNvbnN0IGFjdHVhbFN1YiA9IHRva2Vuc2V0LmNsYWltcygpLnN1YjtcbiAgICAgICAgaWYgKGFjdHVhbFN1YiAhPT0gZXhwZWN0ZWRTdWIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgICBwcmludGY6IFsnc3ViIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIGV4cGVjdGVkU3ViLCBhY3R1YWxTdWJdLFxuICAgICAgICAgICAgand0OiB0b2tlbnNldC5pZF90b2tlbixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnNldDtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3RSZXNvdXJjZShcbiAgICByZXNvdXJjZVVybCxcbiAgICBhY2Nlc3NUb2tlbixcbiAgICB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keSxcbiAgICAgIERQb1AsXG4gICAgICB0b2tlblR5cGUgPSBEUG9QXG4gICAgICAgID8gJ0RQb1AnXG4gICAgICAgIDogYWNjZXNzVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldFxuICAgICAgICA/IGFjY2Vzc1Rva2VuLnRva2VuX3R5cGVcbiAgICAgICAgOiAnQmVhcmVyJyxcbiAgICB9ID0ge30sXG4gICAgcmV0cnksXG4gICkge1xuICAgIGlmIChhY2Nlc3NUb2tlbiBpbnN0YW5jZW9mIFRva2VuU2V0KSB7XG4gICAgICBpZiAoIWFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhY2Nlc3NfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcbiAgICAgIH1cbiAgICAgIGFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuO1xuICAgIH1cblxuICAgIGlmICghYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGFjY2VzcyB0b2tlbiBwcm92aWRlZCcpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjY2Vzc1Rva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhY2Nlc3MgdG9rZW4gcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0T3B0cyA9IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbkhlYWRlclZhbHVlKGFjY2Vzc1Rva2VuLCB0b2tlblR5cGUpLFxuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgfSxcbiAgICAgIGJvZHksXG4gICAgfTtcblxuICAgIGNvbnN0IG1UTFMgPSAhIXRoaXMudGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAge1xuICAgICAgICAuLi5yZXF1ZXN0T3B0cyxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYnVmZmVyJyxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICB1cmw6IHJlc291cmNlVXJsLFxuICAgICAgfSxcbiAgICAgIHsgYWNjZXNzVG9rZW4sIG1UTFMsIERQb1AgfSxcbiAgICApO1xuXG4gICAgY29uc3Qgd3d3QXV0aGVudGljYXRlID0gcmVzcG9uc2UuaGVhZGVyc1snd3d3LWF1dGhlbnRpY2F0ZSddO1xuICAgIGlmIChcbiAgICAgIHJldHJ5ICE9PSByZXRyeUF0dGVtcHQgJiZcbiAgICAgIHd3d0F1dGhlbnRpY2F0ZSAmJlxuICAgICAgd3d3QXV0aGVudGljYXRlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZHBvcCAnKSAmJlxuICAgICAgcGFyc2VXd3dBdXRoZW50aWNhdGUod3d3QXV0aGVudGljYXRlKS5lcnJvciA9PT0gJ3VzZV9kcG9wX25vbmNlJ1xuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFJlc291cmNlKHJlc291cmNlVXJsLCBhY2Nlc3NUb2tlbiwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHksXG4gICAgICAgIERQb1AsXG4gICAgICAgIHRva2VuVHlwZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIGFzeW5jIHVzZXJpbmZvKGFjY2Vzc1Rva2VuLCB7IG1ldGhvZCA9ICdHRVQnLCB2aWEgPSAnaGVhZGVyJywgdG9rZW5UeXBlLCBwYXJhbXMsIERQb1AgfSA9IHt9KSB7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3VzZXJpbmZvX2VuZHBvaW50Jyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHRva2VuVHlwZSxcbiAgICAgIG1ldGhvZDogU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKSxcbiAgICAgIERQb1AsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLm1ldGhvZCAhPT0gJ0dFVCcgJiYgb3B0aW9ucy5tZXRob2QgIT09ICdQT1NUJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignI3VzZXJpbmZvKCkgbWV0aG9kIGNhbiBvbmx5IGJlIFBPU1Qgb3IgYSBHRVQnKTtcbiAgICB9XG5cbiAgICBpZiAodmlhID09PSAnYm9keScgJiYgb3B0aW9ucy5tZXRob2QgIT09ICdQT1NUJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FuIG9ubHkgc2VuZCBib2R5IG9uIFBPU1QnKTtcbiAgICB9XG5cbiAgICBjb25zdCBqd3QgPSAhISh0aGlzLnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcgfHwgdGhpcy51c2VyaW5mb19lbmNyeXB0ZWRfcmVzcG9uc2VfYWxnKTtcblxuICAgIGlmIChqd3QpIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHsgQWNjZXB0OiAnYXBwbGljYXRpb24vand0JyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG4gICAgfVxuICAgIGNvbnN0IG1UTFMgPSAhIXRoaXMudGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zO1xuXG4gICAgbGV0IHRhcmdldFVybDtcbiAgICBpZiAobVRMUyAmJiB0aGlzLmlzc3Vlci5tdGxzX2VuZHBvaW50X2FsaWFzZXMpIHtcbiAgICAgIHRhcmdldFVybCA9IHRoaXMuaXNzdWVyLm10bHNfZW5kcG9pbnRfYWxpYXNlcy51c2VyaW5mb19lbmRwb2ludDtcbiAgICB9XG5cbiAgICB0YXJnZXRVcmwgPSBuZXcgVVJMKHRhcmdldFVybCB8fCB0aGlzLmlzc3Vlci51c2VyaW5mb19lbmRwb2ludCk7XG5cbiAgICBpZiAodmlhID09PSAnYm9keScpIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgb3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgb3B0aW9ucy5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgb3B0aW9ucy5ib2R5LmFwcGVuZChcbiAgICAgICAgJ2FjY2Vzc190b2tlbicsXG4gICAgICAgIGFjY2Vzc1Rva2VuIGluc3RhbmNlb2YgVG9rZW5TZXQgPyBhY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4gOiBhY2Nlc3NUb2tlbixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGFkZGl0aW9uYWwgcGFyYW1ldGVycywgR0VUIHZpYSBxdWVyeXN0cmluZywgUE9TVCB2aWEgdXJsZW5jb2RlZCBib2R5XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIHRhcmdldFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICAgIC8vIFBPU1QgJiYgdmlhIGJvZHlcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBvcHRpb25zLmJvZHkuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBPU1QgJiYgdmlhIGhlYWRlclxuICAgICAgICBvcHRpb25zLmJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBvcHRpb25zLmJvZHkuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICBvcHRpb25zLmJvZHkgPSBvcHRpb25zLmJvZHkudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdFJlc291cmNlKHRhcmdldFVybCwgYWNjZXNzVG9rZW4sIG9wdGlvbnMpO1xuXG4gICAgbGV0IHBhcnNlZCA9IHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSwgeyBiZWFyZXI6IHRydWUgfSk7XG5cbiAgICBpZiAoand0KSB7XG4gICAgICBpZiAoIS9eYXBwbGljYXRpb25cXC9qd3QvLnRlc3QocmVzcG9uc2UuaGVhZGVyc1snY29udGVudC10eXBlJ10pKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgYXBwbGljYXRpb24vand0IHJlc3BvbnNlIGZyb20gdGhlIHVzZXJpbmZvX2VuZHBvaW50JyxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJvZHkgPSByZXNwb25zZS5ib2R5LnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCB1c2VyaW5mbyA9IGF3YWl0IHRoaXMuZGVjcnlwdEpXVFVzZXJpbmZvKGJvZHkpO1xuICAgICAgaWYgKCF0aGlzLnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHVzZXJpbmZvKTtcbiAgICAgICAgICBhc3NlcnQoaXNQbGFpbk9iamVjdChwYXJzZWQpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ2ZhaWxlZCB0byBwYXJzZSB1c2VyaW5mbyBKV0UgcGF5bG9hZCBhcyBKU09OJyxcbiAgICAgICAgICAgIGp3dDogdXNlcmluZm8sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICh7IHBheWxvYWQ6IHBhcnNlZCB9ID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpXVFVzZXJpbmZvKHVzZXJpbmZvKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UocmVzcG9uc2UuYm9keSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ3Jlc3BvbnNlJywgeyB2YWx1ZTogcmVzcG9uc2UgfSk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWNjZXNzVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldCAmJiBhY2Nlc3NUb2tlbi5pZF90b2tlbikge1xuICAgICAgY29uc3QgZXhwZWN0ZWRTdWIgPSBhY2Nlc3NUb2tlbi5jbGFpbXMoKS5zdWI7XG4gICAgICBpZiAocGFyc2VkLnN1YiAhPT0gZXhwZWN0ZWRTdWIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIHByaW50ZjogWyd1c2VyaW5mbyBzdWIgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgZXhwZWN0ZWRTdWIsIHBhcnNlZC5zdWJdLFxuICAgICAgICAgIGJvZHk6IHBhcnNlZCxcbiAgICAgICAgICBqd3Q6IGFjY2Vzc1Rva2VuLmlkX3Rva2VuLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgZW5jcnlwdGlvblNlY3JldChsZW4pIHtcbiAgICBjb25zdCBoYXNoID0gbGVuIDw9IDI1NiA/ICdzaGEyNTYnIDogbGVuIDw9IDM4NCA/ICdzaGEzODQnIDogbGVuIDw9IDUxMiA/ICdzaGE1MTInIDogZmFsc2U7XG4gICAgaWYgKCFoYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHN5bW1ldHJpYyBlbmNyeXB0aW9uIGtleSBkZXJpdmF0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyeXB0b1xuICAgICAgLmNyZWF0ZUhhc2goaGFzaClcbiAgICAgIC51cGRhdGUodGhpcy5jbGllbnRfc2VjcmV0KVxuICAgICAgLmRpZ2VzdCgpXG4gICAgICAuc2xpY2UoMCwgbGVuIC8gOCk7XG4gIH1cblxuICBzZWNyZXRGb3JBbGcoYWxnKSB7XG4gICAgaWYgKCF0aGlzLmNsaWVudF9zZWNyZXQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NsaWVudF9zZWNyZXQgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoL15BKFxcZHszfSkoPzpHQ00pP0tXJC8udGVzdChhbGcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uU2VjcmV0KHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApKTtcbiAgICB9XG5cbiAgICBpZiAoL15BKFxcZHszfSkoPzpHQ018Q0JDLUhTKFxcZHszfSkpJC8udGVzdChhbGcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uU2VjcmV0KHBhcnNlSW50KFJlZ0V4cC4kMiB8fCBSZWdFeHAuJDEsIDEwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0aGlzLmNsaWVudF9zZWNyZXQpO1xuICB9XG5cbiAgYXN5bmMgZ3JhbnQoYm9keSwgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0gPSB7fSwgcmV0cnkpIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAndG9rZW5fZW5kcG9pbnQnKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0ZWRQb3N0LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3Rva2VuJyxcbiAgICAgIHtcbiAgICAgICAgZm9ybTogYm9keSxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICB9LFxuICAgICAgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0sXG4gICAgKTtcbiAgICBsZXQgcmVzcG9uc2VCb2R5O1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZUJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHJldHJ5ICE9PSByZXRyeUF0dGVtcHQgJiYgZXJyIGluc3RhbmNlb2YgT1BFcnJvciAmJiBlcnIuZXJyb3IgPT09ICd1c2VfZHBvcF9ub25jZScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhbnQoYm9keSwgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0sIHJldHJ5QXR0ZW1wdCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUb2tlblNldChyZXNwb25zZUJvZHkpO1xuICB9XG5cbiAgYXN5bmMgZGV2aWNlQXV0aG9yaXphdGlvbihwYXJhbXMgPSB7fSwgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9KSB7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ2RldmljZV9hdXRob3JpemF0aW9uX2VuZHBvaW50Jyk7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3Rva2VuX2VuZHBvaW50Jyk7XG5cbiAgICBjb25zdCBib2R5ID0gYXV0aG9yaXphdGlvblBhcmFtcy5jYWxsKHRoaXMsIHtcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXG4gICAgICByZWRpcmVjdF91cmk6IG51bGwsXG4gICAgICByZXNwb25zZV90eXBlOiBudWxsLFxuICAgICAgLi4ucGFyYW1zLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGVkUG9zdC5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdkZXZpY2VfYXV0aG9yaXphdGlvbicsXG4gICAgICB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICBmb3JtOiBib2R5LFxuICAgICAgfSxcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgZW5kcG9pbnRBdXRoTWV0aG9kOiAndG9rZW4nIH0sXG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZUJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuXG4gICAgcmV0dXJuIG5ldyBEZXZpY2VGbG93SGFuZGxlKHtcbiAgICAgIGNsaWVudDogdGhpcyxcbiAgICAgIGV4Y2hhbmdlQm9keSxcbiAgICAgIGNsaWVudEFzc2VydGlvblBheWxvYWQsXG4gICAgICByZXNwb25zZTogcmVzcG9uc2VCb2R5LFxuICAgICAgbWF4QWdlOiBwYXJhbXMubWF4X2FnZSxcbiAgICAgIERQb1AsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZXZva2UodG9rZW4sIGhpbnQsIHsgcmV2b2tlQm9keSwgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCB9ID0ge30pIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAncmV2b2NhdGlvbl9lbmRwb2ludCcpO1xuICAgIGlmIChoaW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtID0geyAuLi5yZXZva2VCb2R5LCB0b2tlbiB9O1xuXG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGZvcm0udG9rZW5fdHlwZV9oaW50ID0gaGludDtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0ZWRQb3N0LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3Jldm9jYXRpb24nLFxuICAgICAge1xuICAgICAgICBmb3JtLFxuICAgICAgfSxcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCB9LFxuICAgICk7XG4gICAgcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IGJvZHk6IGZhbHNlIH0pO1xuICB9XG5cbiAgYXN5bmMgaW50cm9zcGVjdCh0b2tlbiwgaGludCwgeyBpbnRyb3NwZWN0Qm9keSwgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCB9ID0ge30pIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnaW50cm9zcGVjdGlvbl9lbmRwb2ludCcpO1xuICAgIGlmIChoaW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtID0geyAuLi5pbnRyb3NwZWN0Qm9keSwgdG9rZW4gfTtcbiAgICBpZiAoaGludCkge1xuICAgICAgZm9ybS50b2tlbl90eXBlX2hpbnQgPSBoaW50O1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRlZFBvc3QuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnaW50cm9zcGVjdGlvbicsXG4gICAgICB7IGZvcm0sIHJlc3BvbnNlVHlwZTogJ2pzb24nIH0sXG4gICAgICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQgfSxcbiAgICApO1xuXG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcblxuICAgIHJldHVybiByZXNwb25zZUJvZHk7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgcmVnaXN0ZXIobWV0YWRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgaW5pdGlhbEFjY2Vzc1Rva2VuLCBqd2tzLCAuLi5jbGllbnRPcHRpb25zIH0gPSBvcHRpb25zO1xuXG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3JlZ2lzdHJhdGlvbl9lbmRwb2ludCcpO1xuXG4gICAgaWYgKGp3a3MgIT09IHVuZGVmaW5lZCAmJiAhKG1ldGFkYXRhLmp3a3MgfHwgbWV0YWRhdGEuandrc191cmkpKSB7XG4gICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGdldEtleXN0b3JlLmNhbGwodGhpcywgandrcyk7XG4gICAgICBtZXRhZGF0YS5qd2tzID0ga2V5c3RvcmUudG9KV0tTKCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmNhbGwodGhpcywge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgLi4uKGluaXRpYWxBY2Nlc3NUb2tlblxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uSGVhZGVyVmFsdWUoaW5pdGlhbEFjY2Vzc1Rva2VuKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHVuZGVmaW5lZCksXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICBqc29uOiBtZXRhZGF0YSxcbiAgICAgIHVybDogdGhpcy5pc3N1ZXIucmVnaXN0cmF0aW9uX2VuZHBvaW50LFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IHN0YXR1c0NvZGU6IDIwMSwgYmVhcmVyOiB0cnVlIH0pO1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzKHJlc3BvbnNlQm9keSwgandrcywgY2xpZW50T3B0aW9ucyk7XG4gIH1cblxuICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIGNsb25lKE9iamVjdC5mcm9tRW50cmllcyh0aGlzLiNtZXRhZGF0YS5lbnRyaWVzKCkpKTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tVXJpKHJlZ2lzdHJhdGlvbkNsaWVudFVyaSwgcmVnaXN0cmF0aW9uQWNjZXNzVG9rZW4sIGp3a3MsIGNsaWVudE9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuY2FsbCh0aGlzLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiByZWdpc3RyYXRpb25DbGllbnRVcmksXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbkhlYWRlclZhbHVlKHJlZ2lzdHJhdGlvbkFjY2Vzc1Rva2VuKSxcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSwgeyBiZWFyZXI6IHRydWUgfSk7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMocmVzcG9uc2VCb2R5LCBqd2tzLCBjbGllbnRPcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3RPYmplY3QoXG4gICAgcmVxdWVzdE9iamVjdCA9IHt9LFxuICAgIHtcbiAgICAgIHNpZ246IHNpZ25pbmdBbGdvcml0aG0gPSB0aGlzLnJlcXVlc3Rfb2JqZWN0X3NpZ25pbmdfYWxnIHx8ICdub25lJyxcbiAgICAgIGVuY3J5cHQ6IHtcbiAgICAgICAgYWxnOiBlS2V5TWFuYWdlbWVudCA9IHRoaXMucmVxdWVzdF9vYmplY3RfZW5jcnlwdGlvbl9hbGcsXG4gICAgICAgIGVuYzogZUNvbnRlbnRFbmNyeXB0aW9uID0gdGhpcy5yZXF1ZXN0X29iamVjdF9lbmNyeXB0aW9uX2VuYyB8fCAnQTEyOENCQy1IUzI1NicsXG4gICAgICB9ID0ge30sXG4gICAgfSA9IHt9LFxuICApIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QocmVxdWVzdE9iamVjdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlcXVlc3RPYmplY3QgbXVzdCBiZSBhIHBsYWluIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGxldCBzaWduZWQ7XG4gICAgbGV0IGtleTtcbiAgICBjb25zdCB1bml4ID0gbm93KCk7XG4gICAgY29uc3QgaGVhZGVyID0geyBhbGc6IHNpZ25pbmdBbGdvcml0aG0sIHR5cDogJ29hdXRoLWF1dGh6LXJlcStqd3QnIH07XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgZGVmYXVsdHMoe30sIHJlcXVlc3RPYmplY3QsIHtcbiAgICAgICAgaXNzOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgICAgYXVkOiB0aGlzLmlzc3Vlci5pc3N1ZXIsXG4gICAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXG4gICAgICAgIGp0aTogcmFuZG9tKCksXG4gICAgICAgIGlhdDogdW5peCxcbiAgICAgICAgZXhwOiB1bml4ICsgMzAwLFxuICAgICAgICAuLi4odGhpcy5mYXBpKCkgPyB7IG5iZjogdW5peCB9IDogdW5kZWZpbmVkKSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgaWYgKHNpZ25pbmdBbGdvcml0aG0gPT09ICdub25lJykge1xuICAgICAgc2lnbmVkID0gW2Jhc2U2NHVybC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksIGJhc2U2NHVybC5lbmNvZGUocGF5bG9hZCksICcnXS5qb2luKCcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN5bW1ldHJpYyA9IHNpZ25pbmdBbGdvcml0aG0uc3RhcnRzV2l0aCgnSFMnKTtcbiAgICAgIGlmIChzeW1tZXRyaWMpIHtcbiAgICAgICAga2V5ID0gdGhpcy5zZWNyZXRGb3JBbGcoc2lnbmluZ0FsZ29yaXRobSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGtleXN0b3Jlcy5nZXQodGhpcyk7XG5cbiAgICAgICAgaWYgKCFrZXlzdG9yZSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgbm8ga2V5c3RvcmUgcHJlc2VudCBmb3IgY2xpZW50LCBjYW5ub3Qgc2lnbiB1c2luZyBhbGcgJHtzaWduaW5nQWxnb3JpdGhtfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBrZXlzdG9yZS5nZXQoeyBhbGc6IHNpZ25pbmdBbGdvcml0aG0sIHVzZTogJ3NpZycgfSk7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbm8ga2V5IHRvIHNpZ24gd2l0aCBmb3VuZCBmb3IgYWxnICR7c2lnbmluZ0FsZ29yaXRobX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzaWduZWQgPSBhd2FpdCBuZXcgam9zZS5Db21wYWN0U2lnbihuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGF5bG9hZCkpXG4gICAgICAgIC5zZXRQcm90ZWN0ZWRIZWFkZXIoe1xuICAgICAgICAgIC4uLmhlYWRlcixcbiAgICAgICAgICBraWQ6IHN5bW1ldHJpYyA/IHVuZGVmaW5lZCA6IGtleS5qd2sua2lkLFxuICAgICAgICB9KVxuICAgICAgICAuc2lnbihzeW1tZXRyaWMgPyBrZXkgOiBhd2FpdCBrZXkua2V5T2JqZWN0KHNpZ25pbmdBbGdvcml0aG0pKTtcbiAgICB9XG5cbiAgICBpZiAoIWVLZXlNYW5hZ2VtZW50KSB7XG4gICAgICByZXR1cm4gc2lnbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkcyA9IHsgYWxnOiBlS2V5TWFuYWdlbWVudCwgZW5jOiBlQ29udGVudEVuY3J5cHRpb24sIGN0eTogJ29hdXRoLWF1dGh6LXJlcStqd3QnIH07XG5cbiAgICBpZiAoZmllbGRzLmFsZy5tYXRjaCgvXihSU0F8RUNESCkvKSkge1xuICAgICAgW2tleV0gPSBhd2FpdCBxdWVyeUtleVN0b3JlLmNhbGwoXG4gICAgICAgIHRoaXMuaXNzdWVyLFxuICAgICAgICB7IGFsZzogZmllbGRzLmFsZywgdXNlOiAnZW5jJyB9LFxuICAgICAgICB7IGFsbG93TXVsdGk6IHRydWUgfSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHRoaXMuc2VjcmV0Rm9yQWxnKGZpZWxkcy5hbGcgPT09ICdkaXInID8gZmllbGRzLmVuYyA6IGZpZWxkcy5hbGcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgam9zZS5Db21wYWN0RW5jcnlwdChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2lnbmVkKSlcbiAgICAgIC5zZXRQcm90ZWN0ZWRIZWFkZXIoe1xuICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgIGtpZDoga2V5IGluc3RhbmNlb2YgVWludDhBcnJheSA/IHVuZGVmaW5lZCA6IGtleS5qd2sua2lkLFxuICAgICAgfSlcbiAgICAgIC5lbmNyeXB0KGtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBrZXkgOiBhd2FpdCBrZXkua2V5T2JqZWN0KGZpZWxkcy5hbGcpKTtcbiAgfVxuXG4gIGFzeW5jIHB1c2hlZEF1dGhvcml6YXRpb25SZXF1ZXN0KHBhcmFtcyA9IHt9LCB7IGNsaWVudEFzc2VydGlvblBheWxvYWQgfSA9IHt9KSB7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3B1c2hlZF9hdXRob3JpemF0aW9uX3JlcXVlc3RfZW5kcG9pbnQnKTtcblxuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAuLi4oJ3JlcXVlc3QnIGluIHBhcmFtcyA/IHBhcmFtcyA6IGF1dGhvcml6YXRpb25QYXJhbXMuY2FsbCh0aGlzLCBwYXJhbXMpKSxcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRlZFBvc3QuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncHVzaGVkX2F1dGhvcml6YXRpb25fcmVxdWVzdCcsXG4gICAgICB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICBmb3JtOiBib2R5LFxuICAgICAgfSxcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgZW5kcG9pbnRBdXRoTWV0aG9kOiAndG9rZW4nIH0sXG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZUJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UsIHsgc3RhdHVzQ29kZTogMjAxIH0pO1xuXG4gICAgaWYgKCEoJ2V4cGlyZXNfaW4nIGluIHJlc3BvbnNlQm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ2V4cGVjdGVkIGV4cGlyZXNfaW4gaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VCb2R5LmV4cGlyZXNfaW4gIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkIGV4cGlyZXNfaW4gdmFsdWUgaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghKCdyZXF1ZXN0X3VyaScgaW4gcmVzcG9uc2VCb2R5KSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgcmVxdWVzdF91cmkgaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VCb2R5LnJlcXVlc3RfdXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCByZXF1ZXN0X3VyaSB2YWx1ZSBpbiBQdXNoZWQgQXV0aG9yaXphdGlvbiBTdWNjZXNzZnVsIFJlc3BvbnNlJyxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2VCb2R5O1xuICB9XG5cbiAgZ2V0IGlzc3VlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNzdWVyO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgW2luc3BlY3QuY3VzdG9tXSgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAke2luc3BlY3QodGhpcy5tZXRhZGF0YSwge1xuICAgICAgZGVwdGg6IEluZmluaXR5LFxuICAgICAgY29sb3JzOiBwcm9jZXNzLnN0ZG91dC5pc1RUWSxcbiAgICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgICAgc29ydGVkOiB0cnVlLFxuICAgIH0pfWA7XG4gIH1cblxuICBmYXBpKCkge1xuICAgIHJldHVybiB0aGlzLmZhcGkxKCkgfHwgdGhpcy5mYXBpMigpO1xuICB9XG5cbiAgZmFwaTEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSA9PT0gJ0ZBUEkxQ2xpZW50JztcbiAgfVxuXG4gIGZhcGkyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdGQVBJMkNsaWVudCc7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUpBUk0ocmVzcG9uc2UpIHtcbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMuYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnO1xuICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpXVChyZXNwb25zZSwgZXhwZWN0ZWRBbGcsIFsnaXNzJywgJ2V4cCcsICdhdWQnXSk7XG4gICAgcmV0dXJuIHBpY2tDYihwYXlsb2FkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBkcG9wUHJvb2ZcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhc3luYyBkcG9wUHJvb2YocGF5bG9hZCwgcHJpdmF0ZUtleUlucHV0LCBhY2Nlc3NUb2tlbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChwYXlsb2FkKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF5bG9hZCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgbGV0IHByaXZhdGVLZXk7XG4gICAgaWYgKGlzS2V5T2JqZWN0KHByaXZhdGVLZXlJbnB1dCkpIHtcbiAgICAgIHByaXZhdGVLZXkgPSBwcml2YXRlS2V5SW5wdXQ7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5SW5wdXRbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0NyeXB0b0tleScpIHtcbiAgICAgIHByaXZhdGVLZXkgPSBwcml2YXRlS2V5SW5wdXQ7XG4gICAgfSBlbHNlIGlmIChqb3NlLmNyeXB0b1J1bnRpbWUgPT09ICdub2RlOmNyeXB0bycpIHtcbiAgICAgIHByaXZhdGVLZXkgPSBjcnlwdG8uY3JlYXRlUHJpdmF0ZUtleShwcml2YXRlS2V5SW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnJlY29nbml6ZWQgY3J5cHRvIHJ1bnRpbWUnKTtcbiAgICB9XG5cbiAgICBpZiAocHJpdmF0ZUtleS50eXBlICE9PSAncHJpdmF0ZScpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiRFBvUFwiIG9wdGlvbiBtdXN0IGJlIGEgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgbGV0IGFsZyA9IGRldGVybWluZURQb1BBbGdvcml0aG0uY2FsbCh0aGlzLCBwcml2YXRlS2V5LCBwcml2YXRlS2V5SW5wdXQpO1xuXG4gICAgaWYgKCFhbGcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBkZXRlcm1pbmUgRFBvUCBKV1MgQWxnb3JpdGhtJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBqb3NlLlNpZ25KV1Qoe1xuICAgICAgYXRoOiBhY2Nlc3NUb2tlblxuICAgICAgICA/IGJhc2U2NHVybC5lbmNvZGUoY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhY2Nlc3NUb2tlbikuZGlnZXN0KCkpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgLi4ucGF5bG9hZCxcbiAgICB9KVxuICAgICAgLnNldFByb3RlY3RlZEhlYWRlcih7XG4gICAgICAgIGFsZyxcbiAgICAgICAgdHlwOiAnZHBvcCtqd3QnLFxuICAgICAgICBqd2s6IGF3YWl0IGdldEp3ayhwcml2YXRlS2V5LCBwcml2YXRlS2V5SW5wdXQpLFxuICAgICAgfSlcbiAgICAgIC5zZXRJc3N1ZWRBdCgpXG4gICAgICAuc2V0SnRpKHJhbmRvbSgpKVxuICAgICAgLnNpZ24ocHJpdmF0ZUtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lRFBvUEFsZ29yaXRobUZyb21DcnlwdG9LZXkoY3J5cHRvS2V5KSB7XG4gIHN3aXRjaCAoY3J5cHRvS2V5LmFsZ29yaXRobS5uYW1lKSB7XG4gICAgY2FzZSAnRWQyNTUxOSc6XG4gICAgY2FzZSAnRWQ0NDgnOlxuICAgICAgcmV0dXJuICdFZERTQSc7XG4gICAgY2FzZSAnRUNEU0EnOiB7XG4gICAgICBzd2l0Y2ggKGNyeXB0b0tleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSkge1xuICAgICAgICBjYXNlICdQLTI1Nic6XG4gICAgICAgICAgcmV0dXJuICdFUzI1Nic7XG4gICAgICAgIGNhc2UgJ1AtMzg0JzpcbiAgICAgICAgICByZXR1cm4gJ0VTMzg0JztcbiAgICAgICAgY2FzZSAnUC01MjEnOlxuICAgICAgICAgIHJldHVybiAnRVM1MTInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ1JTQVNTQS1QS0NTMS12MV81JzpcbiAgICAgIHJldHVybiBgUlMke2NyeXB0b0tleS5hbGdvcml0aG0uaGFzaC5uYW1lLnNsaWNlKDQpfWA7XG4gICAgY2FzZSAnUlNBLVBTUyc6XG4gICAgICByZXR1cm4gYFBTJHtjcnlwdG9LZXkuYWxnb3JpdGhtLmhhc2gubmFtZS5zbGljZSg0KX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnN1cHBvcnRlZCBEUG9QIHByaXZhdGUga2V5Jyk7XG4gIH1cbn1cblxubGV0IGRldGVybWluZURQb1BBbGdvcml0aG07XG5pZiAoam9zZS5jcnlwdG9SdW50aW1lID09PSAnbm9kZTpjcnlwdG8nKSB7XG4gIGRldGVybWluZURQb1BBbGdvcml0aG0gPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgcHJpdmF0ZUtleUlucHV0KSB7XG4gICAgaWYgKHByaXZhdGVLZXlJbnB1dFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQ3J5cHRvS2V5Jykge1xuICAgICAgcmV0dXJuIGRldGVybWluZURQb1BBbGdvcml0aG1Gcm9tQ3J5cHRvS2V5KHByaXZhdGVLZXkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAocHJpdmF0ZUtleS5hc3ltbWV0cmljS2V5VHlwZSkge1xuICAgICAgY2FzZSAnZWQyNTUxOSc6XG4gICAgICBjYXNlICdlZDQ0OCc6XG4gICAgICAgIHJldHVybiAnRWREU0EnO1xuICAgICAgY2FzZSAnZWMnOlxuICAgICAgICByZXR1cm4gZGV0ZXJtaW5lRWNBbGdvcml0aG0ocHJpdmF0ZUtleSwgcHJpdmF0ZUtleUlucHV0KTtcbiAgICAgIGNhc2UgJ3JzYSc6XG4gICAgICBjYXNlIHJzYVBzc1BhcmFtcyAmJiAncnNhLXBzcyc6XG4gICAgICAgIHJldHVybiBkZXRlcm1pbmVSc2FBbGdvcml0aG0oXG4gICAgICAgICAgcHJpdmF0ZUtleSxcbiAgICAgICAgICBwcml2YXRlS2V5SW5wdXQsXG4gICAgICAgICAgdGhpcy5pc3N1ZXIuZHBvcF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkLFxuICAgICAgICApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgRFBvUCBwcml2YXRlIGtleScpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBSU1BTID0gL14oPzpSU3xQUykoPzoyNTZ8Mzg0fDUxMikkLztcbiAgZnVuY3Rpb24gZGV0ZXJtaW5lUnNhQWxnb3JpdGhtKHByaXZhdGVLZXksIHByaXZhdGVLZXlJbnB1dCwgdmFsdWVzU3VwcG9ydGVkKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHByaXZhdGVLZXlJbnB1dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHByaXZhdGVLZXlJbnB1dC5mb3JtYXQgPT09ICdqd2snICYmXG4gICAgICBwcml2YXRlS2V5SW5wdXQua2V5ICYmXG4gICAgICBwcml2YXRlS2V5SW5wdXQua2V5LmFsZ1xuICAgICkge1xuICAgICAgcmV0dXJuIHByaXZhdGVLZXlJbnB1dC5rZXkuYWxnO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlc1N1cHBvcnRlZCkpIHtcbiAgICAgIGxldCBjYW5kaWRhdGVzID0gdmFsdWVzU3VwcG9ydGVkLmZpbHRlcihSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZChSU1BTKSk7XG4gICAgICBpZiAocHJpdmF0ZUtleS5hc3ltbWV0cmljS2V5VHlwZSA9PT0gJ3JzYS1wc3MnKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnN0YXJ0c1dpdGgoJ1BTJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsnUFMyNTYnLCAnUFMzODQnLCAnUFM1MTInLCAnUlMyNTYnLCAnUlMzODQnLCAnUlMzODQnXS5maW5kKChwcmVmZXJyZWQpID0+XG4gICAgICAgIGNhbmRpZGF0ZXMuaW5jbHVkZXMocHJlZmVycmVkKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuICdQUzI1Nic7XG4gIH1cblxuICBjb25zdCBwMjU2ID0gQnVmZmVyLmZyb20oWzQyLCAxMzQsIDcyLCAyMDYsIDYxLCAzLCAxLCA3XSk7XG4gIGNvbnN0IHAzODQgPSBCdWZmZXIuZnJvbShbNDMsIDEyOSwgNCwgMCwgMzRdKTtcbiAgY29uc3QgcDUyMSA9IEJ1ZmZlci5mcm9tKFs0MywgMTI5LCA0LCAwLCAzNV0pO1xuICBjb25zdCBzZWNwMjU2azEgPSBCdWZmZXIuZnJvbShbNDMsIDEyOSwgNCwgMCwgMTBdKTtcblxuICBmdW5jdGlvbiBkZXRlcm1pbmVFY0FsZ29yaXRobShwcml2YXRlS2V5LCBwcml2YXRlS2V5SW5wdXQpIHtcbiAgICAvLyBJZiBpbnB1dCB3YXMgYSBKV0tcbiAgICBzd2l0Y2ggKFxuICAgICAgdHlwZW9mIHByaXZhdGVLZXlJbnB1dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBwcml2YXRlS2V5SW5wdXQua2V5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgcHJpdmF0ZUtleUlucHV0LmtleS5jcnZcbiAgICApIHtcbiAgICAgIGNhc2UgJ1AtMjU2JzpcbiAgICAgICAgcmV0dXJuICdFUzI1Nic7XG4gICAgICBjYXNlICdzZWNwMjU2azEnOlxuICAgICAgICByZXR1cm4gJ0VTMjU2Syc7XG4gICAgICBjYXNlICdQLTM4NCc6XG4gICAgICAgIHJldHVybiAnRVMzODQnO1xuICAgICAgY2FzZSAnUC01MTInOlxuICAgICAgICByZXR1cm4gJ0VTNTEyJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHByaXZhdGVLZXkuZXhwb3J0KHsgZm9ybWF0OiAnZGVyJywgdHlwZTogJ3BrY3M4JyB9KTtcbiAgICBjb25zdCBpID0gYnVmWzFdIDwgMTI4ID8gMTcgOiAxODtcbiAgICBjb25zdCBsZW4gPSBidWZbaV07XG4gICAgY29uc3QgY3VydmVPaWQgPSBidWYuc2xpY2UoaSArIDEsIGkgKyAxICsgbGVuKTtcbiAgICBpZiAoY3VydmVPaWQuZXF1YWxzKHAyNTYpKSB7XG4gICAgICByZXR1cm4gJ0VTMjU2JztcbiAgICB9XG5cbiAgICBpZiAoY3VydmVPaWQuZXF1YWxzKHAzODQpKSB7XG4gICAgICByZXR1cm4gJ0VTMzg0JztcbiAgICB9XG4gICAgaWYgKGN1cnZlT2lkLmVxdWFscyhwNTIxKSkge1xuICAgICAgcmV0dXJuICdFUzUxMic7XG4gICAgfVxuXG4gICAgaWYgKGN1cnZlT2lkLmVxdWFscyhzZWNwMjU2azEpKSB7XG4gICAgICByZXR1cm4gJ0VTMjU2Syc7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgRFBvUCBwcml2YXRlIGtleSBjdXJ2ZScpO1xuICB9XG59IGVsc2Uge1xuICBkZXRlcm1pbmVEUG9QQWxnb3JpdGhtID0gZGV0ZXJtaW5lRFBvUEFsZ29yaXRobUZyb21DcnlwdG9LZXk7XG59XG5cbmNvbnN0IGp3a0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmFzeW5jIGZ1bmN0aW9uIGdldEp3ayhrZXlPYmplY3QsIHByaXZhdGVLZXlJbnB1dCkge1xuICBpZiAoXG4gICAgam9zZS5jcnlwdG9SdW50aW1lID09PSAnbm9kZTpjcnlwdG8nICYmXG4gICAgdHlwZW9mIHByaXZhdGVLZXlJbnB1dCA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgcHJpdmF0ZUtleUlucHV0LmtleSA9PT0gJ29iamVjdCcgJiZcbiAgICBwcml2YXRlS2V5SW5wdXQuZm9ybWF0ID09PSAnandrJ1xuICApIHtcbiAgICByZXR1cm4gcGljayhwcml2YXRlS2V5SW5wdXQua2V5LCAna3R5JywgJ2NydicsICd4JywgJ3knLCAnZScsICduJyk7XG4gIH1cblxuICBpZiAoandrQ2FjaGUuaGFzKHByaXZhdGVLZXlJbnB1dCkpIHtcbiAgICByZXR1cm4gandrQ2FjaGUuZ2V0KHByaXZhdGVLZXlJbnB1dCk7XG4gIH1cblxuICBjb25zdCBqd2sgPSBwaWNrKGF3YWl0IGpvc2UuZXhwb3J0SldLKGtleU9iamVjdCksICdrdHknLCAnY3J2JywgJ3gnLCAneScsICdlJywgJ24nKTtcblxuICBpZiAoaXNLZXlPYmplY3QocHJpdmF0ZUtleUlucHV0KSB8fCBqb3NlLmNyeXB0b1J1bnRpbWUgPT09ICdXZWJDcnlwdG9BUEknKSB7XG4gICAgandrQ2FjaGUuc2V0KHByaXZhdGVLZXlJbnB1dCwgandrKTtcbiAgfVxuXG4gIHJldHVybiBqd2s7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGlzc3VlciwgYWFkSXNzVmFsaWRhdGlvbiA9IGZhbHNlKSA9PlxuICBjbGFzcyBDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlcihpc3N1ZXIsIGFhZElzc1ZhbGlkYXRpb24sIC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgaXNzdWVyKCkge1xuICAgICAgcmV0dXJuIGlzc3VlcjtcbiAgICB9XG4gIH07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2VDbGllbnQgPSBCYXNlQ2xpZW50O1xuIl0sIm5hbWVzIjpbImluc3BlY3QiLCJyZXF1aXJlIiwic3RkaHR0cCIsImNyeXB0byIsInN0cmljdCIsImFzc2VydCIsInF1ZXJ5c3RyaW5nIiwidXJsIiwiVVJMIiwiVVJMU2VhcmNoUGFyYW1zIiwiam9zZSIsInRva2VuSGFzaCIsImlzS2V5T2JqZWN0IiwiZGVjb2RlSldUIiwiYmFzZTY0dXJsIiwiZGVmYXVsdHMiLCJwYXJzZVd3d0F1dGhlbnRpY2F0ZSIsImFzc2VydFNpZ25pbmdBbGdWYWx1ZXNTdXBwb3J0IiwiYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbiIsInBpY2siLCJpc1BsYWluT2JqZWN0IiwicHJvY2Vzc1Jlc3BvbnNlIiwiVG9rZW5TZXQiLCJPUEVycm9yIiwiUlBFcnJvciIsIm5vdyIsInJhbmRvbSIsInJlcXVlc3QiLCJDTE9DS19UT0xFUkFOQ0UiLCJrZXlzdG9yZXMiLCJLZXlTdG9yZSIsImNsb25lIiwiYXV0aGVudGljYXRlZFBvc3QiLCJyZXNvbHZlUmVzcG9uc2VUeXBlIiwicmVzb2x2ZVJlZGlyZWN0VXJpIiwicXVlcnlLZXlTdG9yZSIsIkRldmljZUZsb3dIYW5kbGUiLCJtYWpvciIsIm1pbm9yIiwicHJvY2VzcyIsInZlcnNpb24iLCJzbGljZSIsInNwbGl0IiwibWFwIiwic3RyIiwicGFyc2VJbnQiLCJyc2FQc3NQYXJhbXMiLCJyZXRyeUF0dGVtcHQiLCJTeW1ib2wiLCJza2lwTm9uY2VDaGVjayIsInNraXBNYXhBZ2VDaGVjayIsInBpY2tDYiIsImlucHV0IiwiYXV0aG9yaXphdGlvbkhlYWRlclZhbHVlIiwidG9rZW4iLCJ0b2tlblR5cGUiLCJnZXRTZWFyY2hQYXJhbXMiLCJwYXJzZWQiLCJwYXJzZSIsInNlYXJjaCIsInN1YnN0cmluZyIsInZlcmlmeVByZXNlbmNlIiwicGF5bG9hZCIsImp3dCIsInByb3AiLCJ1bmRlZmluZWQiLCJtZXNzYWdlIiwiYXV0aG9yaXphdGlvblBhcmFtcyIsInBhcmFtcyIsImF1dGhQYXJhbXMiLCJjbGllbnRfaWQiLCJzY29wZSIsInJlc3BvbnNlX3R5cGUiLCJjYWxsIiwicmVkaXJlY3RfdXJpIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJBcnJheSIsImlzQXJyYXkiLCJTdHJpbmciLCJnZXRLZXlzdG9yZSIsImp3a3MiLCJrZXlzIiwic29tZSIsImsiLCJUeXBlRXJyb3IiLCJmcm9tSldLUyIsIm9ubHlQcml2YXRlIiwiY2hlY2tCYXNpY1N1cHBvcnQiLCJjbGllbnQiLCJwcm9wZXJ0aWVzIiwic3VwcG9ydGVkIiwiaXNzdWVyIiwidG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZCIsImluY2x1ZGVzIiwidG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QiLCJlcnIiLCJoYW5kbGVDb21tb25NaXN0YWtlcyIsIm1ldGFkYXRhIiwicmVkaXJlY3RfdXJpcyIsInJlc3BvbnNlX3R5cGVzIiwiZ2V0RGVmYXVsdHNGb3JFbmRwb2ludCIsImVuZHBvaW50IiwidG9rZW5FbmRwb2ludEF1dGhNZXRob2QiLCJ0b2tlbkVuZHBvaW50QXV0aFNpZ25pbmdBbGciLCJ0b2tlbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnIiwiZWFtIiwiZWFzYSIsIkJhc2VDbGllbnQiLCJjb25zdHJ1Y3RvciIsImFhZElzc1ZhbGlkYXRpb24iLCJvcHRpb25zIiwiTWFwIiwiZ3JhbnRfdHlwZXMiLCJpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwiYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwiZmFwaTEiLCJ0bHNfY2xpZW50X2NlcnRpZmljYXRlX2JvdW5kX2FjY2Vzc190b2tlbnMiLCJmYXBpMiIsImZhcGkiLCJkcG9wX2JvdW5kX2FjY2Vzc190b2tlbnMiLCJzZXQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImVudW1lcmFibGUiLCJrZXlzdG9yZSIsImFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyIsImF1dGhvcml6YXRpb25VcmwiLCJ0YXJnZXQiLCJhdXRob3JpemF0aW9uX2VuZHBvaW50IiwibmFtZSIsInNlYXJjaFBhcmFtcyIsImRlbGV0ZSIsIm1lbWJlciIsImFwcGVuZCIsImhyZWYiLCJyZXBsYWNlIiwiYXV0aG9yaXphdGlvblBvc3QiLCJpbnB1dHMiLCJmb3JtSW5wdXRzIiwiam9pbiIsImVuZFNlc3Npb25VcmwiLCJwb3N0TG9nb3V0IiwibGVuZ3RoIiwicG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpcyIsInBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSIsImlkX3Rva2VuX2hpbnQiLCJpZF90b2tlbiIsImVuZF9zZXNzaW9uX2VuZHBvaW50IiwicXVlcnkiLCJmb3JtYXQiLCJjYWxsYmFja1BhcmFtcyIsImlzSW5jb21pbmdNZXNzYWdlIiwiSW5jb21pbmdNZXNzYWdlIiwibWV0aG9kIiwiaXNTdHJpbmciLCJib2R5IiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJ0b1N0cmluZyIsImNhbGxiYWNrIiwicmVkaXJlY3RVcmkiLCJwYXJhbWV0ZXJzIiwiY2hlY2tzIiwiZXhjaGFuZ2VCb2R5IiwiY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCIsIkRQb1AiLCJqYXJtIiwiZGVjcnlwdGVkIiwiZGVjcnlwdEpBUk0iLCJyZXNwb25zZSIsInZhbGlkYXRlSkFSTSIsImRlZmF1bHRfbWF4X2FnZSIsIm1heF9hZ2UiLCJzdGF0ZSIsInByaW50ZiIsImlzcyIsImF1dGhvcml6YXRpb25fcmVzcG9uc2VfaXNzX3BhcmFtZXRlcl9zdXBwb3J0ZWQiLCJlcnJvciIsIlJFU1BPTlNFX1RZUEVfUkVRVUlSRURfUEFSQU1TIiwiY29kZSIsInR5cGUiLCJhY2Nlc3NfdG9rZW4iLCJwYXJhbSIsInRva2Vuc2V0IiwiZGVjcnlwdElkVG9rZW4iLCJ2YWxpZGF0ZUlkVG9rZW4iLCJub25jZSIsImdyYW50IiwiZ3JhbnRfdHlwZSIsImNvZGVfdmVyaWZpZXIiLCJzZXNzaW9uX3N0YXRlIiwib2F1dGhDYWxsYmFjayIsImlkX3Rva2VuX2VuY3J5cHRlZF9yZXNwb25zZV9hbGciLCJpZFRva2VuIiwiZXhwZWN0ZWRBbGciLCJleHBlY3RlZEVuYyIsImlkX3Rva2VuX2VuY3J5cHRlZF9yZXNwb25zZV9lbmMiLCJyZXN1bHQiLCJkZWNyeXB0SldFIiwidmFsaWRhdGVKV1RVc2VyaW5mbyIsInVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGciLCJ2YWxpZGF0ZUpXVCIsImF1dGhvcml6YXRpb25fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZyIsImF1dGhvcml6YXRpb25fZW5jcnlwdGVkX3Jlc3BvbnNlX2VuYyIsImRlY3J5cHRKV1RVc2VyaW5mbyIsInVzZXJpbmZvX2VuY3J5cHRlZF9yZXNwb25zZV9hbGciLCJ1c2VyaW5mb19lbmNyeXB0ZWRfcmVzcG9uc2VfZW5jIiwiandlIiwiaGVhZGVyIiwiZGVjb2RlIiwiYWxnIiwiZW5jIiwiZ2V0UGxhaW50ZXh0IiwiVGV4dERlY29kZXIiLCJwbGFpbnRleHQiLCJtYXRjaCIsInByb3RlY3RlZEhlYWRlciIsImRlY29kZVByb3RlY3RlZEhlYWRlciIsImFsbCIsInVzZSIsImNvbXBhY3REZWNyeXB0Iiwia2V5T2JqZWN0IiwidGhlbiIsInNlY3JldEZvckFsZyIsInRva2VuU2V0IiwicmV0dXJuZWRCeSIsIm1heEFnZSIsImlzVG9rZW5TZXQiLCJ0aW1lc3RhbXAiLCJwcm90ZWN0ZWQiLCJyZXF1aXJlX2F1dGhfdGltZSIsImF1dGhfdGltZSIsInRvbGVyYW5jZSIsImF0X2hhc2giLCJjX2hhc2giLCJzX2hhc2giLCJ2YWxpZGF0ZSIsImNsYWltIiwic291cmNlIiwiandrIiwiY3J2IiwiaWF0IiwicmVxdWlyZWQiLCJpc1NlbGZJc3N1ZWQiLCJjb21wbGV0ZSIsImJpbmQiLCJleHBlY3RlZElzcyIsInRpZCIsIm5iZiIsImV4cCIsImF1ZCIsImF6cCIsInN1Yl9qd2siLCJpbXBvcnRKV0siLCJlcXVhbCIsImNhbGN1bGF0ZUp3a1RodW1icHJpbnQiLCJzdWIiLCJzdGFydHNXaXRoIiwidmVyaWZpZWQiLCJjb21wYWN0VmVyaWZ5IiwiVWludDhBcnJheSIsImNhdGNoIiwicmVmcmVzaCIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hfdG9rZW4iLCJleHBlY3RlZFN1YiIsImNsYWltcyIsImFjdHVhbFN1YiIsInJlcXVlc3RSZXNvdXJjZSIsInJlc291cmNlVXJsIiwiYWNjZXNzVG9rZW4iLCJoZWFkZXJzIiwidG9rZW5fdHlwZSIsInJldHJ5IiwicmVxdWVzdE9wdHMiLCJBdXRob3JpemF0aW9uIiwibVRMUyIsInJlc3BvbnNlVHlwZSIsInd3d0F1dGhlbnRpY2F0ZSIsInRvTG93ZXJDYXNlIiwidXNlcmluZm8iLCJ2aWEiLCJ0b1VwcGVyQ2FzZSIsIkFjY2VwdCIsInRhcmdldFVybCIsIm10bHNfZW5kcG9pbnRfYWxpYXNlcyIsInVzZXJpbmZvX2VuZHBvaW50IiwiYmVhcmVyIiwidGVzdCIsImVuY3J5cHRpb25TZWNyZXQiLCJsZW4iLCJoYXNoIiwiRXJyb3IiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiY2xpZW50X3NlY3JldCIsImRpZ2VzdCIsIlJlZ0V4cCIsIiQxIiwiJDIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImZvcm0iLCJyZXNwb25zZUJvZHkiLCJkZXZpY2VBdXRob3JpemF0aW9uIiwiZW5kcG9pbnRBdXRoTWV0aG9kIiwicmV2b2tlIiwiaGludCIsInJldm9rZUJvZHkiLCJ0b2tlbl90eXBlX2hpbnQiLCJpbnRyb3NwZWN0IiwiaW50cm9zcGVjdEJvZHkiLCJyZWdpc3RlciIsImluaXRpYWxBY2Nlc3NUb2tlbiIsImNsaWVudE9wdGlvbnMiLCJqd2tzX3VyaSIsInRvSldLUyIsImpzb24iLCJyZWdpc3RyYXRpb25fZW5kcG9pbnQiLCJzdGF0dXNDb2RlIiwiZnJvbUVudHJpZXMiLCJmcm9tVXJpIiwicmVnaXN0cmF0aW9uQ2xpZW50VXJpIiwicmVnaXN0cmF0aW9uQWNjZXNzVG9rZW4iLCJyZXF1ZXN0T2JqZWN0Iiwic2lnbiIsInNpZ25pbmdBbGdvcml0aG0iLCJyZXF1ZXN0X29iamVjdF9zaWduaW5nX2FsZyIsImVuY3J5cHQiLCJlS2V5TWFuYWdlbWVudCIsInJlcXVlc3Rfb2JqZWN0X2VuY3J5cHRpb25fYWxnIiwiZUNvbnRlbnRFbmNyeXB0aW9uIiwicmVxdWVzdF9vYmplY3RfZW5jcnlwdGlvbl9lbmMiLCJzaWduZWQiLCJ1bml4IiwidHlwIiwianRpIiwic3ltbWV0cmljIiwiQ29tcGFjdFNpZ24iLCJzZXRQcm90ZWN0ZWRIZWFkZXIiLCJraWQiLCJmaWVsZHMiLCJjdHkiLCJhbGxvd011bHRpIiwiQ29tcGFjdEVuY3J5cHQiLCJwdXNoZWRBdXRob3JpemF0aW9uUmVxdWVzdCIsImV4cGlyZXNfaW4iLCJyZXF1ZXN0X3VyaSIsImN1c3RvbSIsImRlcHRoIiwiSW5maW5pdHkiLCJjb2xvcnMiLCJzdGRvdXQiLCJpc1RUWSIsImNvbXBhY3QiLCJzb3J0ZWQiLCJkcG9wUHJvb2YiLCJwcml2YXRlS2V5SW5wdXQiLCJwcml2YXRlS2V5IiwidG9TdHJpbmdUYWciLCJjcnlwdG9SdW50aW1lIiwiY3JlYXRlUHJpdmF0ZUtleSIsImRldGVybWluZURQb1BBbGdvcml0aG0iLCJTaWduSldUIiwiYXRoIiwiZ2V0SndrIiwic2V0SXNzdWVkQXQiLCJzZXRKdGkiLCJkZXRlcm1pbmVEUG9QQWxnb3JpdGhtRnJvbUNyeXB0b0tleSIsImNyeXB0b0tleSIsImFsZ29yaXRobSIsIm5hbWVkQ3VydmUiLCJhc3ltbWV0cmljS2V5VHlwZSIsImRldGVybWluZUVjQWxnb3JpdGhtIiwiZGV0ZXJtaW5lUnNhQWxnb3JpdGhtIiwiZHBvcF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwiUlNQUyIsInZhbHVlc1N1cHBvcnRlZCIsImNhbmRpZGF0ZXMiLCJmaWx0ZXIiLCJwcm90b3R5cGUiLCJmaW5kIiwicHJlZmVycmVkIiwicDI1NiIsImZyb20iLCJwMzg0IiwicDUyMSIsInNlY3AyNTZrMSIsImJ1ZiIsImV4cG9ydCIsImkiLCJjdXJ2ZU9pZCIsImVxdWFscyIsImp3a0NhY2hlIiwiV2Vha01hcCIsImhhcyIsImV4cG9ydEpXSyIsIm1vZHVsZSIsImV4cG9ydHMiLCJDbGllbnQiLCJhcmdzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/client.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/device_flow_handle.js":
/*!***************************************************************!*\
  !*** ../node_modules/openid-client/lib/device_flow_handle.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { inspect } = __webpack_require__(/*! util */ \"util\");\n\nconst { RPError, OPError } = __webpack_require__(/*! ./errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js\");\n\nclass DeviceFlowHandle {\n  #aborted;\n  #client;\n  #clientAssertionPayload;\n  #DPoP;\n  #exchangeBody;\n  #expires_at;\n  #interval;\n  #maxAge;\n  #response;\n  constructor({ client, exchangeBody, clientAssertionPayload, response, maxAge, DPoP }) {\n    ['verification_uri', 'user_code', 'device_code'].forEach((prop) => {\n      if (typeof response[prop] !== 'string' || !response[prop]) {\n        throw new RPError(\n          `expected ${prop} string to be returned by Device Authorization Response, got %j`,\n          response[prop],\n        );\n      }\n    });\n\n    if (!Number.isSafeInteger(response.expires_in)) {\n      throw new RPError(\n        'expected expires_in number to be returned by Device Authorization Response, got %j',\n        response.expires_in,\n      );\n    }\n\n    this.#expires_at = now() + response.expires_in;\n    this.#client = client;\n    this.#DPoP = DPoP;\n    this.#maxAge = maxAge;\n    this.#exchangeBody = exchangeBody;\n    this.#clientAssertionPayload = clientAssertionPayload;\n    this.#response = response;\n    this.#interval = response.interval * 1000 || 5000;\n  }\n\n  abort() {\n    this.#aborted = true;\n  }\n\n  async poll({ signal } = {}) {\n    if ((signal && signal.aborted) || this.#aborted) {\n      throw new RPError('polling aborted');\n    }\n\n    if (this.expired()) {\n      throw new RPError(\n        'the device code %j has expired and the device authorization session has concluded',\n        this.device_code,\n      );\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, this.#interval));\n\n    let tokenset;\n    try {\n      tokenset = await this.#client.grant(\n        {\n          ...this.#exchangeBody,\n          grant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n          device_code: this.device_code,\n        },\n        { clientAssertionPayload: this.#clientAssertionPayload, DPoP: this.#DPoP },\n      );\n    } catch (err) {\n      switch (err instanceof OPError && err.error) {\n        case 'slow_down':\n          this.#interval += 5000;\n        case 'authorization_pending':\n          return this.poll({ signal });\n        default:\n          throw err;\n      }\n    }\n\n    if ('id_token' in tokenset) {\n      await this.#client.decryptIdToken(tokenset);\n      await this.#client.validateIdToken(tokenset, undefined, 'token', this.#maxAge);\n    }\n\n    return tokenset;\n  }\n\n  get device_code() {\n    return this.#response.device_code;\n  }\n\n  get user_code() {\n    return this.#response.user_code;\n  }\n\n  get verification_uri() {\n    return this.#response.verification_uri;\n  }\n\n  get verification_uri_complete() {\n    return this.#response.verification_uri_complete;\n  }\n\n  get expires_in() {\n    return Math.max.apply(null, [this.#expires_at - now(), 0]);\n  }\n\n  expired() {\n    return this.expires_in === 0;\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.#response, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true,\n    })}`;\n  }\n}\n\nmodule.exports = DeviceFlowHandle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2RldmljZV9mbG93X2hhbmRsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLGtCQUFNOztBQUVsQyxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsbUVBQVU7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLG1HQUEwQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0VBQXNFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTLElBQUk7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxVQUFVLHdFQUF3RTtBQUNsRjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsdUJBQXVCLEVBQUU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvamFtYWx3YXJkL2F4aXMucG9pbnQvbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2RldmljZV9mbG93X2hhbmRsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGluc3BlY3QgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgeyBSUEVycm9yLCBPUEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3Qgbm93ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3VuaXhfdGltZXN0YW1wJyk7XG5cbmNsYXNzIERldmljZUZsb3dIYW5kbGUge1xuICAjYWJvcnRlZDtcbiAgI2NsaWVudDtcbiAgI2NsaWVudEFzc2VydGlvblBheWxvYWQ7XG4gICNEUG9QO1xuICAjZXhjaGFuZ2VCb2R5O1xuICAjZXhwaXJlc19hdDtcbiAgI2ludGVydmFsO1xuICAjbWF4QWdlO1xuICAjcmVzcG9uc2U7XG4gIGNvbnN0cnVjdG9yKHsgY2xpZW50LCBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIHJlc3BvbnNlLCBtYXhBZ2UsIERQb1AgfSkge1xuICAgIFsndmVyaWZpY2F0aW9uX3VyaScsICd1c2VyX2NvZGUnLCAnZGV2aWNlX2NvZGUnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlc3BvbnNlW3Byb3BdICE9PSAnc3RyaW5nJyB8fCAhcmVzcG9uc2VbcHJvcF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoXG4gICAgICAgICAgYGV4cGVjdGVkICR7cHJvcH0gc3RyaW5nIHRvIGJlIHJldHVybmVkIGJ5IERldmljZSBBdXRob3JpemF0aW9uIFJlc3BvbnNlLCBnb3QgJWpgLFxuICAgICAgICAgIHJlc3BvbnNlW3Byb3BdLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyZXNwb25zZS5leHBpcmVzX2luKSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoXG4gICAgICAgICdleHBlY3RlZCBleHBpcmVzX2luIG51bWJlciB0byBiZSByZXR1cm5lZCBieSBEZXZpY2UgQXV0aG9yaXphdGlvbiBSZXNwb25zZSwgZ290ICVqJyxcbiAgICAgICAgcmVzcG9uc2UuZXhwaXJlc19pbixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy4jZXhwaXJlc19hdCA9IG5vdygpICsgcmVzcG9uc2UuZXhwaXJlc19pbjtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy4jRFBvUCA9IERQb1A7XG4gICAgdGhpcy4jbWF4QWdlID0gbWF4QWdlO1xuICAgIHRoaXMuI2V4Y2hhbmdlQm9keSA9IGV4Y2hhbmdlQm9keTtcbiAgICB0aGlzLiNjbGllbnRBc3NlcnRpb25QYXlsb2FkID0gY2xpZW50QXNzZXJ0aW9uUGF5bG9hZDtcbiAgICB0aGlzLiNyZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuI2ludGVydmFsID0gcmVzcG9uc2UuaW50ZXJ2YWwgKiAxMDAwIHx8IDUwMDA7XG4gIH1cblxuICBhYm9ydCgpIHtcbiAgICB0aGlzLiNhYm9ydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIHBvbGwoeyBzaWduYWwgfSA9IHt9KSB7XG4gICAgaWYgKChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHx8IHRoaXMuI2Fib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKCdwb2xsaW5nIGFib3J0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBpcmVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKFxuICAgICAgICAndGhlIGRldmljZSBjb2RlICVqIGhhcyBleHBpcmVkIGFuZCB0aGUgZGV2aWNlIGF1dGhvcml6YXRpb24gc2Vzc2lvbiBoYXMgY29uY2x1ZGVkJyxcbiAgICAgICAgdGhpcy5kZXZpY2VfY29kZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGhpcy4jaW50ZXJ2YWwpKTtcblxuICAgIGxldCB0b2tlbnNldDtcbiAgICB0cnkge1xuICAgICAgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLiNjbGllbnQuZ3JhbnQoXG4gICAgICAgIHtcbiAgICAgICAgICAuLi50aGlzLiNleGNoYW5nZUJvZHksXG4gICAgICAgICAgZ3JhbnRfdHlwZTogJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOmRldmljZV9jb2RlJyxcbiAgICAgICAgICBkZXZpY2VfY29kZTogdGhpcy5kZXZpY2VfY29kZSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkOiB0aGlzLiNjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QOiB0aGlzLiNEUG9QIH0sXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc3dpdGNoIChlcnIgaW5zdGFuY2VvZiBPUEVycm9yICYmIGVyci5lcnJvcikge1xuICAgICAgICBjYXNlICdzbG93X2Rvd24nOlxuICAgICAgICAgIHRoaXMuI2ludGVydmFsICs9IDUwMDA7XG4gICAgICAgIGNhc2UgJ2F1dGhvcml6YXRpb25fcGVuZGluZyc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucG9sbCh7IHNpZ25hbCB9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCdpZF90b2tlbicgaW4gdG9rZW5zZXQpIHtcbiAgICAgIGF3YWl0IHRoaXMuI2NsaWVudC5kZWNyeXB0SWRUb2tlbih0b2tlbnNldCk7XG4gICAgICBhd2FpdCB0aGlzLiNjbGllbnQudmFsaWRhdGVJZFRva2VuKHRva2Vuc2V0LCB1bmRlZmluZWQsICd0b2tlbicsIHRoaXMuI21heEFnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2Vuc2V0O1xuICB9XG5cbiAgZ2V0IGRldmljZV9jb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZXNwb25zZS5kZXZpY2VfY29kZTtcbiAgfVxuXG4gIGdldCB1c2VyX2NvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Jlc3BvbnNlLnVzZXJfY29kZTtcbiAgfVxuXG4gIGdldCB2ZXJpZmljYXRpb25fdXJpKCkge1xuICAgIHJldHVybiB0aGlzLiNyZXNwb25zZS52ZXJpZmljYXRpb25fdXJpO1xuICB9XG5cbiAgZ2V0IHZlcmlmaWNhdGlvbl91cmlfY29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Jlc3BvbnNlLnZlcmlmaWNhdGlvbl91cmlfY29tcGxldGU7XG4gIH1cblxuICBnZXQgZXhwaXJlc19pbigpIHtcbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgW3RoaXMuI2V4cGlyZXNfYXQgLSBub3coKSwgMF0pO1xuICB9XG5cbiAgZXhwaXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHBpcmVzX2luID09PSAwO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgW2luc3BlY3QuY3VzdG9tXSgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAke2luc3BlY3QodGhpcy4jcmVzcG9uc2UsIHtcbiAgICAgIGRlcHRoOiBJbmZpbml0eSxcbiAgICAgIGNvbG9yczogcHJvY2Vzcy5zdGRvdXQuaXNUVFksXG4gICAgICBjb21wYWN0OiBmYWxzZSxcbiAgICAgIHNvcnRlZDogdHJ1ZSxcbiAgICB9KX1gO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGV2aWNlRmxvd0hhbmRsZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/device_flow_handle.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/errors.js":
/*!***************************************************!*\
  !*** ../node_modules/openid-client/lib/errors.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { format } = __webpack_require__(/*! util */ \"util\");\n\nclass OPError extends Error {\n  constructor({ error_description, error, error_uri, session_state, state, scope }, response) {\n    super(!error_description ? error : `${error} (${error_description})`);\n\n    Object.assign(\n      this,\n      { error },\n      error_description && { error_description },\n      error_uri && { error_uri },\n      state && { state },\n      scope && { scope },\n      session_state && { session_state },\n    );\n\n    if (response) {\n      Object.defineProperty(this, 'response', {\n        value: response,\n      });\n    }\n\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nclass RPError extends Error {\n  constructor(...args) {\n    if (typeof args[0] === 'string') {\n      super(format(...args));\n    } else {\n      const { message, printf, response, ...rest } = args[0];\n      if (printf) {\n        super(format(...printf));\n      } else {\n        super(message);\n      }\n      Object.assign(this, rest);\n      if (response) {\n        Object.defineProperty(this, 'response', {\n          value: response,\n        });\n      }\n    }\n\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = {\n  OPError,\n  RPError,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLGtCQUFNOztBQUVqQztBQUNBLGdCQUFnQixrRUFBa0U7QUFDbEYsMENBQTBDLE9BQU8sR0FBRyxrQkFBa0I7O0FBRXRFO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZiw2QkFBNkIsbUJBQW1CO0FBQ2hELHFCQUFxQixXQUFXO0FBQ2hDLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLHlCQUF5QixlQUFlO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLHFDQUFxQztBQUNuRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvamFtYWx3YXJkL2F4aXMucG9pbnQvbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGZvcm1hdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jbGFzcyBPUEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IGVycm9yX2Rlc2NyaXB0aW9uLCBlcnJvciwgZXJyb3JfdXJpLCBzZXNzaW9uX3N0YXRlLCBzdGF0ZSwgc2NvcGUgfSwgcmVzcG9uc2UpIHtcbiAgICBzdXBlcighZXJyb3JfZGVzY3JpcHRpb24gPyBlcnJvciA6IGAke2Vycm9yfSAoJHtlcnJvcl9kZXNjcmlwdGlvbn0pYCk7XG5cbiAgICBPYmplY3QuYXNzaWduKFxuICAgICAgdGhpcyxcbiAgICAgIHsgZXJyb3IgfSxcbiAgICAgIGVycm9yX2Rlc2NyaXB0aW9uICYmIHsgZXJyb3JfZGVzY3JpcHRpb24gfSxcbiAgICAgIGVycm9yX3VyaSAmJiB7IGVycm9yX3VyaSB9LFxuICAgICAgc3RhdGUgJiYgeyBzdGF0ZSB9LFxuICAgICAgc2NvcGUgJiYgeyBzY29wZSB9LFxuICAgICAgc2Vzc2lvbl9zdGF0ZSAmJiB7IHNlc3Npb25fc3RhdGUgfSxcbiAgICApO1xuXG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Jlc3BvbnNlJywge1xuICAgICAgICB2YWx1ZTogcmVzcG9uc2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH1cbn1cblxuY2xhc3MgUlBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHN1cGVyKGZvcm1hdCguLi5hcmdzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZSwgcHJpbnRmLCByZXNwb25zZSwgLi4ucmVzdCB9ID0gYXJnc1swXTtcbiAgICAgIGlmIChwcmludGYpIHtcbiAgICAgICAgc3VwZXIoZm9ybWF0KC4uLnByaW50ZikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3QpO1xuICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVzcG9uc2UnLCB7XG4gICAgICAgICAgdmFsdWU6IHJlc3BvbnNlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE9QRXJyb3IsXG4gIFJQRXJyb3IsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/assert.js":
/*!***********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/assert.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("function assertSigningAlgValuesSupport(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n  const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`;\n\n  if (properties[eam] && properties[eam].endsWith('_jwt') && !properties[easa] && !issuer[easavs]) {\n    throw new TypeError(\n      `${easavs} must be configured on the issuer if ${easa} is not defined on a client`,\n    );\n  }\n}\n\nfunction assertIssuerConfiguration(issuer, endpoint) {\n  if (!issuer[endpoint]) {\n    throw new TypeError(`${endpoint} must be configured on the issuer`);\n  }\n}\n\nmodule.exports = {\n  assertSigningAlgValuesSupport,\n  assertIssuerConfiguration,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsaUJBQWlCLFNBQVM7O0FBRTFCLGlCQUFpQixTQUFTO0FBQzFCLGtCQUFrQixTQUFTO0FBQzNCLG9CQUFvQixTQUFTOztBQUU3QjtBQUNBO0FBQ0EsU0FBUyxRQUFRLHNDQUFzQyxNQUFNO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phbWFsd2FyZC9heGlzLnBvaW50L25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2Fzc2VydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydChlbmRwb2ludCwgaXNzdWVyLCBwcm9wZXJ0aWVzKSB7XG4gIGlmICghaXNzdWVyW2Ake2VuZHBvaW50fV9lbmRwb2ludGBdKSByZXR1cm47XG5cbiAgY29uc3QgZWFtID0gYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfbWV0aG9kYDtcbiAgY29uc3QgZWFzYSA9IGAke2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnYDtcbiAgY29uc3QgZWFzYXZzID0gYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZGA7XG5cbiAgaWYgKHByb3BlcnRpZXNbZWFtXSAmJiBwcm9wZXJ0aWVzW2VhbV0uZW5kc1dpdGgoJ19qd3QnKSAmJiAhcHJvcGVydGllc1tlYXNhXSAmJiAhaXNzdWVyW2Vhc2F2c10pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYCR7ZWFzYXZzfSBtdXN0IGJlIGNvbmZpZ3VyZWQgb24gdGhlIGlzc3VlciBpZiAke2Vhc2F9IGlzIG5vdCBkZWZpbmVkIG9uIGEgY2xpZW50YCxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24oaXNzdWVyLCBlbmRwb2ludCkge1xuICBpZiAoIWlzc3VlcltlbmRwb2ludF0pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2VuZHBvaW50fSBtdXN0IGJlIGNvbmZpZ3VyZWQgb24gdGhlIGlzc3VlcmApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydCxcbiAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbixcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/assert.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/base64url.js":
/*!**************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/base64url.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("let encode;\nif (Buffer.isEncoding('base64url')) {\n  encode = (input, encoding = 'utf8') => Buffer.from(input, encoding).toString('base64url');\n} else {\n  const fromBase64 = (base64) => base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n  encode = (input, encoding = 'utf8') =>\n    fromBase64(Buffer.from(input, encoding).toString('base64'));\n}\n\nconst decode = (input) => Buffer.from(input, 'base64');\n\nmodule.exports.decode = decode;\nmodule.exports.encode = encode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvYmFzZTY0dXJsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvamFtYWx3YXJkL2F4aXMucG9pbnQvbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvYmFzZTY0dXJsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBlbmNvZGU7XG5pZiAoQnVmZmVyLmlzRW5jb2RpbmcoJ2Jhc2U2NHVybCcpKSB7XG4gIGVuY29kZSA9IChpbnB1dCwgZW5jb2RpbmcgPSAndXRmOCcpID0+IEJ1ZmZlci5mcm9tKGlucHV0LCBlbmNvZGluZykudG9TdHJpbmcoJ2Jhc2U2NHVybCcpO1xufSBlbHNlIHtcbiAgY29uc3QgZnJvbUJhc2U2NCA9IChiYXNlNjQpID0+IGJhc2U2NC5yZXBsYWNlKC89L2csICcnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcbiAgZW5jb2RlID0gKGlucHV0LCBlbmNvZGluZyA9ICd1dGY4JykgPT5cbiAgICBmcm9tQmFzZTY0KEJ1ZmZlci5mcm9tKGlucHV0LCBlbmNvZGluZykudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbn1cblxuY29uc3QgZGVjb2RlID0gKGlucHV0KSA9PiBCdWZmZXIuZnJvbShpbnB1dCwgJ2Jhc2U2NCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/base64url.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/client.js":
/*!***********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/client.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const jose = __webpack_require__(/*! jose */ \"(rsc)/../node_modules/jose/dist/node/cjs/index.js\");\n\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\n\nconst { assertIssuerConfiguration } = __webpack_require__(/*! ./assert */ \"(rsc)/../node_modules/openid-client/lib/helpers/assert.js\");\nconst { random } = __webpack_require__(/*! ./generators */ \"(rsc)/../node_modules/openid-client/lib/helpers/generators.js\");\nconst now = __webpack_require__(/*! ./unix_timestamp */ \"(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nconst request = __webpack_require__(/*! ./request */ \"(rsc)/../node_modules/openid-client/lib/helpers/request.js\");\nconst { keystores } = __webpack_require__(/*! ./weak_cache */ \"(rsc)/../node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst merge = __webpack_require__(/*! ./merge */ \"(rsc)/../node_modules/openid-client/lib/helpers/merge.js\");\n\n// TODO: in v6.x additionally encode the `- _ . ! ~ * ' ( )` characters\n// https://github.com/panva/node-openid-client/commit/5a2ea80ef5e59ec0c03dbd97d82f551e24a9d348\nconst formUrlEncode = (value) => encodeURIComponent(value).replace(/%20/g, '+');\n\nasync function clientAssertion(endpoint, payload) {\n  let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n  if (!alg) {\n    assertIssuerConfiguration(\n      this.issuer,\n      `${endpoint}_endpoint_auth_signing_alg_values_supported`,\n    );\n  }\n\n  if (this[`${endpoint}_endpoint_auth_method`] === 'client_secret_jwt') {\n    if (!alg) {\n      const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n      alg =\n        Array.isArray(supported) && supported.find((signAlg) => /^HS(?:256|384|512)/.test(signAlg));\n    }\n\n    if (!alg) {\n      throw new RPError(\n        `failed to determine a JWS Algorithm to use for ${\n          this[`${endpoint}_endpoint_auth_method`]\n        } Client Assertion`,\n      );\n    }\n\n    return new jose.CompactSign(Buffer.from(JSON.stringify(payload)))\n      .setProtectedHeader({ alg })\n      .sign(this.secretForAlg(alg));\n  }\n\n  const keystore = await keystores.get(this);\n\n  if (!keystore) {\n    throw new TypeError('no client jwks provided for signing a client assertion with');\n  }\n\n  if (!alg) {\n    const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n    alg =\n      Array.isArray(supported) &&\n      supported.find((signAlg) => keystore.get({ alg: signAlg, use: 'sig' }));\n  }\n\n  if (!alg) {\n    throw new RPError(\n      `failed to determine a JWS Algorithm to use for ${\n        this[`${endpoint}_endpoint_auth_method`]\n      } Client Assertion`,\n    );\n  }\n\n  const key = keystore.get({ alg, use: 'sig' });\n  if (!key) {\n    throw new RPError(\n      `no key found in client jwks to sign a client assertion with using alg ${alg}`,\n    );\n  }\n\n  return new jose.CompactSign(Buffer.from(JSON.stringify(payload)))\n    .setProtectedHeader({ alg, kid: key.jwk && key.jwk.kid })\n    .sign(await key.keyObject(alg));\n}\n\nasync function authFor(endpoint, { clientAssertionPayload } = {}) {\n  const authMethod = this[`${endpoint}_endpoint_auth_method`];\n  switch (authMethod) {\n    case 'self_signed_tls_client_auth':\n    case 'tls_client_auth':\n    case 'none':\n      return { form: { client_id: this.client_id } };\n    case 'client_secret_post':\n      if (typeof this.client_secret !== 'string') {\n        throw new TypeError(\n          'client_secret_post client authentication method requires a client_secret',\n        );\n      }\n      return { form: { client_id: this.client_id, client_secret: this.client_secret } };\n    case 'private_key_jwt':\n    case 'client_secret_jwt': {\n      const timestamp = now();\n\n      const assertion = await clientAssertion.call(this, endpoint, {\n        iat: timestamp,\n        exp: timestamp + 60,\n        jti: random(),\n        iss: this.client_id,\n        sub: this.client_id,\n        aud: this.issuer.issuer,\n        ...clientAssertionPayload,\n      });\n\n      return {\n        form: {\n          client_id: this.client_id,\n          client_assertion: assertion,\n          client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',\n        },\n      };\n    }\n    case 'client_secret_basic': {\n      // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n      // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n      // > The client identifier is encoded using the\n      // > \"application/x-www-form-urlencoded\" encoding algorithm per\n      // > Appendix B, and the encoded value is used as the username; the client\n      // > password is encoded using the same algorithm and used as the\n      // > password.\n      if (typeof this.client_secret !== 'string') {\n        throw new TypeError(\n          'client_secret_basic client authentication method requires a client_secret',\n        );\n      }\n      const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n      const value = Buffer.from(encoded).toString('base64');\n      return { headers: { Authorization: `Basic ${value}` } };\n    }\n    default: {\n      throw new TypeError(`missing, or unsupported, ${endpoint}_endpoint_auth_method`);\n    }\n  }\n}\n\nfunction resolveResponseType() {\n  const { length, 0: value } = this.response_types;\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nfunction resolveRedirectUri() {\n  const { length, 0: value } = this.redirect_uris || [];\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nasync function authenticatedPost(\n  endpoint,\n  opts,\n  { clientAssertionPayload, endpointAuthMethod = endpoint, DPoP } = {},\n) {\n  const auth = await authFor.call(this, endpointAuthMethod, { clientAssertionPayload });\n  const requestOpts = merge(opts, auth);\n\n  const mTLS =\n    this[`${endpointAuthMethod}_endpoint_auth_method`].includes('tls_client_auth') ||\n    (endpoint === 'token' && this.tls_client_certificate_bound_access_tokens);\n\n  let targetUrl;\n  if (mTLS && this.issuer.mtls_endpoint_aliases) {\n    targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];\n  }\n\n  targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];\n\n  if ('form' in requestOpts) {\n    for (const [key, value] of Object.entries(requestOpts.form)) {\n      if (typeof value === 'undefined') {\n        delete requestOpts.form[key];\n      }\n    }\n  }\n\n  return request.call(\n    this,\n    {\n      ...requestOpts,\n      method: 'POST',\n      url: targetUrl,\n      headers: {\n        ...(endpoint !== 'revocation'\n          ? {\n              Accept: 'application/json',\n            }\n          : undefined),\n        ...requestOpts.headers,\n      },\n    },\n    { mTLS, DPoP },\n  );\n}\n\nmodule.exports = {\n  resolveResponseType,\n  resolveRedirectUri,\n  authFor,\n  authenticatedPost,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQywrREFBTTs7QUFFM0IsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyxvRUFBVzs7QUFFdkMsUUFBUSw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFVO0FBQ3hELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsbUZBQWM7QUFDekMsWUFBWSxtQkFBTyxDQUFDLDJGQUFrQjtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBVztBQUNuQyxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLG1GQUFjO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyx5RUFBUzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0EsaURBQWlELDBCQUEwQjtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixRQUFRO0FBQ1I7QUFDQTs7QUFFQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSwrRUFBK0UsSUFBSTtBQUNuRjtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBOztBQUVBLG1DQUFtQyx5QkFBeUIsSUFBSTtBQUNoRSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCLEdBQUcsa0NBQWtDO0FBQzVGO0FBQ0EsZUFBZSxXQUFXLHdCQUF3QixNQUFNO0FBQ3hEO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG1CQUFtQjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG1CQUFtQjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4REFBOEQsSUFBSTtBQUN0RTtBQUNBLDhEQUE4RCx3QkFBd0I7QUFDdEY7O0FBRUE7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7O0FBRUEsMENBQTBDLFNBQVM7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxNQUFNLFlBQVk7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYW1hbHdhcmQvYXhpcy5wb2ludC9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgam9zZSA9IHJlcXVpcmUoJ2pvc2UnKTtcblxuY29uc3QgeyBSUEVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxuY29uc3QgeyBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIH0gPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuY29uc3QgeyByYW5kb20gfSA9IHJlcXVpcmUoJy4vZ2VuZXJhdG9ycycpO1xuY29uc3Qgbm93ID0gcmVxdWlyZSgnLi91bml4X3RpbWVzdGFtcCcpO1xuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpO1xuY29uc3QgeyBrZXlzdG9yZXMgfSA9IHJlcXVpcmUoJy4vd2Vha19jYWNoZScpO1xuY29uc3QgbWVyZ2UgPSByZXF1aXJlKCcuL21lcmdlJyk7XG5cbi8vIFRPRE86IGluIHY2LnggYWRkaXRpb25hbGx5IGVuY29kZSB0aGUgYC0gXyAuICEgfiAqICcgKCApYCBjaGFyYWN0ZXJzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGFudmEvbm9kZS1vcGVuaWQtY2xpZW50L2NvbW1pdC81YTJlYTgwZWY1ZTU5ZWMwYzAzZGJkOTdkODJmNTUxZTI0YTlkMzQ4XG5jb25zdCBmb3JtVXJsRW5jb2RlID0gKHZhbHVlKSA9PiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xuXG5hc3luYyBmdW5jdGlvbiBjbGllbnRBc3NlcnRpb24oZW5kcG9pbnQsIHBheWxvYWQpIHtcbiAgbGV0IGFsZyA9IHRoaXNbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdgXTtcbiAgaWYgKCFhbGcpIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKFxuICAgICAgdGhpcy5pc3N1ZXIsXG4gICAgICBgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkYCxcbiAgICApO1xuICB9XG5cbiAgaWYgKHRoaXNbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfbWV0aG9kYF0gPT09ICdjbGllbnRfc2VjcmV0X2p3dCcpIHtcbiAgICBpZiAoIWFsZykge1xuICAgICAgY29uc3Qgc3VwcG9ydGVkID0gdGhpcy5pc3N1ZXJbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZGBdO1xuICAgICAgYWxnID1cbiAgICAgICAgQXJyYXkuaXNBcnJheShzdXBwb3J0ZWQpICYmIHN1cHBvcnRlZC5maW5kKChzaWduQWxnKSA9PiAvXkhTKD86MjU2fDM4NHw1MTIpLy50ZXN0KHNpZ25BbGcpKTtcbiAgICB9XG5cbiAgICBpZiAoIWFsZykge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoXG4gICAgICAgIGBmYWlsZWQgdG8gZGV0ZXJtaW5lIGEgSldTIEFsZ29yaXRobSB0byB1c2UgZm9yICR7XG4gICAgICAgICAgdGhpc1tgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgXVxuICAgICAgICB9IENsaWVudCBBc3NlcnRpb25gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IGpvc2UuQ29tcGFjdFNpZ24oQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpKVxuICAgICAgLnNldFByb3RlY3RlZEhlYWRlcih7IGFsZyB9KVxuICAgICAgLnNpZ24odGhpcy5zZWNyZXRGb3JBbGcoYWxnKSk7XG4gIH1cblxuICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGtleXN0b3Jlcy5nZXQodGhpcyk7XG5cbiAgaWYgKCFrZXlzdG9yZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGNsaWVudCBqd2tzIHByb3ZpZGVkIGZvciBzaWduaW5nIGEgY2xpZW50IGFzc2VydGlvbiB3aXRoJyk7XG4gIH1cblxuICBpZiAoIWFsZykge1xuICAgIGNvbnN0IHN1cHBvcnRlZCA9IHRoaXMuaXNzdWVyW2Ake2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWRgXTtcbiAgICBhbGcgPVxuICAgICAgQXJyYXkuaXNBcnJheShzdXBwb3J0ZWQpICYmXG4gICAgICBzdXBwb3J0ZWQuZmluZCgoc2lnbkFsZykgPT4ga2V5c3RvcmUuZ2V0KHsgYWxnOiBzaWduQWxnLCB1c2U6ICdzaWcnIH0pKTtcbiAgfVxuXG4gIGlmICghYWxnKSB7XG4gICAgdGhyb3cgbmV3IFJQRXJyb3IoXG4gICAgICBgZmFpbGVkIHRvIGRldGVybWluZSBhIEpXUyBBbGdvcml0aG0gdG8gdXNlIGZvciAke1xuICAgICAgICB0aGlzW2Ake2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX21ldGhvZGBdXG4gICAgICB9IENsaWVudCBBc3NlcnRpb25gLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBrZXkgPSBrZXlzdG9yZS5nZXQoeyBhbGcsIHVzZTogJ3NpZycgfSk7XG4gIGlmICgha2V5KSB7XG4gICAgdGhyb3cgbmV3IFJQRXJyb3IoXG4gICAgICBgbm8ga2V5IGZvdW5kIGluIGNsaWVudCBqd2tzIHRvIHNpZ24gYSBjbGllbnQgYXNzZXJ0aW9uIHdpdGggdXNpbmcgYWxnICR7YWxnfWAsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgam9zZS5Db21wYWN0U2lnbihCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpXG4gICAgLnNldFByb3RlY3RlZEhlYWRlcih7IGFsZywga2lkOiBrZXkuandrICYmIGtleS5qd2sua2lkIH0pXG4gICAgLnNpZ24oYXdhaXQga2V5LmtleU9iamVjdChhbGcpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXV0aEZvcihlbmRwb2ludCwgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkIH0gPSB7fSkge1xuICBjb25zdCBhdXRoTWV0aG9kID0gdGhpc1tgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgXTtcbiAgc3dpdGNoIChhdXRoTWV0aG9kKSB7XG4gICAgY2FzZSAnc2VsZl9zaWduZWRfdGxzX2NsaWVudF9hdXRoJzpcbiAgICBjYXNlICd0bHNfY2xpZW50X2F1dGgnOlxuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgcmV0dXJuIHsgZm9ybTogeyBjbGllbnRfaWQ6IHRoaXMuY2xpZW50X2lkIH0gfTtcbiAgICBjYXNlICdjbGllbnRfc2VjcmV0X3Bvc3QnOlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNsaWVudF9zZWNyZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ2NsaWVudF9zZWNyZXRfcG9zdCBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kIHJlcXVpcmVzIGEgY2xpZW50X3NlY3JldCcsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBmb3JtOiB7IGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsIGNsaWVudF9zZWNyZXQ6IHRoaXMuY2xpZW50X3NlY3JldCB9IH07XG4gICAgY2FzZSAncHJpdmF0ZV9rZXlfand0JzpcbiAgICBjYXNlICdjbGllbnRfc2VjcmV0X2p3dCc6IHtcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5vdygpO1xuXG4gICAgICBjb25zdCBhc3NlcnRpb24gPSBhd2FpdCBjbGllbnRBc3NlcnRpb24uY2FsbCh0aGlzLCBlbmRwb2ludCwge1xuICAgICAgICBpYXQ6IHRpbWVzdGFtcCxcbiAgICAgICAgZXhwOiB0aW1lc3RhbXAgKyA2MCxcbiAgICAgICAganRpOiByYW5kb20oKSxcbiAgICAgICAgaXNzOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgICAgc3ViOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgICAgYXVkOiB0aGlzLmlzc3Vlci5pc3N1ZXIsXG4gICAgICAgIC4uLmNsaWVudEFzc2VydGlvblBheWxvYWQsXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybToge1xuICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXG4gICAgICAgICAgY2xpZW50X2Fzc2VydGlvbjogYXNzZXJ0aW9uLFxuICAgICAgICAgIGNsaWVudF9hc3NlcnRpb25fdHlwZTogJ3VybjppZXRmOnBhcmFtczpvYXV0aDpjbGllbnQtYXNzZXJ0aW9uLXR5cGU6and0LWJlYXJlcicsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlICdjbGllbnRfc2VjcmV0X2Jhc2ljJzoge1xuICAgICAgLy8gVGhpcyBpcyBjb3JyZWN0IGJlaGF2aW91ciwgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NzQ5I3NlY3Rpb24tMi4zLjEgYW5kIHRoZVxuICAgICAgLy8gcmVsYXRlZCBhcHBlbmRpeC4gKGFsc28gaHR0cHM6Ly9naXRodWIuY29tL3BhbnZhL25vZGUtb3BlbmlkLWNsaWVudC9wdWxsLzkxKVxuICAgICAgLy8gPiBUaGUgY2xpZW50IGlkZW50aWZpZXIgaXMgZW5jb2RlZCB1c2luZyB0aGVcbiAgICAgIC8vID4gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiBlbmNvZGluZyBhbGdvcml0aG0gcGVyXG4gICAgICAvLyA+IEFwcGVuZGl4IEIsIGFuZCB0aGUgZW5jb2RlZCB2YWx1ZSBpcyB1c2VkIGFzIHRoZSB1c2VybmFtZTsgdGhlIGNsaWVudFxuICAgICAgLy8gPiBwYXNzd29yZCBpcyBlbmNvZGVkIHVzaW5nIHRoZSBzYW1lIGFsZ29yaXRobSBhbmQgdXNlZCBhcyB0aGVcbiAgICAgIC8vID4gcGFzc3dvcmQuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuY2xpZW50X3NlY3JldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnY2xpZW50X3NlY3JldF9iYXNpYyBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kIHJlcXVpcmVzIGEgY2xpZW50X3NlY3JldCcsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBlbmNvZGVkID0gYCR7Zm9ybVVybEVuY29kZSh0aGlzLmNsaWVudF9pZCl9OiR7Zm9ybVVybEVuY29kZSh0aGlzLmNsaWVudF9zZWNyZXQpfWA7XG4gICAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5mcm9tKGVuY29kZWQpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIHJldHVybiB7IGhlYWRlcnM6IHsgQXV0aG9yaXphdGlvbjogYEJhc2ljICR7dmFsdWV9YCB9IH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG1pc3NpbmcsIG9yIHVuc3VwcG9ydGVkLCAke2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX21ldGhvZGApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVzcG9uc2VUeXBlKCkge1xuICBjb25zdCB7IGxlbmd0aCwgMDogdmFsdWUgfSA9IHRoaXMucmVzcG9uc2VfdHlwZXM7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZWRpcmVjdFVyaSgpIHtcbiAgY29uc3QgeyBsZW5ndGgsIDA6IHZhbHVlIH0gPSB0aGlzLnJlZGlyZWN0X3VyaXMgfHwgW107XG5cbiAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZWRQb3N0KFxuICBlbmRwb2ludCxcbiAgb3B0cyxcbiAgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBlbmRwb2ludEF1dGhNZXRob2QgPSBlbmRwb2ludCwgRFBvUCB9ID0ge30sXG4pIHtcbiAgY29uc3QgYXV0aCA9IGF3YWl0IGF1dGhGb3IuY2FsbCh0aGlzLCBlbmRwb2ludEF1dGhNZXRob2QsIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCB9KTtcbiAgY29uc3QgcmVxdWVzdE9wdHMgPSBtZXJnZShvcHRzLCBhdXRoKTtcblxuICBjb25zdCBtVExTID1cbiAgICB0aGlzW2Ake2VuZHBvaW50QXV0aE1ldGhvZH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgXS5pbmNsdWRlcygndGxzX2NsaWVudF9hdXRoJykgfHxcbiAgICAoZW5kcG9pbnQgPT09ICd0b2tlbicgJiYgdGhpcy50bHNfY2xpZW50X2NlcnRpZmljYXRlX2JvdW5kX2FjY2Vzc190b2tlbnMpO1xuXG4gIGxldCB0YXJnZXRVcmw7XG4gIGlmIChtVExTICYmIHRoaXMuaXNzdWVyLm10bHNfZW5kcG9pbnRfYWxpYXNlcykge1xuICAgIHRhcmdldFVybCA9IHRoaXMuaXNzdWVyLm10bHNfZW5kcG9pbnRfYWxpYXNlc1tgJHtlbmRwb2ludH1fZW5kcG9pbnRgXTtcbiAgfVxuXG4gIHRhcmdldFVybCA9IHRhcmdldFVybCB8fCB0aGlzLmlzc3VlcltgJHtlbmRwb2ludH1fZW5kcG9pbnRgXTtcblxuICBpZiAoJ2Zvcm0nIGluIHJlcXVlc3RPcHRzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdE9wdHMuZm9ybSkpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0T3B0cy5mb3JtW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcXVlc3QuY2FsbChcbiAgICB0aGlzLFxuICAgIHtcbiAgICAgIC4uLnJlcXVlc3RPcHRzLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6IHRhcmdldFVybCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uKGVuZHBvaW50ICE9PSAncmV2b2NhdGlvbidcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB1bmRlZmluZWQpLFxuICAgICAgICAuLi5yZXF1ZXN0T3B0cy5oZWFkZXJzLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHsgbVRMUywgRFBvUCB9LFxuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVzb2x2ZVJlc3BvbnNlVHlwZSxcbiAgcmVzb2x2ZVJlZGlyZWN0VXJpLFxuICBhdXRoRm9yLFxuICBhdXRoZW50aWNhdGVkUG9zdCxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/client.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/consts.js":
/*!***********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/consts.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("const HTTP_OPTIONS = Symbol();\nconst CLOCK_TOLERANCE = Symbol();\n\nmodule.exports = {\n  CLOCK_TOLERANCE,\n  HTTP_OPTIONS,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvY29uc3RzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYW1hbHdhcmQvYXhpcy5wb2ludC9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9jb25zdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgSFRUUF9PUFRJT05TID0gU3ltYm9sKCk7XG5jb25zdCBDTE9DS19UT0xFUkFOQ0UgPSBTeW1ib2woKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENMT0NLX1RPTEVSQU5DRSxcbiAgSFRUUF9PUFRJT05TLFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/consts.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/decode_jwt.js":
/*!***************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/decode_jwt.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const base64url = __webpack_require__(/*! ./base64url */ \"(rsc)/../node_modules/openid-client/lib/helpers/base64url.js\");\n\nmodule.exports = (token) => {\n  if (typeof token !== 'string' || !token) {\n    throw new TypeError('JWT must be a string');\n  }\n\n  const { 0: header, 1: payload, 2: signature, length } = token.split('.');\n\n  if (length === 5) {\n    throw new TypeError('encrypted JWTs cannot be decoded');\n  }\n\n  if (length !== 3) {\n    throw new Error('JWTs must have three components');\n  }\n\n  try {\n    return {\n      header: JSON.parse(base64url.decode(header)),\n      payload: JSON.parse(base64url.decode(payload)),\n      signature,\n    };\n  } catch (err) {\n    throw new Error('JWT is malformed');\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZGVjb2RlX2p3dC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBYTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSw4Q0FBOEM7O0FBRXhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phbWFsd2FyZC9heGlzLnBvaW50L25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2RlY29kZV9qd3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmFzZTY0dXJsID0gcmVxdWlyZSgnLi9iYXNlNjR1cmwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAodG9rZW4pID0+IHtcbiAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycgfHwgIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSldUIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGNvbnN0IHsgMDogaGVhZGVyLCAxOiBwYXlsb2FkLCAyOiBzaWduYXR1cmUsIGxlbmd0aCB9ID0gdG9rZW4uc3BsaXQoJy4nKTtcblxuICBpZiAobGVuZ3RoID09PSA1KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jcnlwdGVkIEpXVHMgY2Fubm90IGJlIGRlY29kZWQnKTtcbiAgfVxuXG4gIGlmIChsZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVHMgbXVzdCBoYXZlIHRocmVlIGNvbXBvbmVudHMnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcjogSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKGhlYWRlcikpLFxuICAgICAgcGF5bG9hZDogSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKHBheWxvYWQpKSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBpcyBtYWxmb3JtZWQnKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/decode_jwt.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js":
/*!***************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/deep_clone.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("module.exports = globalThis.structuredClone || ((obj) => JSON.parse(JSON.stringify(obj)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZGVlcF9jbG9uZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phbWFsd2FyZC9heGlzLnBvaW50L25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2RlZXBfY2xvbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxUaGlzLnN0cnVjdHVyZWRDbG9uZSB8fCAoKG9iaikgPT4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/defaults.js":
/*!*************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/defaults.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js\");\n\nfunction defaults(deep, target, ...sources) {\n  for (const source of sources) {\n    if (!isPlainObject(source)) {\n      continue;\n    }\n    for (const [key, value] of Object.entries(source)) {\n      /* istanbul ignore if */\n      if (key === '__proto__' || key === 'constructor') {\n        continue;\n      }\n      if (typeof target[key] === 'undefined' && typeof value !== 'undefined') {\n        target[key] = value;\n      }\n\n      if (deep && isPlainObject(target[key]) && isPlainObject(value)) {\n        defaults(true, target[key], value);\n      }\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = defaults.bind(undefined, false);\nmodule.exports.deep = defaults.bind(undefined, true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0JBQXNCLG1CQUFPLENBQUMsNkZBQW1COztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYW1hbHdhcmQvYXhpcy5wb2ludC9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9kZWZhdWx0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc19wbGFpbl9vYmplY3QnKTtcblxuZnVuY3Rpb24gZGVmYXVsdHMoZGVlcCwgdGFyZ2V0LCAuLi5zb3VyY2VzKSB7XG4gIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVlcCAmJiBpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBkZWZhdWx0cyh0cnVlLCB0YXJnZXRba2V5XSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHMuYmluZCh1bmRlZmluZWQsIGZhbHNlKTtcbm1vZHVsZS5leHBvcnRzLmRlZXAgPSBkZWZhdWx0cy5iaW5kKHVuZGVmaW5lZCwgdHJ1ZSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/defaults.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/generators.js":
/*!***************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/generators.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { createHash, randomBytes } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst base64url = __webpack_require__(/*! ./base64url */ \"(rsc)/../node_modules/openid-client/lib/helpers/base64url.js\");\n\nconst random = (bytes = 32) => base64url.encode(randomBytes(bytes));\n\nmodule.exports = {\n  random,\n  state: random,\n  nonce: random,\n  codeVerifier: random,\n  codeChallenge: (codeVerifier) =>\n    base64url.encode(createHash('sha256').update(codeVerifier).digest()),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZ2VuZXJhdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRXBELGtCQUFrQixtQkFBTyxDQUFDLGlGQUFhOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvamFtYWx3YXJkL2F4aXMucG9pbnQvbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZ2VuZXJhdG9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNyZWF0ZUhhc2gsIHJhbmRvbUJ5dGVzIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgYmFzZTY0dXJsID0gcmVxdWlyZSgnLi9iYXNlNjR1cmwnKTtcblxuY29uc3QgcmFuZG9tID0gKGJ5dGVzID0gMzIpID0+IGJhc2U2NHVybC5lbmNvZGUocmFuZG9tQnl0ZXMoYnl0ZXMpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJhbmRvbSxcbiAgc3RhdGU6IHJhbmRvbSxcbiAgbm9uY2U6IHJhbmRvbSxcbiAgY29kZVZlcmlmaWVyOiByYW5kb20sXG4gIGNvZGVDaGFsbGVuZ2U6IChjb2RlVmVyaWZpZXIpID0+XG4gICAgYmFzZTY0dXJsLmVuY29kZShjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoY29kZVZlcmlmaWVyKS5kaWdlc3QoKSksXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/generators.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/is_key_object.js":
/*!******************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/is_key_object.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! util */ \"util\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nmodule.exports = util.types.isKeyObject || ((obj) => obj && obj instanceof crypto.KeyObject);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvaXNfa2V5X29iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLHNCQUFROztBQUUvQiIsInNvdXJjZXMiOlsiL1VzZXJzL2phbWFsd2FyZC9heGlzLnBvaW50L25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2lzX2tleV9vYmplY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWwudHlwZXMuaXNLZXlPYmplY3QgfHwgKChvYmopID0+IG9iaiAmJiBvYmogaW5zdGFuY2VvZiBjcnlwdG8uS2V5T2JqZWN0KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/is_key_object.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js":
/*!********************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/is_plain_object.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("module.exports = (a) => !!a && a.constructor === Object;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvaXNfcGxhaW5fb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyIvVXNlcnMvamFtYWx3YXJkL2F4aXMucG9pbnQvbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvaXNfcGxhaW5fb2JqZWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gKGEpID0+ICEhYSAmJiBhLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/issuer.js":
/*!***********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/issuer.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const objectHash = __webpack_require__(/*! object-hash */ \"(rsc)/../node_modules/object-hash/index.js\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/../node_modules/lru-cache/index.js\");\n\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\n\nconst { assertIssuerConfiguration } = __webpack_require__(/*! ./assert */ \"(rsc)/../node_modules/openid-client/lib/helpers/assert.js\");\nconst KeyStore = __webpack_require__(/*! ./keystore */ \"(rsc)/../node_modules/openid-client/lib/helpers/keystore.js\");\nconst { keystores } = __webpack_require__(/*! ./weak_cache */ \"(rsc)/../node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst processResponse = __webpack_require__(/*! ./process_response */ \"(rsc)/../node_modules/openid-client/lib/helpers/process_response.js\");\nconst request = __webpack_require__(/*! ./request */ \"(rsc)/../node_modules/openid-client/lib/helpers/request.js\");\n\nconst inFlight = new WeakMap();\nconst caches = new WeakMap();\nconst lrus = (ctx) => {\n  if (!caches.has(ctx)) {\n    caches.set(ctx, new LRU({ max: 100 }));\n  }\n  return caches.get(ctx);\n};\n\nasync function getKeyStore(reload = false) {\n  assertIssuerConfiguration(this, 'jwks_uri');\n\n  const keystore = keystores.get(this);\n  const cache = lrus(this);\n\n  if (reload || !keystore) {\n    if (inFlight.has(this)) {\n      return inFlight.get(this);\n    }\n    cache.reset();\n    inFlight.set(\n      this,\n      (async () => {\n        const response = await request\n          .call(this, {\n            method: 'GET',\n            responseType: 'json',\n            url: this.jwks_uri,\n            headers: {\n              Accept: 'application/json, application/jwk-set+json',\n            },\n          })\n          .finally(() => {\n            inFlight.delete(this);\n          });\n        const jwks = processResponse(response);\n\n        const joseKeyStore = KeyStore.fromJWKS(jwks, { onlyPublic: true });\n        cache.set('throttle', true, 60 * 1000);\n        keystores.set(this, joseKeyStore);\n\n        return joseKeyStore;\n      })(),\n    );\n\n    return inFlight.get(this);\n  }\n\n  return keystore;\n}\n\nasync function queryKeyStore({ kid, kty, alg, use }, { allowMulti = false } = {}) {\n  const cache = lrus(this);\n\n  const def = {\n    kid,\n    kty,\n    alg,\n    use,\n  };\n\n  const defHash = objectHash(def, {\n    algorithm: 'sha256',\n    ignoreUnknown: true,\n    unorderedArrays: true,\n    unorderedSets: true,\n    respectType: false,\n  });\n\n  // refresh keystore on every unknown key but also only upto once every minute\n  const freshJwksUri = cache.get(defHash) || cache.get('throttle');\n\n  const keystore = await getKeyStore.call(this, !freshJwksUri);\n  const keys = keystore.all(def);\n\n  delete def.use;\n  if (keys.length === 0) {\n    throw new RPError({\n      printf: [\"no valid key found in issuer's jwks_uri for key parameters %j\", def],\n      jwks: keystore,\n    });\n  }\n\n  if (!allowMulti && keys.length > 1 && !kid) {\n    throw new RPError({\n      printf: [\n        \"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\",\n        def,\n      ],\n      jwks: keystore,\n    });\n  }\n\n  cache.set(defHash, true);\n\n  return keys;\n}\n\nmodule.exports.queryKeyStore = queryKeyStore;\nmodule.exports.keystore = getKeyStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvaXNzdWVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFhO0FBQ3hDLFlBQVksbUJBQU8sQ0FBQywyREFBVzs7QUFFL0IsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyxvRUFBVzs7QUFFdkMsUUFBUSw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFVO0FBQ3hELGlCQUFpQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3JDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsbUZBQWM7QUFDNUMsd0JBQXdCLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ3BELGdCQUFnQixtQkFBTyxDQUFDLDZFQUFXOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCLG9CQUFvQixJQUFJLHFCQUFxQixJQUFJO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLHVCQUF1QiIsInNvdXJjZXMiOlsiL1VzZXJzL2phbWFsd2FyZC9heGlzLnBvaW50L25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2lzc3Vlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvYmplY3RIYXNoID0gcmVxdWlyZSgnb2JqZWN0LWhhc2gnKTtcbmNvbnN0IExSVSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpO1xuXG5jb25zdCB7IFJQRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG5jb25zdCB7IGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24gfSA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5jb25zdCBLZXlTdG9yZSA9IHJlcXVpcmUoJy4va2V5c3RvcmUnKTtcbmNvbnN0IHsga2V5c3RvcmVzIH0gPSByZXF1aXJlKCcuL3dlYWtfY2FjaGUnKTtcbmNvbnN0IHByb2Nlc3NSZXNwb25zZSA9IHJlcXVpcmUoJy4vcHJvY2Vzc19yZXNwb25zZScpO1xuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpO1xuXG5jb25zdCBpbkZsaWdodCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBjYWNoZXMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgbHJ1cyA9IChjdHgpID0+IHtcbiAgaWYgKCFjYWNoZXMuaGFzKGN0eCkpIHtcbiAgICBjYWNoZXMuc2V0KGN0eCwgbmV3IExSVSh7IG1heDogMTAwIH0pKTtcbiAgfVxuICByZXR1cm4gY2FjaGVzLmdldChjdHgpO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0S2V5U3RvcmUocmVsb2FkID0gZmFsc2UpIHtcbiAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLCAnandrc191cmknKTtcblxuICBjb25zdCBrZXlzdG9yZSA9IGtleXN0b3Jlcy5nZXQodGhpcyk7XG4gIGNvbnN0IGNhY2hlID0gbHJ1cyh0aGlzKTtcblxuICBpZiAocmVsb2FkIHx8ICFrZXlzdG9yZSkge1xuICAgIGlmIChpbkZsaWdodC5oYXModGhpcykpIHtcbiAgICAgIHJldHVybiBpbkZsaWdodC5nZXQodGhpcyk7XG4gICAgfVxuICAgIGNhY2hlLnJlc2V0KCk7XG4gICAgaW5GbGlnaHQuc2V0KFxuICAgICAgdGhpcyxcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFxuICAgICAgICAgIC5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIHVybDogdGhpcy5qd2tzX3VyaSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbiwgYXBwbGljYXRpb24vandrLXNldCtqc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBpbkZsaWdodC5kZWxldGUodGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGp3a3MgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuXG4gICAgICAgIGNvbnN0IGpvc2VLZXlTdG9yZSA9IEtleVN0b3JlLmZyb21KV0tTKGp3a3MsIHsgb25seVB1YmxpYzogdHJ1ZSB9KTtcbiAgICAgICAgY2FjaGUuc2V0KCd0aHJvdHRsZScsIHRydWUsIDYwICogMTAwMCk7XG4gICAgICAgIGtleXN0b3Jlcy5zZXQodGhpcywgam9zZUtleVN0b3JlKTtcblxuICAgICAgICByZXR1cm4gam9zZUtleVN0b3JlO1xuICAgICAgfSkoKSxcbiAgICApO1xuXG4gICAgcmV0dXJuIGluRmxpZ2h0LmdldCh0aGlzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzdG9yZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcXVlcnlLZXlTdG9yZSh7IGtpZCwga3R5LCBhbGcsIHVzZSB9LCB7IGFsbG93TXVsdGkgPSBmYWxzZSB9ID0ge30pIHtcbiAgY29uc3QgY2FjaGUgPSBscnVzKHRoaXMpO1xuXG4gIGNvbnN0IGRlZiA9IHtcbiAgICBraWQsXG4gICAga3R5LFxuICAgIGFsZyxcbiAgICB1c2UsXG4gIH07XG5cbiAgY29uc3QgZGVmSGFzaCA9IG9iamVjdEhhc2goZGVmLCB7XG4gICAgYWxnb3JpdGhtOiAnc2hhMjU2JyxcbiAgICBpZ25vcmVVbmtub3duOiB0cnVlLFxuICAgIHVub3JkZXJlZEFycmF5czogdHJ1ZSxcbiAgICB1bm9yZGVyZWRTZXRzOiB0cnVlLFxuICAgIHJlc3BlY3RUeXBlOiBmYWxzZSxcbiAgfSk7XG5cbiAgLy8gcmVmcmVzaCBrZXlzdG9yZSBvbiBldmVyeSB1bmtub3duIGtleSBidXQgYWxzbyBvbmx5IHVwdG8gb25jZSBldmVyeSBtaW51dGVcbiAgY29uc3QgZnJlc2hKd2tzVXJpID0gY2FjaGUuZ2V0KGRlZkhhc2gpIHx8IGNhY2hlLmdldCgndGhyb3R0bGUnKTtcblxuICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGdldEtleVN0b3JlLmNhbGwodGhpcywgIWZyZXNoSndrc1VyaSk7XG4gIGNvbnN0IGtleXMgPSBrZXlzdG9yZS5hbGwoZGVmKTtcblxuICBkZWxldGUgZGVmLnVzZTtcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgcHJpbnRmOiBbXCJubyB2YWxpZCBrZXkgZm91bmQgaW4gaXNzdWVyJ3Mgandrc191cmkgZm9yIGtleSBwYXJhbWV0ZXJzICVqXCIsIGRlZl0sXG4gICAgICBqd2tzOiBrZXlzdG9yZSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghYWxsb3dNdWx0aSAmJiBrZXlzLmxlbmd0aCA+IDEgJiYgIWtpZCkge1xuICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgIHByaW50ZjogW1xuICAgICAgICBcIm11bHRpcGxlIG1hdGNoaW5nIGtleXMgZm91bmQgaW4gaXNzdWVyJ3Mgandrc191cmkgZm9yIGtleSBwYXJhbWV0ZXJzICVqLCBraWQgbXVzdCBiZSBwcm92aWRlZCBpbiB0aGlzIGNhc2VcIixcbiAgICAgICAgZGVmLFxuICAgICAgXSxcbiAgICAgIGp3a3M6IGtleXN0b3JlLFxuICAgIH0pO1xuICB9XG5cbiAgY2FjaGUuc2V0KGRlZkhhc2gsIHRydWUpO1xuXG4gIHJldHVybiBrZXlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5xdWVyeUtleVN0b3JlID0gcXVlcnlLZXlTdG9yZTtcbm1vZHVsZS5leHBvcnRzLmtleXN0b3JlID0gZ2V0S2V5U3RvcmU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/issuer.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/keystore.js":
/*!*************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/keystore.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const jose = __webpack_require__(/*! jose */ \"(rsc)/../node_modules/jose/dist/node/cjs/index.js\");\n\nconst clone = __webpack_require__(/*! ./deep_clone */ \"(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js\");\n\nconst internal = Symbol();\n\nconst keyscore = (key, { alg, use }) => {\n  let score = 0;\n\n  if (alg && key.alg) {\n    score++;\n  }\n\n  if (use && key.use) {\n    score++;\n  }\n\n  return score;\n};\n\nfunction getKtyFromAlg(alg) {\n  switch (typeof alg === 'string' && alg.slice(0, 2)) {\n    case 'RS':\n    case 'PS':\n      return 'RSA';\n    case 'ES':\n      return 'EC';\n    case 'Ed':\n      return 'OKP';\n    default:\n      return undefined;\n  }\n}\n\nfunction getAlgorithms(use, alg, kty, crv) {\n  // Ed25519, Ed448, and secp256k1 always have \"alg\"\n  // OKP always has \"use\"\n  if (alg) {\n    return new Set([alg]);\n  }\n\n  switch (kty) {\n    case 'EC': {\n      let algs = [];\n\n      if (use === 'enc' || use === undefined) {\n        algs = algs.concat(['ECDH-ES', 'ECDH-ES+A128KW', 'ECDH-ES+A192KW', 'ECDH-ES+A256KW']);\n      }\n\n      if (use === 'sig' || use === undefined) {\n        switch (crv) {\n          case 'P-256':\n          case 'P-384':\n            algs = algs.concat([`ES${crv.slice(-3)}`]);\n            break;\n          case 'P-521':\n            algs = algs.concat(['ES512']);\n            break;\n          case 'secp256k1':\n            if (jose.cryptoRuntime === 'node:crypto') {\n              algs = algs.concat(['ES256K']);\n            }\n            break;\n        }\n      }\n\n      return new Set(algs);\n    }\n    case 'OKP': {\n      return new Set(['ECDH-ES', 'ECDH-ES+A128KW', 'ECDH-ES+A192KW', 'ECDH-ES+A256KW']);\n    }\n    case 'RSA': {\n      let algs = [];\n\n      if (use === 'enc' || use === undefined) {\n        algs = algs.concat(['RSA-OAEP', 'RSA-OAEP-256', 'RSA-OAEP-384', 'RSA-OAEP-512']);\n        if (jose.cryptoRuntime === 'node:crypto') {\n          algs = algs.concat(['RSA1_5']);\n        }\n      }\n\n      if (use === 'sig' || use === undefined) {\n        algs = algs.concat(['PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512']);\n      }\n\n      return new Set(algs);\n    }\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nmodule.exports = class KeyStore {\n  #keys;\n\n  constructor(i, keys) {\n    if (i !== internal) throw new Error('invalid constructor call');\n    this.#keys = keys;\n  }\n\n  toJWKS() {\n    return {\n      keys: this.map(({ jwk: { d, p, q, dp, dq, qi, ...jwk } }) => jwk),\n    };\n  }\n\n  all({ alg, kid, use } = {}) {\n    if (!use || !alg) {\n      throw new Error();\n    }\n\n    const kty = getKtyFromAlg(alg);\n\n    const search = { alg, use };\n    return this.filter((key) => {\n      let candidate = true;\n\n      if (candidate && kty !== undefined && key.jwk.kty !== kty) {\n        candidate = false;\n      }\n\n      if (candidate && kid !== undefined && key.jwk.kid !== kid) {\n        candidate = false;\n      }\n\n      if (candidate && use !== undefined && key.jwk.use !== undefined && key.jwk.use !== use) {\n        candidate = false;\n      }\n\n      if (candidate && key.jwk.alg && key.jwk.alg !== alg) {\n        candidate = false;\n      } else if (!key.algorithms.has(alg)) {\n        candidate = false;\n      }\n\n      return candidate;\n    }).sort((first, second) => keyscore(second, search) - keyscore(first, search));\n  }\n\n  get(...args) {\n    return this.all(...args)[0];\n  }\n\n  static async fromJWKS(jwks, { onlyPublic = false, onlyPrivate = false } = {}) {\n    if (\n      !isPlainObject(jwks) ||\n      !Array.isArray(jwks.keys) ||\n      jwks.keys.some((k) => !isPlainObject(k) || !('kty' in k))\n    ) {\n      throw new TypeError('jwks must be a JSON Web Key Set formatted object');\n    }\n\n    const keys = [];\n\n    for (let jwk of jwks.keys) {\n      jwk = clone(jwk);\n      const { kty, kid, crv } = jwk;\n\n      let { alg, use } = jwk;\n\n      if (typeof kty !== 'string' || !kty) {\n        continue;\n      }\n\n      if (use !== undefined && use !== 'sig' && use !== 'enc') {\n        continue;\n      }\n\n      if (typeof alg !== 'string' && alg !== undefined) {\n        continue;\n      }\n\n      if (typeof kid !== 'string' && kid !== undefined) {\n        continue;\n      }\n\n      if (kty === 'EC' && use === 'sig') {\n        switch (crv) {\n          case 'P-256':\n            alg = 'ES256';\n            break;\n          case 'P-384':\n            alg = 'ES384';\n            break;\n          case 'P-521':\n            alg = 'ES512';\n            break;\n          default:\n            break;\n        }\n      }\n\n      if (crv === 'secp256k1') {\n        use = 'sig';\n        alg = 'ES256K';\n      }\n\n      if (kty === 'OKP') {\n        switch (crv) {\n          case 'Ed25519':\n          case 'Ed448':\n            use = 'sig';\n            alg = 'EdDSA';\n            break;\n          case 'X25519':\n          case 'X448':\n            use = 'enc';\n            break;\n          default:\n            break;\n        }\n      }\n\n      if (alg && !use) {\n        switch (true) {\n          case alg.startsWith('ECDH'):\n            use = 'enc';\n            break;\n          case alg.startsWith('RSA'):\n            use = 'enc';\n            break;\n          default:\n            break;\n        }\n      }\n\n      if (onlyPrivate && (jwk.kty === 'oct' || !jwk.d)) {\n        throw new Error('jwks must only contain private keys');\n      }\n\n      if (onlyPublic && (jwk.d || jwk.k)) {\n        continue;\n      }\n\n      keys.push({\n        jwk: { ...jwk, alg, use },\n        async keyObject(alg) {\n          if (this[alg]) {\n            return this[alg];\n          }\n\n          const keyObject = await jose.importJWK(this.jwk, alg);\n          this[alg] = keyObject;\n          return keyObject;\n        },\n        get algorithms() {\n          Object.defineProperty(this, 'algorithms', {\n            value: getAlgorithms(this.jwk.use, this.jwk.alg, this.jwk.kty, this.jwk.crv),\n            enumerable: true,\n            configurable: false,\n          });\n          return this.algorithms;\n        },\n      });\n    }\n\n    return new this(internal, keys);\n  }\n\n  filter(...args) {\n    return this.#keys.filter(...args);\n  }\n\n  find(...args) {\n    return this.#keys.find(...args);\n  }\n\n  every(...args) {\n    return this.#keys.every(...args);\n  }\n\n  some(...args) {\n    return this.#keys.some(...args);\n  }\n\n  map(...args) {\n    return this.#keys.map(...args);\n  }\n\n  forEach(...args) {\n    return this.#keys.forEach(...args);\n  }\n\n  reduce(...args) {\n    return this.#keys.reduce(...args);\n  }\n\n  sort(...args) {\n    return this.#keys.sort(...args);\n  }\n\n  *[Symbol.iterator]() {\n    for (const key of this.#keys) {\n      yield key;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMva2V5c3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLCtEQUFNOztBQUUzQixjQUFjLG1CQUFPLENBQUMsbUZBQWM7QUFDcEMsc0JBQXNCLG1CQUFPLENBQUMsNkZBQW1COztBQUVqRDs7QUFFQSx5QkFBeUIsVUFBVTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixPQUFPLCtCQUErQjtBQUM5RDtBQUNBOztBQUVBLFFBQVEsZ0JBQWdCLElBQUk7QUFDNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLDBDQUEwQyxJQUFJO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjs7QUFFOUIsWUFBWSxXQUFXOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvamFtYWx3YXJkL2F4aXMucG9pbnQvbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMva2V5c3RvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgam9zZSA9IHJlcXVpcmUoJ2pvc2UnKTtcblxuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2RlZXBfY2xvbmUnKTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzX3BsYWluX29iamVjdCcpO1xuXG5jb25zdCBpbnRlcm5hbCA9IFN5bWJvbCgpO1xuXG5jb25zdCBrZXlzY29yZSA9IChrZXksIHsgYWxnLCB1c2UgfSkgPT4ge1xuICBsZXQgc2NvcmUgPSAwO1xuXG4gIGlmIChhbGcgJiYga2V5LmFsZykge1xuICAgIHNjb3JlKys7XG4gIH1cblxuICBpZiAodXNlICYmIGtleS51c2UpIHtcbiAgICBzY29yZSsrO1xuICB9XG5cbiAgcmV0dXJuIHNjb3JlO1xufTtcblxuZnVuY3Rpb24gZ2V0S3R5RnJvbUFsZyhhbGcpIHtcbiAgc3dpdGNoICh0eXBlb2YgYWxnID09PSAnc3RyaW5nJyAmJiBhbGcuc2xpY2UoMCwgMikpIHtcbiAgICBjYXNlICdSUyc6XG4gICAgY2FzZSAnUFMnOlxuICAgICAgcmV0dXJuICdSU0EnO1xuICAgIGNhc2UgJ0VTJzpcbiAgICAgIHJldHVybiAnRUMnO1xuICAgIGNhc2UgJ0VkJzpcbiAgICAgIHJldHVybiAnT0tQJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbGdvcml0aG1zKHVzZSwgYWxnLCBrdHksIGNydikge1xuICAvLyBFZDI1NTE5LCBFZDQ0OCwgYW5kIHNlY3AyNTZrMSBhbHdheXMgaGF2ZSBcImFsZ1wiXG4gIC8vIE9LUCBhbHdheXMgaGFzIFwidXNlXCJcbiAgaWYgKGFsZykge1xuICAgIHJldHVybiBuZXcgU2V0KFthbGddKTtcbiAgfVxuXG4gIHN3aXRjaCAoa3R5KSB7XG4gICAgY2FzZSAnRUMnOiB7XG4gICAgICBsZXQgYWxncyA9IFtdO1xuXG4gICAgICBpZiAodXNlID09PSAnZW5jJyB8fCB1c2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbGdzID0gYWxncy5jb25jYXQoWydFQ0RILUVTJywgJ0VDREgtRVMrQTEyOEtXJywgJ0VDREgtRVMrQTE5MktXJywgJ0VDREgtRVMrQTI1NktXJ10pO1xuICAgICAgfVxuXG4gICAgICBpZiAodXNlID09PSAnc2lnJyB8fCB1c2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzd2l0Y2ggKGNydikge1xuICAgICAgICAgIGNhc2UgJ1AtMjU2JzpcbiAgICAgICAgICBjYXNlICdQLTM4NCc6XG4gICAgICAgICAgICBhbGdzID0gYWxncy5jb25jYXQoW2BFUyR7Y3J2LnNsaWNlKC0zKX1gXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdQLTUyMSc6XG4gICAgICAgICAgICBhbGdzID0gYWxncy5jb25jYXQoWydFUzUxMiddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NlY3AyNTZrMSc6XG4gICAgICAgICAgICBpZiAoam9zZS5jcnlwdG9SdW50aW1lID09PSAnbm9kZTpjcnlwdG8nKSB7XG4gICAgICAgICAgICAgIGFsZ3MgPSBhbGdzLmNvbmNhdChbJ0VTMjU2SyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU2V0KGFsZ3MpO1xuICAgIH1cbiAgICBjYXNlICdPS1AnOiB7XG4gICAgICByZXR1cm4gbmV3IFNldChbJ0VDREgtRVMnLCAnRUNESC1FUytBMTI4S1cnLCAnRUNESC1FUytBMTkyS1cnLCAnRUNESC1FUytBMjU2S1cnXSk7XG4gICAgfVxuICAgIGNhc2UgJ1JTQSc6IHtcbiAgICAgIGxldCBhbGdzID0gW107XG5cbiAgICAgIGlmICh1c2UgPT09ICdlbmMnIHx8IHVzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFsZ3MgPSBhbGdzLmNvbmNhdChbJ1JTQS1PQUVQJywgJ1JTQS1PQUVQLTI1NicsICdSU0EtT0FFUC0zODQnLCAnUlNBLU9BRVAtNTEyJ10pO1xuICAgICAgICBpZiAoam9zZS5jcnlwdG9SdW50aW1lID09PSAnbm9kZTpjcnlwdG8nKSB7XG4gICAgICAgICAgYWxncyA9IGFsZ3MuY29uY2F0KFsnUlNBMV81J10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2UgPT09ICdzaWcnIHx8IHVzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFsZ3MgPSBhbGdzLmNvbmNhdChbJ1BTMjU2JywgJ1BTMzg0JywgJ1BTNTEyJywgJ1JTMjU2JywgJ1JTMzg0JywgJ1JTNTEyJ10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFNldChhbGdzKTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEtleVN0b3JlIHtcbiAgI2tleXM7XG5cbiAgY29uc3RydWN0b3IoaSwga2V5cykge1xuICAgIGlmIChpICE9PSBpbnRlcm5hbCkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvbnN0cnVjdG9yIGNhbGwnKTtcbiAgICB0aGlzLiNrZXlzID0ga2V5cztcbiAgfVxuXG4gIHRvSldLUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogdGhpcy5tYXAoKHsgandrOiB7IGQsIHAsIHEsIGRwLCBkcSwgcWksIC4uLmp3ayB9IH0pID0+IGp3ayksXG4gICAgfTtcbiAgfVxuXG4gIGFsbCh7IGFsZywga2lkLCB1c2UgfSA9IHt9KSB7XG4gICAgaWYgKCF1c2UgfHwgIWFsZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuXG4gICAgY29uc3Qga3R5ID0gZ2V0S3R5RnJvbUFsZyhhbGcpO1xuXG4gICAgY29uc3Qgc2VhcmNoID0geyBhbGcsIHVzZSB9O1xuICAgIHJldHVybiB0aGlzLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICBsZXQgY2FuZGlkYXRlID0gdHJ1ZTtcblxuICAgICAgaWYgKGNhbmRpZGF0ZSAmJiBrdHkgIT09IHVuZGVmaW5lZCAmJiBrZXkuandrLmt0eSAhPT0ga3R5KSB7XG4gICAgICAgIGNhbmRpZGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuZGlkYXRlICYmIGtpZCAhPT0gdW5kZWZpbmVkICYmIGtleS5qd2sua2lkICE9PSBraWQpIHtcbiAgICAgICAgY2FuZGlkYXRlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5kaWRhdGUgJiYgdXNlICE9PSB1bmRlZmluZWQgJiYga2V5Lmp3ay51c2UgIT09IHVuZGVmaW5lZCAmJiBrZXkuandrLnVzZSAhPT0gdXNlKSB7XG4gICAgICAgIGNhbmRpZGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuZGlkYXRlICYmIGtleS5qd2suYWxnICYmIGtleS5qd2suYWxnICE9PSBhbGcpIHtcbiAgICAgICAgY2FuZGlkYXRlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFrZXkuYWxnb3JpdGhtcy5oYXMoYWxnKSkge1xuICAgICAgICBjYW5kaWRhdGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICB9KS5zb3J0KChmaXJzdCwgc2Vjb25kKSA9PiBrZXlzY29yZShzZWNvbmQsIHNlYXJjaCkgLSBrZXlzY29yZShmaXJzdCwgc2VhcmNoKSk7XG4gIH1cblxuICBnZXQoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmFsbCguLi5hcmdzKVswXTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tSldLUyhqd2tzLCB7IG9ubHlQdWJsaWMgPSBmYWxzZSwgb25seVByaXZhdGUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBpZiAoXG4gICAgICAhaXNQbGFpbk9iamVjdChqd2tzKSB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkoandrcy5rZXlzKSB8fFxuICAgICAgandrcy5rZXlzLnNvbWUoKGspID0+ICFpc1BsYWluT2JqZWN0KGspIHx8ICEoJ2t0eScgaW4gaykpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdqd2tzIG11c3QgYmUgYSBKU09OIFdlYiBLZXkgU2V0IGZvcm1hdHRlZCBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gW107XG5cbiAgICBmb3IgKGxldCBqd2sgb2Ygandrcy5rZXlzKSB7XG4gICAgICBqd2sgPSBjbG9uZShqd2spO1xuICAgICAgY29uc3QgeyBrdHksIGtpZCwgY3J2IH0gPSBqd2s7XG5cbiAgICAgIGxldCB7IGFsZywgdXNlIH0gPSBqd2s7XG5cbiAgICAgIGlmICh0eXBlb2Yga3R5ICE9PSAnc3RyaW5nJyB8fCAha3R5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodXNlICE9PSB1bmRlZmluZWQgJiYgdXNlICE9PSAnc2lnJyAmJiB1c2UgIT09ICdlbmMnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGFsZyAhPT0gJ3N0cmluZycgJiYgYWxnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Yga2lkICE9PSAnc3RyaW5nJyAmJiBraWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGt0eSA9PT0gJ0VDJyAmJiB1c2UgPT09ICdzaWcnKSB7XG4gICAgICAgIHN3aXRjaCAoY3J2KSB7XG4gICAgICAgICAgY2FzZSAnUC0yNTYnOlxuICAgICAgICAgICAgYWxnID0gJ0VTMjU2JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1AtMzg0JzpcbiAgICAgICAgICAgIGFsZyA9ICdFUzM4NCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdQLTUyMSc6XG4gICAgICAgICAgICBhbGcgPSAnRVM1MTInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjcnYgPT09ICdzZWNwMjU2azEnKSB7XG4gICAgICAgIHVzZSA9ICdzaWcnO1xuICAgICAgICBhbGcgPSAnRVMyNTZLJztcbiAgICAgIH1cblxuICAgICAgaWYgKGt0eSA9PT0gJ09LUCcpIHtcbiAgICAgICAgc3dpdGNoIChjcnYpIHtcbiAgICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgICBjYXNlICdFZDQ0OCc6XG4gICAgICAgICAgICB1c2UgPSAnc2lnJztcbiAgICAgICAgICAgIGFsZyA9ICdFZERTQSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdYMjU1MTknOlxuICAgICAgICAgIGNhc2UgJ1g0NDgnOlxuICAgICAgICAgICAgdXNlID0gJ2VuYyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFsZyAmJiAhdXNlKSB7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgIGNhc2UgYWxnLnN0YXJ0c1dpdGgoJ0VDREgnKTpcbiAgICAgICAgICAgIHVzZSA9ICdlbmMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhbGcuc3RhcnRzV2l0aCgnUlNBJyk6XG4gICAgICAgICAgICB1c2UgPSAnZW5jJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob25seVByaXZhdGUgJiYgKGp3ay5rdHkgPT09ICdvY3QnIHx8ICFqd2suZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqd2tzIG11c3Qgb25seSBjb250YWluIHByaXZhdGUga2V5cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAob25seVB1YmxpYyAmJiAoandrLmQgfHwgandrLmspKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBqd2s6IHsgLi4uandrLCBhbGcsIHVzZSB9LFxuICAgICAgICBhc3luYyBrZXlPYmplY3QoYWxnKSB7XG4gICAgICAgICAgaWYgKHRoaXNbYWxnXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbYWxnXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBrZXlPYmplY3QgPSBhd2FpdCBqb3NlLmltcG9ydEpXSyh0aGlzLmp3aywgYWxnKTtcbiAgICAgICAgICB0aGlzW2FsZ10gPSBrZXlPYmplY3Q7XG4gICAgICAgICAgcmV0dXJuIGtleU9iamVjdDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGFsZ29yaXRobXMoKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdhbGdvcml0aG1zJywge1xuICAgICAgICAgICAgdmFsdWU6IGdldEFsZ29yaXRobXModGhpcy5qd2sudXNlLCB0aGlzLmp3ay5hbGcsIHRoaXMuandrLmt0eSwgdGhpcy5qd2suY3J2KSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmFsZ29yaXRobXM7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHRoaXMoaW50ZXJuYWwsIGtleXMpO1xuICB9XG5cbiAgZmlsdGVyKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4ja2V5cy5maWx0ZXIoLi4uYXJncyk7XG4gIH1cblxuICBmaW5kKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4ja2V5cy5maW5kKC4uLmFyZ3MpO1xuICB9XG5cbiAgZXZlcnkoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNrZXlzLmV2ZXJ5KC4uLmFyZ3MpO1xuICB9XG5cbiAgc29tZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMuc29tZSguLi5hcmdzKTtcbiAgfVxuXG4gIG1hcCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMubWFwKC4uLmFyZ3MpO1xuICB9XG5cbiAgZm9yRWFjaCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMuZm9yRWFjaCguLi5hcmdzKTtcbiAgfVxuXG4gIHJlZHVjZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMucmVkdWNlKC4uLmFyZ3MpO1xuICB9XG5cbiAgc29ydCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMuc29ydCguLi5hcmdzKTtcbiAgfVxuXG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLiNrZXlzKSB7XG4gICAgICB5aWVsZCBrZXk7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/keystore.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/merge.js":
/*!**********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/merge.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js\");\n\nfunction merge(target, ...sources) {\n  for (const source of sources) {\n    if (!isPlainObject(source)) {\n      continue;\n    }\n    for (const [key, value] of Object.entries(source)) {\n      /* istanbul ignore if */\n      if (key === '__proto__' || key === 'constructor') {\n        continue;\n      }\n      if (isPlainObject(target[key]) && isPlainObject(value)) {\n        target[key] = merge(target[key], value);\n      } else if (typeof value !== 'undefined') {\n        target[key] = value;\n      }\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = merge;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvbWVyZ2UuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0JBQXNCLG1CQUFPLENBQUMsNkZBQW1COztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phbWFsd2FyZC9heGlzLnBvaW50L25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL21lcmdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzX3BsYWluX29iamVjdCcpO1xuXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIC4uLnNvdXJjZXMpIHtcbiAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZSh0YXJnZXRba2V5XSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/merge.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/pick.js":
/*!*********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/pick.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("module.exports = function pick(object, ...paths) {\n  const obj = {};\n  for (const path of paths) {\n    if (object[path] !== undefined) {\n      obj[path] = object[path];\n    }\n  }\n  return obj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvcGljay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYW1hbHdhcmQvYXhpcy5wb2ludC9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9waWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGljayhvYmplY3QsIC4uLnBhdGhzKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBpZiAob2JqZWN0W3BhdGhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9ialtwYXRoXSA9IG9iamVjdFtwYXRoXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/pick.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/process_response.js":
/*!*********************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/process_response.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\nconst { format } = __webpack_require__(/*! util */ \"util\");\n\nconst { OPError } = __webpack_require__(/*! ../errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst parseWwwAuthenticate = __webpack_require__(/*! ./www_authenticate_parser */ \"(rsc)/../node_modules/openid-client/lib/helpers/www_authenticate_parser.js\");\n\nconst throwAuthenticateErrors = (response) => {\n  const params = parseWwwAuthenticate(response.headers['www-authenticate']);\n\n  if (params.error) {\n    throw new OPError(params, response);\n  }\n};\n\nconst isStandardBodyError = (response) => {\n  let result = false;\n  try {\n    let jsonbody;\n    if (typeof response.body !== 'object' || Buffer.isBuffer(response.body)) {\n      jsonbody = JSON.parse(response.body);\n    } else {\n      jsonbody = response.body;\n    }\n    result = typeof jsonbody.error === 'string' && jsonbody.error.length;\n    if (result) Object.defineProperty(response, 'body', { value: jsonbody, configurable: true });\n  } catch (err) {}\n\n  return result;\n};\n\nfunction processResponse(response, { statusCode = 200, body = true, bearer = false } = {}) {\n  if (response.statusCode !== statusCode) {\n    if (bearer) {\n      throwAuthenticateErrors(response);\n    }\n\n    if (isStandardBodyError(response)) {\n      throw new OPError(response.body, response);\n    }\n\n    throw new OPError(\n      {\n        error: format(\n          'expected %i %s, got: %i %s',\n          statusCode,\n          STATUS_CODES[statusCode],\n          response.statusCode,\n          STATUS_CODES[response.statusCode],\n        ),\n      },\n      response,\n    );\n  }\n\n  if (body && !response.body) {\n    throw new OPError(\n      {\n        error: format(\n          'expected %i %s with body but no body was returned',\n          statusCode,\n          STATUS_CODES[statusCode],\n        ),\n      },\n      response,\n    );\n  }\n\n  return response.body;\n}\n\nmodule.exports = processResponse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvcHJvY2Vzc19yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3ZDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsa0JBQU07O0FBRWpDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsb0VBQVc7QUFDdkMsNkJBQTZCLG1CQUFPLENBQUMsNkdBQTJCOztBQUVoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQscUNBQXFDO0FBQy9GLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxxQ0FBcUMsZ0RBQWdELElBQUk7QUFDekY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phbWFsd2FyZC9heGlzLnBvaW50L25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3Byb2Nlc3NfcmVzcG9uc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBTVEFUVVNfQ09ERVMgfSA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHsgZm9ybWF0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IHsgT1BFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBwYXJzZVd3d0F1dGhlbnRpY2F0ZSA9IHJlcXVpcmUoJy4vd3d3X2F1dGhlbnRpY2F0ZV9wYXJzZXInKTtcblxuY29uc3QgdGhyb3dBdXRoZW50aWNhdGVFcnJvcnMgPSAocmVzcG9uc2UpID0+IHtcbiAgY29uc3QgcGFyYW1zID0gcGFyc2VXd3dBdXRoZW50aWNhdGUocmVzcG9uc2UuaGVhZGVyc1snd3d3LWF1dGhlbnRpY2F0ZSddKTtcblxuICBpZiAocGFyYW1zLmVycm9yKSB7XG4gICAgdGhyb3cgbmV3IE9QRXJyb3IocGFyYW1zLCByZXNwb25zZSk7XG4gIH1cbn07XG5cbmNvbnN0IGlzU3RhbmRhcmRCb2R5RXJyb3IgPSAocmVzcG9uc2UpID0+IHtcbiAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGxldCBqc29uYm9keTtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmJvZHkgIT09ICdvYmplY3QnIHx8IEJ1ZmZlci5pc0J1ZmZlcihyZXNwb25zZS5ib2R5KSkge1xuICAgICAganNvbmJvZHkgPSBKU09OLnBhcnNlKHJlc3BvbnNlLmJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBqc29uYm9keSA9IHJlc3BvbnNlLmJvZHk7XG4gICAgfVxuICAgIHJlc3VsdCA9IHR5cGVvZiBqc29uYm9keS5lcnJvciA9PT0gJ3N0cmluZycgJiYganNvbmJvZHkuZXJyb3IubGVuZ3RoO1xuICAgIGlmIChyZXN1bHQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ2JvZHknLCB7IHZhbHVlOiBqc29uYm9keSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSwgeyBzdGF0dXNDb2RlID0gMjAwLCBib2R5ID0gdHJ1ZSwgYmVhcmVyID0gZmFsc2UgfSA9IHt9KSB7XG4gIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSBzdGF0dXNDb2RlKSB7XG4gICAgaWYgKGJlYXJlcikge1xuICAgICAgdGhyb3dBdXRoZW50aWNhdGVFcnJvcnMocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGlmIChpc1N0YW5kYXJkQm9keUVycm9yKHJlc3BvbnNlKSkge1xuICAgICAgdGhyb3cgbmV3IE9QRXJyb3IocmVzcG9uc2UuYm9keSwgcmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBPUEVycm9yKFxuICAgICAge1xuICAgICAgICBlcnJvcjogZm9ybWF0KFxuICAgICAgICAgICdleHBlY3RlZCAlaSAlcywgZ290OiAlaSAlcycsXG4gICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICBTVEFUVVNfQ09ERVNbc3RhdHVzQ29kZV0sXG4gICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICBTVEFUVVNfQ09ERVNbcmVzcG9uc2Uuc3RhdHVzQ29kZV0sXG4gICAgICAgICksXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2UsXG4gICAgKTtcbiAgfVxuXG4gIGlmIChib2R5ICYmICFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IE9QRXJyb3IoXG4gICAgICB7XG4gICAgICAgIGVycm9yOiBmb3JtYXQoXG4gICAgICAgICAgJ2V4cGVjdGVkICVpICVzIHdpdGggYm9keSBidXQgbm8gYm9keSB3YXMgcmV0dXJuZWQnLFxuICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgU1RBVFVTX0NPREVTW3N0YXR1c0NvZGVdLFxuICAgICAgICApLFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzUmVzcG9uc2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/process_response.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/request.js":
/*!************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/request.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! assert */ \"assert\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst { once } = __webpack_require__(/*! events */ \"events\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/../node_modules/lru-cache/index.js\");\n\nconst pkg = __webpack_require__(/*! ../../package.json */ \"(rsc)/../node_modules/openid-client/package.json\");\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\n\nconst pick = __webpack_require__(/*! ./pick */ \"(rsc)/../node_modules/openid-client/lib/helpers/pick.js\");\nconst { deep: defaultsDeep } = __webpack_require__(/*! ./defaults */ \"(rsc)/../node_modules/openid-client/lib/helpers/defaults.js\");\nconst { HTTP_OPTIONS } = __webpack_require__(/*! ./consts */ \"(rsc)/../node_modules/openid-client/lib/helpers/consts.js\");\n\nlet DEFAULT_HTTP_OPTIONS;\nconst NQCHAR = /^[\\x21\\x23-\\x5B\\x5D-\\x7E]+$/;\n\nconst allowed = [\n  'agent',\n  'ca',\n  'cert',\n  'crl',\n  'headers',\n  'key',\n  'lookup',\n  'passphrase',\n  'pfx',\n  'timeout',\n];\n\nconst setDefaults = (props, options) => {\n  DEFAULT_HTTP_OPTIONS = defaultsDeep(\n    {},\n    props.length ? pick(options, ...props) : options,\n    DEFAULT_HTTP_OPTIONS,\n  );\n};\n\nsetDefaults([], {\n  headers: {\n    'User-Agent': `${pkg.name}/${pkg.version} (${pkg.homepage})`,\n    'Accept-Encoding': 'identity',\n  },\n  timeout: 3500,\n});\n\nfunction send(req, body, contentType) {\n  if (contentType) {\n    req.removeHeader('content-type');\n    req.setHeader('content-type', contentType);\n  }\n  if (body) {\n    req.removeHeader('content-length');\n    req.setHeader('content-length', Buffer.byteLength(body));\n    req.write(body);\n  }\n  req.end();\n}\n\nconst nonces = new LRU({ max: 100 });\n\nmodule.exports = async function request(options, { accessToken, mTLS = false, DPoP } = {}) {\n  let url;\n  try {\n    url = new URL(options.url);\n    delete options.url;\n    assert(/^(https?:)$/.test(url.protocol));\n  } catch (err) {\n    throw new TypeError('only valid absolute URLs can be requested');\n  }\n  const optsFn = this[HTTP_OPTIONS];\n  let opts = options;\n\n  const nonceKey = `${url.origin}${url.pathname}`;\n  if (DPoP && 'dpopProof' in this) {\n    opts.headers = opts.headers || {};\n    opts.headers.DPoP = await this.dpopProof(\n      {\n        htu: `${url.origin}${url.pathname}`,\n        htm: options.method || 'GET',\n        nonce: nonces.get(nonceKey),\n      },\n      DPoP,\n      accessToken,\n    );\n  }\n\n  let userOptions;\n  if (optsFn) {\n    userOptions = pick(\n      optsFn.call(this, url, defaultsDeep({}, opts, DEFAULT_HTTP_OPTIONS)),\n      ...allowed,\n    );\n  }\n  opts = defaultsDeep({}, userOptions, opts, DEFAULT_HTTP_OPTIONS);\n\n  if (mTLS && !opts.pfx && !(opts.key && opts.cert)) {\n    throw new TypeError('mutual-TLS certificate and key not set');\n  }\n\n  if (opts.searchParams) {\n    for (const [key, value] of Object.entries(opts.searchParams)) {\n      url.searchParams.delete(key);\n      url.searchParams.set(key, value);\n    }\n  }\n\n  let responseType;\n  let form;\n  let json;\n  let body;\n  ({ form, responseType, json, body, ...opts } = opts);\n\n  for (const [key, value] of Object.entries(opts.headers || {})) {\n    if (value === undefined) {\n      delete opts.headers[key];\n    }\n  }\n\n  let response;\n  const req = (url.protocol === 'https:' ? https.request : http.request)(url.href, opts);\n  return (async () => {\n    if (json) {\n      send(req, JSON.stringify(json), 'application/json');\n    } else if (form) {\n      send(req, querystring.stringify(form), 'application/x-www-form-urlencoded');\n    } else if (body) {\n      send(req, body);\n    } else {\n      send(req);\n    }\n\n    [response] = await Promise.race([once(req, 'response'), once(req, 'timeout')]);\n\n    // timeout reached\n    if (!response) {\n      req.destroy();\n      throw new RPError(`outgoing request timed out after ${opts.timeout}ms`);\n    }\n\n    const parts = [];\n\n    for await (const part of response) {\n      parts.push(part);\n    }\n\n    if (parts.length) {\n      switch (responseType) {\n        case 'json': {\n          Object.defineProperty(response, 'body', {\n            get() {\n              let value = Buffer.concat(parts);\n              try {\n                value = JSON.parse(value);\n              } catch (err) {\n                Object.defineProperty(err, 'response', { value: response });\n                throw err;\n              } finally {\n                Object.defineProperty(response, 'body', { value, configurable: true });\n              }\n              return value;\n            },\n            configurable: true,\n          });\n          break;\n        }\n        case undefined:\n        case 'buffer': {\n          Object.defineProperty(response, 'body', {\n            get() {\n              const value = Buffer.concat(parts);\n              Object.defineProperty(response, 'body', { value, configurable: true });\n              return value;\n            },\n            configurable: true,\n          });\n          break;\n        }\n        default:\n          throw new TypeError('unsupported responseType request option');\n      }\n    }\n\n    return response;\n  })()\n    .catch((err) => {\n      if (response) Object.defineProperty(err, 'response', { value: response });\n      throw err;\n    })\n    .finally(() => {\n      const dpopNonce = response && response.headers['dpop-nonce'];\n      if (dpopNonce && NQCHAR.test(dpopNonce)) {\n        nonces.set(nonceKey, dpopNonce);\n      }\n    });\n};\n\nmodule.exports.setDefaults = setDefaults.bind(undefined, allowed);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsZ0NBQWE7QUFDekMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsZ0JBQUs7O0FBRTdCLFlBQVksbUJBQU8sQ0FBQywyREFBVzs7QUFFL0IsWUFBWSxtQkFBTyxDQUFDLDRFQUFvQjtBQUN4QyxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLG9FQUFXOztBQUV2QyxhQUFhLG1CQUFPLENBQUMsdUVBQVE7QUFDN0IsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLCtFQUFZO0FBQ25ELFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsMkVBQVU7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixTQUFTLEdBQUcsYUFBYSxHQUFHLGFBQWE7QUFDOUQ7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsVUFBVTs7QUFFbkMsbURBQW1ELGtDQUFrQyxJQUFJO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFdBQVcsRUFBRSxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVcsRUFBRSxhQUFhO0FBQzFDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMENBQTBDOztBQUUvQyw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxhQUFhO0FBQ3pFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQSxnQkFBZ0I7QUFDaEIsMERBQTBELDJCQUEyQjtBQUNyRjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDJCQUEyQjtBQUNuRjtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2REFBNkQsaUJBQWlCO0FBQzlFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsMEJBQTBCIiwic291cmNlcyI6WyIvVXNlcnMvamFtYWx3YXJkL2F4aXMucG9pbnQvbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvcmVxdWVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbmNvbnN0IHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCB7IG9uY2UgfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKTtcblxuY29uc3QgcGtnID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCB7IFJQRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG5jb25zdCBwaWNrID0gcmVxdWlyZSgnLi9waWNrJyk7XG5jb25zdCB7IGRlZXA6IGRlZmF1bHRzRGVlcCB9ID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuY29uc3QgeyBIVFRQX09QVElPTlMgfSA9IHJlcXVpcmUoJy4vY29uc3RzJyk7XG5cbmxldCBERUZBVUxUX0hUVFBfT1BUSU9OUztcbmNvbnN0IE5RQ0hBUiA9IC9eW1xceDIxXFx4MjMtXFx4NUJcXHg1RC1cXHg3RV0rJC87XG5cbmNvbnN0IGFsbG93ZWQgPSBbXG4gICdhZ2VudCcsXG4gICdjYScsXG4gICdjZXJ0JyxcbiAgJ2NybCcsXG4gICdoZWFkZXJzJyxcbiAgJ2tleScsXG4gICdsb29rdXAnLFxuICAncGFzc3BocmFzZScsXG4gICdwZngnLFxuICAndGltZW91dCcsXG5dO1xuXG5jb25zdCBzZXREZWZhdWx0cyA9IChwcm9wcywgb3B0aW9ucykgPT4ge1xuICBERUZBVUxUX0hUVFBfT1BUSU9OUyA9IGRlZmF1bHRzRGVlcChcbiAgICB7fSxcbiAgICBwcm9wcy5sZW5ndGggPyBwaWNrKG9wdGlvbnMsIC4uLnByb3BzKSA6IG9wdGlvbnMsXG4gICAgREVGQVVMVF9IVFRQX09QVElPTlMsXG4gICk7XG59O1xuXG5zZXREZWZhdWx0cyhbXSwge1xuICBoZWFkZXJzOiB7XG4gICAgJ1VzZXItQWdlbnQnOiBgJHtwa2cubmFtZX0vJHtwa2cudmVyc2lvbn0gKCR7cGtnLmhvbWVwYWdlfSlgLFxuICAgICdBY2NlcHQtRW5jb2RpbmcnOiAnaWRlbnRpdHknLFxuICB9LFxuICB0aW1lb3V0OiAzNTAwLFxufSk7XG5cbmZ1bmN0aW9uIHNlbmQocmVxLCBib2R5LCBjb250ZW50VHlwZSkge1xuICBpZiAoY29udGVudFR5cGUpIHtcbiAgICByZXEucmVtb3ZlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgICByZXEuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCBjb250ZW50VHlwZSk7XG4gIH1cbiAgaWYgKGJvZHkpIHtcbiAgICByZXEucmVtb3ZlSGVhZGVyKCdjb250ZW50LWxlbmd0aCcpO1xuICAgIHJlcS5zZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJywgQnVmZmVyLmJ5dGVMZW5ndGgoYm9keSkpO1xuICAgIHJlcS53cml0ZShib2R5KTtcbiAgfVxuICByZXEuZW5kKCk7XG59XG5cbmNvbnN0IG5vbmNlcyA9IG5ldyBMUlUoeyBtYXg6IDEwMCB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyBmdW5jdGlvbiByZXF1ZXN0KG9wdGlvbnMsIHsgYWNjZXNzVG9rZW4sIG1UTFMgPSBmYWxzZSwgRFBvUCB9ID0ge30pIHtcbiAgbGV0IHVybDtcbiAgdHJ5IHtcbiAgICB1cmwgPSBuZXcgVVJMKG9wdGlvbnMudXJsKTtcbiAgICBkZWxldGUgb3B0aW9ucy51cmw7XG4gICAgYXNzZXJ0KC9eKGh0dHBzPzopJC8udGVzdCh1cmwucHJvdG9jb2wpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb25seSB2YWxpZCBhYnNvbHV0ZSBVUkxzIGNhbiBiZSByZXF1ZXN0ZWQnKTtcbiAgfVxuICBjb25zdCBvcHRzRm4gPSB0aGlzW0hUVFBfT1BUSU9OU107XG4gIGxldCBvcHRzID0gb3B0aW9ucztcblxuICBjb25zdCBub25jZUtleSA9IGAke3VybC5vcmlnaW59JHt1cmwucGF0aG5hbWV9YDtcbiAgaWYgKERQb1AgJiYgJ2Rwb3BQcm9vZicgaW4gdGhpcykge1xuICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICBvcHRzLmhlYWRlcnMuRFBvUCA9IGF3YWl0IHRoaXMuZHBvcFByb29mKFxuICAgICAge1xuICAgICAgICBodHU6IGAke3VybC5vcmlnaW59JHt1cmwucGF0aG5hbWV9YCxcbiAgICAgICAgaHRtOiBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgICAgbm9uY2U6IG5vbmNlcy5nZXQobm9uY2VLZXkpLFxuICAgICAgfSxcbiAgICAgIERQb1AsXG4gICAgICBhY2Nlc3NUb2tlbixcbiAgICApO1xuICB9XG5cbiAgbGV0IHVzZXJPcHRpb25zO1xuICBpZiAob3B0c0ZuKSB7XG4gICAgdXNlck9wdGlvbnMgPSBwaWNrKFxuICAgICAgb3B0c0ZuLmNhbGwodGhpcywgdXJsLCBkZWZhdWx0c0RlZXAoe30sIG9wdHMsIERFRkFVTFRfSFRUUF9PUFRJT05TKSksXG4gICAgICAuLi5hbGxvd2VkLFxuICAgICk7XG4gIH1cbiAgb3B0cyA9IGRlZmF1bHRzRGVlcCh7fSwgdXNlck9wdGlvbnMsIG9wdHMsIERFRkFVTFRfSFRUUF9PUFRJT05TKTtcblxuICBpZiAobVRMUyAmJiAhb3B0cy5wZnggJiYgIShvcHRzLmtleSAmJiBvcHRzLmNlcnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXV0dWFsLVRMUyBjZXJ0aWZpY2F0ZSBhbmQga2V5IG5vdCBzZXQnKTtcbiAgfVxuXG4gIGlmIChvcHRzLnNlYXJjaFBhcmFtcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdHMuc2VhcmNoUGFyYW1zKSkge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXNwb25zZVR5cGU7XG4gIGxldCBmb3JtO1xuICBsZXQganNvbjtcbiAgbGV0IGJvZHk7XG4gICh7IGZvcm0sIHJlc3BvbnNlVHlwZSwganNvbiwgYm9keSwgLi4ub3B0cyB9ID0gb3B0cyk7XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0cy5oZWFkZXJzIHx8IHt9KSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgb3B0cy5oZWFkZXJzW2tleV07XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlc3BvbnNlO1xuICBjb25zdCByZXEgPSAodXJsLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3QpKHVybC5ocmVmLCBvcHRzKTtcbiAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgaWYgKGpzb24pIHtcbiAgICAgIHNlbmQocmVxLCBKU09OLnN0cmluZ2lmeShqc29uKSwgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB9IGVsc2UgaWYgKGZvcm0pIHtcbiAgICAgIHNlbmQocmVxLCBxdWVyeXN0cmluZy5zdHJpbmdpZnkoZm9ybSksICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICB9IGVsc2UgaWYgKGJvZHkpIHtcbiAgICAgIHNlbmQocmVxLCBib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZChyZXEpO1xuICAgIH1cblxuICAgIFtyZXNwb25zZV0gPSBhd2FpdCBQcm9taXNlLnJhY2UoW29uY2UocmVxLCAncmVzcG9uc2UnKSwgb25jZShyZXEsICd0aW1lb3V0JyldKTtcblxuICAgIC8vIHRpbWVvdXQgcmVhY2hlZFxuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHJlcS5kZXN0cm95KCk7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcihgb3V0Z29pbmcgcmVxdWVzdCB0aW1lZCBvdXQgYWZ0ZXIgJHtvcHRzLnRpbWVvdXR9bXNgKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHJlc3BvbnNlKSB7XG4gICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cblxuICAgIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAocmVzcG9uc2VUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2pzb24nOiB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCAnYm9keScsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gQnVmZmVyLmNvbmNhdChwYXJ0cyk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ3Jlc3BvbnNlJywgeyB2YWx1ZTogcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ2JvZHknLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnYnVmZmVyJzoge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ2JvZHknLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQnVmZmVyLmNvbmNhdChwYXJ0cyk7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ2JvZHknLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnN1cHBvcnRlZCByZXNwb25zZVR5cGUgcmVxdWVzdCBvcHRpb24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0pKClcbiAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAncmVzcG9uc2UnLCB7IHZhbHVlOiByZXNwb25zZSB9KTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KVxuICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNvbnN0IGRwb3BOb25jZSA9IHJlc3BvbnNlICYmIHJlc3BvbnNlLmhlYWRlcnNbJ2Rwb3Atbm9uY2UnXTtcbiAgICAgIGlmIChkcG9wTm9uY2UgJiYgTlFDSEFSLnRlc3QoZHBvcE5vbmNlKSkge1xuICAgICAgICBub25jZXMuc2V0KG5vbmNlS2V5LCBkcG9wTm9uY2UpO1xuICAgICAgfVxuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc2V0RGVmYXVsdHMgPSBzZXREZWZhdWx0cy5iaW5kKHVuZGVmaW5lZCwgYWxsb3dlZCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/request.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js":
/*!*******************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/unix_timestamp.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("module.exports = () => Math.floor(Date.now() / 1000);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvdW5peF90aW1lc3RhbXAuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYW1hbHdhcmQvYXhpcy5wb2ludC9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy91bml4X3RpbWVzdGFtcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9ICgpID0+IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/weak_cache.js":
/*!***************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/weak_cache.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("module.exports.keystores = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvd2Vha19jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3QkFBd0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYW1hbHdhcmQvYXhpcy5wb2ludC9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy93ZWFrX2NhY2hlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzLmtleXN0b3JlcyA9IG5ldyBXZWFrTWFwKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/weak_cache.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/webfinger_normalize.js":
/*!************************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/webfinger_normalize.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py\n\n// -- Normalization --\n// A string of any other type is interpreted as a URI either the form of scheme\n// \"://\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ] or authority\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986] and is\n// normalized according to the following rules:\n//\n// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme\n// portion, the string is interpreted as [userinfo \"@\"] host [\":\" port]\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986].\n// If the userinfo component is present and all of the path component, query\n// component, and port component are empty, the acct scheme is assumed. In this\n// case, the normalized URI is formed by prefixing acct: to the string as the\n// scheme. Per the 'acct' URI Scheme [I‑D.ietf‑appsawg‑acct‑uri], if there is an\n// at-sign character ('@') in the userinfo component, it needs to be\n// percent-encoded as described in RFC 3986 [RFC3986].\n// For all other inputs without a scheme portion, the https scheme is assumed,\n// and the normalized URI is formed by prefixing https:// to the string as the\n// scheme.\n// If the resulting URI contains a fragment portion, it MUST be stripped off\n// together with the fragment delimiter character \"#\".\n// The WebFinger [I‑D.ietf‑appsawg‑webfinger] Resource in this case is the\n// resulting URI, and the WebFinger Host is the authority component.\n//\n// Note: Since the definition of authority in RFC 3986 [RFC3986] is\n// [ userinfo \"@\" ] host [ \":\" port ], it is legal to have a user input\n// identifier like userinfo@host:port, e.g., alice@example.com:8080.\n\nconst PORT = /^\\d+$/;\n\nfunction hasScheme(input) {\n  if (input.includes('://')) return true;\n\n  const authority = input.replace(/(\\/|\\?)/g, '#').split('#')[0];\n  if (authority.includes(':')) {\n    const index = authority.indexOf(':');\n    const hostOrPort = authority.slice(index + 1);\n    if (!PORT.test(hostOrPort)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction acctSchemeAssumed(input) {\n  if (!input.includes('@')) return false;\n  const parts = input.split('@');\n  const host = parts[parts.length - 1];\n  return !(host.includes(':') || host.includes('/') || host.includes('?'));\n}\n\nfunction normalize(input) {\n  if (typeof input !== 'string') {\n    throw new TypeError('input must be a string');\n  }\n\n  let output;\n  if (hasScheme(input)) {\n    output = input;\n  } else if (acctSchemeAssumed(input)) {\n    output = `acct:${input}`;\n  } else {\n    output = `https://${input}`;\n  }\n\n  return output.split('#')[0];\n}\n\nmodule.exports = normalize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvd2ViZmluZ2VyX25vcm1hbGl6ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscUJBQXFCLE1BQU07QUFDM0IsSUFBSTtBQUNKLHdCQUF3QixNQUFNO0FBQzlCOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYW1hbHdhcmQvYXhpcy5wb2ludC9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy93ZWJmaW5nZXJfbm9ybWFsaXplLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENyZWRpdDogaHR0cHM6Ly9naXRodWIuY29tL3JvaGUvcHlvaWRjL2Jsb2IvbWFzdGVyL3NyYy9vaWMvdXRpbHMvd2ViZmluZ2VyLnB5XG5cbi8vIC0tIE5vcm1hbGl6YXRpb24gLS1cbi8vIEEgc3RyaW5nIG9mIGFueSBvdGhlciB0eXBlIGlzIGludGVycHJldGVkIGFzIGEgVVJJIGVpdGhlciB0aGUgZm9ybSBvZiBzY2hlbWVcbi8vIFwiOi8vXCIgYXV0aG9yaXR5IHBhdGgtYWJlbXB0eSBbIFwiP1wiIHF1ZXJ5IF0gWyBcIiNcIiBmcmFnbWVudCBdIG9yIGF1dGhvcml0eVxuLy8gcGF0aC1hYmVtcHR5IFsgXCI/XCIgcXVlcnkgXSBbIFwiI1wiIGZyYWdtZW50IF0gcGVyIFJGQyAzOTg2IFtSRkMzOTg2XSBhbmQgaXNcbi8vIG5vcm1hbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgcnVsZXM6XG4vL1xuLy8gSWYgdGhlIHVzZXIgaW5wdXQgSWRlbnRpZmllciBkb2VzIG5vdCBoYXZlIGFuIFJGQyAzOTg2IFtSRkMzOTg2XSBzY2hlbWVcbi8vIHBvcnRpb24sIHRoZSBzdHJpbmcgaXMgaW50ZXJwcmV0ZWQgYXMgW3VzZXJpbmZvIFwiQFwiXSBob3N0IFtcIjpcIiBwb3J0XVxuLy8gcGF0aC1hYmVtcHR5IFsgXCI/XCIgcXVlcnkgXSBbIFwiI1wiIGZyYWdtZW50IF0gcGVyIFJGQyAzOTg2IFtSRkMzOTg2XS5cbi8vIElmIHRoZSB1c2VyaW5mbyBjb21wb25lbnQgaXMgcHJlc2VudCBhbmQgYWxsIG9mIHRoZSBwYXRoIGNvbXBvbmVudCwgcXVlcnlcbi8vIGNvbXBvbmVudCwgYW5kIHBvcnQgY29tcG9uZW50IGFyZSBlbXB0eSwgdGhlIGFjY3Qgc2NoZW1lIGlzIGFzc3VtZWQuIEluIHRoaXNcbi8vIGNhc2UsIHRoZSBub3JtYWxpemVkIFVSSSBpcyBmb3JtZWQgYnkgcHJlZml4aW5nIGFjY3Q6IHRvIHRoZSBzdHJpbmcgYXMgdGhlXG4vLyBzY2hlbWUuIFBlciB0aGUgJ2FjY3QnIFVSSSBTY2hlbWUgW0nigJFELmlldGbigJFhcHBzYXdn4oCRYWNjdOKAkXVyaV0sIGlmIHRoZXJlIGlzIGFuXG4vLyBhdC1zaWduIGNoYXJhY3RlciAoJ0AnKSBpbiB0aGUgdXNlcmluZm8gY29tcG9uZW50LCBpdCBuZWVkcyB0byBiZVxuLy8gcGVyY2VudC1lbmNvZGVkIGFzIGRlc2NyaWJlZCBpbiBSRkMgMzk4NiBbUkZDMzk4Nl0uXG4vLyBGb3IgYWxsIG90aGVyIGlucHV0cyB3aXRob3V0IGEgc2NoZW1lIHBvcnRpb24sIHRoZSBodHRwcyBzY2hlbWUgaXMgYXNzdW1lZCxcbi8vIGFuZCB0aGUgbm9ybWFsaXplZCBVUkkgaXMgZm9ybWVkIGJ5IHByZWZpeGluZyBodHRwczovLyB0byB0aGUgc3RyaW5nIGFzIHRoZVxuLy8gc2NoZW1lLlxuLy8gSWYgdGhlIHJlc3VsdGluZyBVUkkgY29udGFpbnMgYSBmcmFnbWVudCBwb3J0aW9uLCBpdCBNVVNUIGJlIHN0cmlwcGVkIG9mZlxuLy8gdG9nZXRoZXIgd2l0aCB0aGUgZnJhZ21lbnQgZGVsaW1pdGVyIGNoYXJhY3RlciBcIiNcIi5cbi8vIFRoZSBXZWJGaW5nZXIgW0nigJFELmlldGbigJFhcHBzYXdn4oCRd2ViZmluZ2VyXSBSZXNvdXJjZSBpbiB0aGlzIGNhc2UgaXMgdGhlXG4vLyByZXN1bHRpbmcgVVJJLCBhbmQgdGhlIFdlYkZpbmdlciBIb3N0IGlzIHRoZSBhdXRob3JpdHkgY29tcG9uZW50LlxuLy9cbi8vIE5vdGU6IFNpbmNlIHRoZSBkZWZpbml0aW9uIG9mIGF1dGhvcml0eSBpbiBSRkMgMzk4NiBbUkZDMzk4Nl0gaXNcbi8vIFsgdXNlcmluZm8gXCJAXCIgXSBob3N0IFsgXCI6XCIgcG9ydCBdLCBpdCBpcyBsZWdhbCB0byBoYXZlIGEgdXNlciBpbnB1dFxuLy8gaWRlbnRpZmllciBsaWtlIHVzZXJpbmZvQGhvc3Q6cG9ydCwgZS5nLiwgYWxpY2VAZXhhbXBsZS5jb206ODA4MC5cblxuY29uc3QgUE9SVCA9IC9eXFxkKyQvO1xuXG5mdW5jdGlvbiBoYXNTY2hlbWUoaW5wdXQpIHtcbiAgaWYgKGlucHV0LmluY2x1ZGVzKCc6Ly8nKSkgcmV0dXJuIHRydWU7XG5cbiAgY29uc3QgYXV0aG9yaXR5ID0gaW5wdXQucmVwbGFjZSgvKFxcL3xcXD8pL2csICcjJykuc3BsaXQoJyMnKVswXTtcbiAgaWYgKGF1dGhvcml0eS5pbmNsdWRlcygnOicpKSB7XG4gICAgY29uc3QgaW5kZXggPSBhdXRob3JpdHkuaW5kZXhPZignOicpO1xuICAgIGNvbnN0IGhvc3RPclBvcnQgPSBhdXRob3JpdHkuc2xpY2UoaW5kZXggKyAxKTtcbiAgICBpZiAoIVBPUlQudGVzdChob3N0T3JQb3J0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhY2N0U2NoZW1lQXNzdW1lZChpbnB1dCkge1xuICBpZiAoIWlucHV0LmluY2x1ZGVzKCdAJykpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcGFydHMgPSBpbnB1dC5zcGxpdCgnQCcpO1xuICBjb25zdCBob3N0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gIHJldHVybiAhKGhvc3QuaW5jbHVkZXMoJzonKSB8fCBob3N0LmluY2x1ZGVzKCcvJykgfHwgaG9zdC5pbmNsdWRlcygnPycpKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKGlucHV0KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXQgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgbGV0IG91dHB1dDtcbiAgaWYgKGhhc1NjaGVtZShpbnB1dCkpIHtcbiAgICBvdXRwdXQgPSBpbnB1dDtcbiAgfSBlbHNlIGlmIChhY2N0U2NoZW1lQXNzdW1lZChpbnB1dCkpIHtcbiAgICBvdXRwdXQgPSBgYWNjdDoke2lucHV0fWA7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gYGh0dHBzOi8vJHtpbnB1dH1gO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5zcGxpdCgnIycpWzBdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/webfinger_normalize.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/www_authenticate_parser.js":
/*!****************************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/www_authenticate_parser.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("const REGEXP = /(\\w+)=(\"[^\"]*\")/g;\n\nmodule.exports = (wwwAuthenticate) => {\n  const params = {};\n  try {\n    while (REGEXP.exec(wwwAuthenticate) !== null) {\n      if (RegExp.$1 && RegExp.$2) {\n        params[RegExp.$1] = RegExp.$2.slice(1, -1);\n      }\n    }\n  } catch (err) {}\n\n  return params;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvd3d3X2F1dGhlbnRpY2F0ZV9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phbWFsd2FyZC9heGlzLnBvaW50L25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3d3d19hdXRoZW50aWNhdGVfcGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFJFR0VYUCA9IC8oXFx3Kyk9KFwiW15cIl0qXCIpL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gKHd3d0F1dGhlbnRpY2F0ZSkgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoUkVHRVhQLmV4ZWMod3d3QXV0aGVudGljYXRlKSAhPT0gbnVsbCkge1xuICAgICAgaWYgKFJlZ0V4cC4kMSAmJiBSZWdFeHAuJDIpIHtcbiAgICAgICAgcGFyYW1zW1JlZ0V4cC4kMV0gPSBSZWdFeHAuJDIuc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gIHJldHVybiBwYXJhbXM7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/www_authenticate_parser.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/index.js":
/*!**************************************************!*\
  !*** ../node_modules/openid-client/lib/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Issuer = __webpack_require__(/*! ./issuer */ \"(rsc)/../node_modules/openid-client/lib/issuer.js\");\nconst { OPError, RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst Strategy = __webpack_require__(/*! ./passport_strategy */ \"(rsc)/../node_modules/openid-client/lib/passport_strategy.js\");\nconst TokenSet = __webpack_require__(/*! ./token_set */ \"(rsc)/../node_modules/openid-client/lib/token_set.js\");\nconst { CLOCK_TOLERANCE, HTTP_OPTIONS } = __webpack_require__(/*! ./helpers/consts */ \"(rsc)/../node_modules/openid-client/lib/helpers/consts.js\");\nconst generators = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/../node_modules/openid-client/lib/helpers/generators.js\");\nconst { setDefaults } = __webpack_require__(/*! ./helpers/request */ \"(rsc)/../node_modules/openid-client/lib/helpers/request.js\");\n\nmodule.exports = {\n  Issuer,\n  Strategy,\n  TokenSet,\n  errors: {\n    OPError,\n    RPError,\n  },\n  custom: {\n    setHttpOptionsDefaults: setDefaults,\n    http_options: HTTP_OPTIONS,\n    clock_tolerance: CLOCK_TOLERANCE,\n  },\n  generators,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVTtBQUNqQyxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsbUVBQVU7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMseUZBQXFCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHlFQUFhO0FBQ3RDLFFBQVEsZ0NBQWdDLEVBQUUsbUJBQU8sQ0FBQyxtRkFBa0I7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMsMkZBQXNCO0FBQ2pELFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMscUZBQW1COztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvamFtYWx3YXJkL2F4aXMucG9pbnQvbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IElzc3VlciA9IHJlcXVpcmUoJy4vaXNzdWVyJyk7XG5jb25zdCB7IE9QRXJyb3IsIFJQRXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBTdHJhdGVneSA9IHJlcXVpcmUoJy4vcGFzc3BvcnRfc3RyYXRlZ3knKTtcbmNvbnN0IFRva2VuU2V0ID0gcmVxdWlyZSgnLi90b2tlbl9zZXQnKTtcbmNvbnN0IHsgQ0xPQ0tfVE9MRVJBTkNFLCBIVFRQX09QVElPTlMgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9jb25zdHMnKTtcbmNvbnN0IGdlbmVyYXRvcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2VuZXJhdG9ycycpO1xuY29uc3QgeyBzZXREZWZhdWx0cyB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3JlcXVlc3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIElzc3VlcixcbiAgU3RyYXRlZ3ksXG4gIFRva2VuU2V0LFxuICBlcnJvcnM6IHtcbiAgICBPUEVycm9yLFxuICAgIFJQRXJyb3IsXG4gIH0sXG4gIGN1c3RvbToge1xuICAgIHNldEh0dHBPcHRpb25zRGVmYXVsdHM6IHNldERlZmF1bHRzLFxuICAgIGh0dHBfb3B0aW9uczogSFRUUF9PUFRJT05TLFxuICAgIGNsb2NrX3RvbGVyYW5jZTogQ0xPQ0tfVE9MRVJBTkNFLFxuICB9LFxuICBnZW5lcmF0b3JzLFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/issuer.js":
/*!***************************************************!*\
  !*** ../node_modules/openid-client/lib/issuer.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { inspect } = __webpack_require__(/*! util */ \"util\");\nconst url = __webpack_require__(/*! url */ \"url\");\n\nconst { RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst getClient = __webpack_require__(/*! ./client */ \"(rsc)/../node_modules/openid-client/lib/client.js\");\nconst registry = __webpack_require__(/*! ./issuer_registry */ \"(rsc)/../node_modules/openid-client/lib/issuer_registry.js\");\nconst processResponse = __webpack_require__(/*! ./helpers/process_response */ \"(rsc)/../node_modules/openid-client/lib/helpers/process_response.js\");\nconst webfingerNormalize = __webpack_require__(/*! ./helpers/webfinger_normalize */ \"(rsc)/../node_modules/openid-client/lib/helpers/webfinger_normalize.js\");\nconst request = __webpack_require__(/*! ./helpers/request */ \"(rsc)/../node_modules/openid-client/lib/helpers/request.js\");\nconst clone = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { keystore } = __webpack_require__(/*! ./helpers/issuer */ \"(rsc)/../node_modules/openid-client/lib/helpers/issuer.js\");\n\nconst AAD_MULTITENANT_DISCOVERY = [\n  'https://login.microsoftonline.com/common/.well-known/openid-configuration',\n  'https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration',\n  'https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration',\n  'https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration',\n];\nconst AAD_MULTITENANT = Symbol();\nconst ISSUER_DEFAULTS = {\n  claim_types_supported: ['normal'],\n  claims_parameter_supported: false,\n  grant_types_supported: ['authorization_code', 'implicit'],\n  request_parameter_supported: false,\n  request_uri_parameter_supported: true,\n  require_request_uri_registration: false,\n  response_modes_supported: ['query', 'fragment'],\n  token_endpoint_auth_methods_supported: ['client_secret_basic'],\n};\n\nclass Issuer {\n  #metadata;\n  constructor(meta = {}) {\n    const aadIssValidation = meta[AAD_MULTITENANT];\n    delete meta[AAD_MULTITENANT];\n    ['introspection', 'revocation'].forEach((endpoint) => {\n      // if intro/revocation endpoint auth specific meta is missing use the token ones if they\n      // are defined\n      if (\n        meta[`${endpoint}_endpoint`] &&\n        meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined &&\n        meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined\n      ) {\n        if (meta.token_endpoint_auth_methods_supported) {\n          meta[`${endpoint}_endpoint_auth_methods_supported`] =\n            meta.token_endpoint_auth_methods_supported;\n        }\n        if (meta.token_endpoint_auth_signing_alg_values_supported) {\n          meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] =\n            meta.token_endpoint_auth_signing_alg_values_supported;\n        }\n      }\n    });\n\n    this.#metadata = new Map();\n\n    Object.entries(meta).forEach(([key, value]) => {\n      this.#metadata.set(key, value);\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return this.#metadata.get(key);\n          },\n          enumerable: true,\n        });\n      }\n    });\n\n    registry.set(this.issuer, this);\n\n    const Client = getClient(this, aadIssValidation);\n\n    Object.defineProperties(this, {\n      Client: { value: Client, enumerable: true },\n      FAPI1Client: { value: class FAPI1Client extends Client {}, enumerable: true },\n      FAPI2Client: { value: class FAPI2Client extends Client {}, enumerable: true },\n    });\n  }\n\n  get metadata() {\n    return clone(Object.fromEntries(this.#metadata.entries()));\n  }\n\n  static async webfinger(input) {\n    const resource = webfingerNormalize(input);\n    const { host } = url.parse(resource);\n    const webfingerUrl = `https://${host}/.well-known/webfinger`;\n\n    const response = await request.call(this, {\n      method: 'GET',\n      url: webfingerUrl,\n      responseType: 'json',\n      searchParams: { resource, rel: 'http://openid.net/specs/connect/1.0/issuer' },\n      headers: {\n        Accept: 'application/json',\n      },\n    });\n    const body = processResponse(response);\n\n    const location =\n      Array.isArray(body.links) &&\n      body.links.find(\n        (link) =>\n          typeof link === 'object' &&\n          link.rel === 'http://openid.net/specs/connect/1.0/issuer' &&\n          link.href,\n      );\n\n    if (!location) {\n      throw new RPError({\n        message: 'no issuer found in webfinger response',\n        body,\n      });\n    }\n\n    if (typeof location.href !== 'string' || !location.href.startsWith('https://')) {\n      throw new RPError({\n        printf: ['invalid issuer location %s', location.href],\n        body,\n      });\n    }\n\n    const expectedIssuer = location.href;\n    if (registry.has(expectedIssuer)) {\n      return registry.get(expectedIssuer);\n    }\n\n    const issuer = await this.discover(expectedIssuer);\n\n    if (issuer.issuer !== expectedIssuer) {\n      registry.del(issuer.issuer);\n      throw new RPError(\n        'discovered issuer mismatch, expected %s, got: %s',\n        expectedIssuer,\n        issuer.issuer,\n      );\n    }\n    return issuer;\n  }\n\n  static async discover(uri) {\n    const wellKnownUri = resolveWellKnownUri(uri);\n\n    const response = await request.call(this, {\n      method: 'GET',\n      responseType: 'json',\n      url: wellKnownUri,\n      headers: {\n        Accept: 'application/json',\n      },\n    });\n    const body = processResponse(response);\n    return new Issuer({\n      ...ISSUER_DEFAULTS,\n      ...body,\n      [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL) =>\n        wellKnownUri.startsWith(discoveryURL),\n      ),\n    });\n  }\n\n  async reloadJwksUri() {\n    await keystore.call(this, true);\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true,\n    })}`;\n  }\n}\n\nfunction resolveWellKnownUri(uri) {\n  const parsed = url.parse(uri);\n  if (parsed.pathname.includes('/.well-known/')) {\n    return uri;\n  } else {\n    let pathname;\n    if (parsed.pathname.endsWith('/')) {\n      pathname = `${parsed.pathname}.well-known/openid-configuration`;\n    } else {\n      pathname = `${parsed.pathname}/.well-known/openid-configuration`;\n    }\n    return url.format({ ...parsed, pathname });\n  }\n}\n\nmodule.exports = Issuer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2lzc3Vlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQyxnQkFBSzs7QUFFekIsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyxtRUFBVTtBQUN0QyxrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBVTtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBbUI7QUFDNUMsd0JBQXdCLG1CQUFPLENBQUMsdUdBQTRCO0FBQzVELDJCQUEyQixtQkFBTyxDQUFDLDZHQUErQjtBQUNsRSxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBbUI7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLDJGQUFzQjtBQUM1QyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1GQUFrQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pELHFCQUFxQiwwQ0FBMEMsb0JBQW9CO0FBQ25GLHFCQUFxQiwwQ0FBMEMsb0JBQW9CO0FBQ25GLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixvQ0FBb0MsS0FBSzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQTZEO0FBQ25GO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUIsRUFBRTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTtBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsTUFBTTtBQUNOLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYW1hbHdhcmQvYXhpcy5wb2ludC9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaXNzdWVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgaW5zcGVjdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IHsgUlBFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IGdldENsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50Jyk7XG5jb25zdCByZWdpc3RyeSA9IHJlcXVpcmUoJy4vaXNzdWVyX3JlZ2lzdHJ5Jyk7XG5jb25zdCBwcm9jZXNzUmVzcG9uc2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvY2Vzc19yZXNwb25zZScpO1xuY29uc3Qgd2ViZmluZ2VyTm9ybWFsaXplID0gcmVxdWlyZSgnLi9oZWxwZXJzL3dlYmZpbmdlcl9ub3JtYWxpemUnKTtcbmNvbnN0IHJlcXVlc3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvcmVxdWVzdCcpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVlcF9jbG9uZScpO1xuY29uc3QgeyBrZXlzdG9yZSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzc3VlcicpO1xuXG5jb25zdCBBQURfTVVMVElURU5BTlRfRElTQ09WRVJZID0gW1xuICAnaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbW1vbi8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbicsXG4gICdodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vY29tbW9uL3YyLjAvLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24nLFxuICAnaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL29yZ2FuaXphdGlvbnMvdjIuMC8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbicsXG4gICdodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vY29uc3VtZXJzL3YyLjAvLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24nLFxuXTtcbmNvbnN0IEFBRF9NVUxUSVRFTkFOVCA9IFN5bWJvbCgpO1xuY29uc3QgSVNTVUVSX0RFRkFVTFRTID0ge1xuICBjbGFpbV90eXBlc19zdXBwb3J0ZWQ6IFsnbm9ybWFsJ10sXG4gIGNsYWltc19wYXJhbWV0ZXJfc3VwcG9ydGVkOiBmYWxzZSxcbiAgZ3JhbnRfdHlwZXNfc3VwcG9ydGVkOiBbJ2F1dGhvcml6YXRpb25fY29kZScsICdpbXBsaWNpdCddLFxuICByZXF1ZXN0X3BhcmFtZXRlcl9zdXBwb3J0ZWQ6IGZhbHNlLFxuICByZXF1ZXN0X3VyaV9wYXJhbWV0ZXJfc3VwcG9ydGVkOiB0cnVlLFxuICByZXF1aXJlX3JlcXVlc3RfdXJpX3JlZ2lzdHJhdGlvbjogZmFsc2UsXG4gIHJlc3BvbnNlX21vZGVzX3N1cHBvcnRlZDogWydxdWVyeScsICdmcmFnbWVudCddLFxuICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkOiBbJ2NsaWVudF9zZWNyZXRfYmFzaWMnXSxcbn07XG5cbmNsYXNzIElzc3VlciB7XG4gICNtZXRhZGF0YTtcbiAgY29uc3RydWN0b3IobWV0YSA9IHt9KSB7XG4gICAgY29uc3QgYWFkSXNzVmFsaWRhdGlvbiA9IG1ldGFbQUFEX01VTFRJVEVOQU5UXTtcbiAgICBkZWxldGUgbWV0YVtBQURfTVVMVElURU5BTlRdO1xuICAgIFsnaW50cm9zcGVjdGlvbicsICdyZXZvY2F0aW9uJ10uZm9yRWFjaCgoZW5kcG9pbnQpID0+IHtcbiAgICAgIC8vIGlmIGludHJvL3Jldm9jYXRpb24gZW5kcG9pbnQgYXV0aCBzcGVjaWZpYyBtZXRhIGlzIG1pc3NpbmcgdXNlIHRoZSB0b2tlbiBvbmVzIGlmIHRoZXlcbiAgICAgIC8vIGFyZSBkZWZpbmVkXG4gICAgICBpZiAoXG4gICAgICAgIG1ldGFbYCR7ZW5kcG9pbnR9X2VuZHBvaW50YF0gJiZcbiAgICAgICAgbWV0YVtgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZGBdID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgbWV0YVtgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkYF0gPT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIGlmIChtZXRhLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQpIHtcbiAgICAgICAgICBtZXRhW2Ake2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkYF0gPVxuICAgICAgICAgICAgbWV0YS50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLnRva2VuX2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCkge1xuICAgICAgICAgIG1ldGFbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZGBdID1cbiAgICAgICAgICAgIG1ldGEudG9rZW5fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLiNtZXRhZGF0YSA9IG5ldyBNYXAoKTtcblxuICAgIE9iamVjdC5lbnRyaWVzKG1ldGEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgdGhpcy4jbWV0YWRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCF0aGlzW2tleV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YS5nZXQoa2V5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVnaXN0cnkuc2V0KHRoaXMuaXNzdWVyLCB0aGlzKTtcblxuICAgIGNvbnN0IENsaWVudCA9IGdldENsaWVudCh0aGlzLCBhYWRJc3NWYWxpZGF0aW9uKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIENsaWVudDogeyB2YWx1ZTogQ2xpZW50LCBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICBGQVBJMUNsaWVudDogeyB2YWx1ZTogY2xhc3MgRkFQSTFDbGllbnQgZXh0ZW5kcyBDbGllbnQge30sIGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIEZBUEkyQ2xpZW50OiB7IHZhbHVlOiBjbGFzcyBGQVBJMkNsaWVudCBleHRlbmRzIENsaWVudCB7fSwgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IG1ldGFkYXRhKCkge1xuICAgIHJldHVybiBjbG9uZShPYmplY3QuZnJvbUVudHJpZXModGhpcy4jbWV0YWRhdGEuZW50cmllcygpKSk7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgd2ViZmluZ2VyKGlucHV0KSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSB3ZWJmaW5nZXJOb3JtYWxpemUoaW5wdXQpO1xuICAgIGNvbnN0IHsgaG9zdCB9ID0gdXJsLnBhcnNlKHJlc291cmNlKTtcbiAgICBjb25zdCB3ZWJmaW5nZXJVcmwgPSBgaHR0cHM6Ly8ke2hvc3R9Ly53ZWxsLWtub3duL3dlYmZpbmdlcmA7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuY2FsbCh0aGlzLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiB3ZWJmaW5nZXJVcmwsXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgIHNlYXJjaFBhcmFtczogeyByZXNvdXJjZSwgcmVsOiAnaHR0cDovL29wZW5pZC5uZXQvc3BlY3MvY29ubmVjdC8xLjAvaXNzdWVyJyB9LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgYm9keSA9IHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSk7XG5cbiAgICBjb25zdCBsb2NhdGlvbiA9XG4gICAgICBBcnJheS5pc0FycmF5KGJvZHkubGlua3MpICYmXG4gICAgICBib2R5LmxpbmtzLmZpbmQoXG4gICAgICAgIChsaW5rKSA9PlxuICAgICAgICAgIHR5cGVvZiBsaW5rID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIGxpbmsucmVsID09PSAnaHR0cDovL29wZW5pZC5uZXQvc3BlY3MvY29ubmVjdC8xLjAvaXNzdWVyJyAmJlxuICAgICAgICAgIGxpbmsuaHJlZixcbiAgICAgICk7XG5cbiAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdubyBpc3N1ZXIgZm91bmQgaW4gd2ViZmluZ2VyIHJlc3BvbnNlJyxcbiAgICAgICAgYm9keSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbG9jYXRpb24uaHJlZiAhPT0gJ3N0cmluZycgfHwgIWxvY2F0aW9uLmhyZWYuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBwcmludGY6IFsnaW52YWxpZCBpc3N1ZXIgbG9jYXRpb24gJXMnLCBsb2NhdGlvbi5ocmVmXSxcbiAgICAgICAgYm9keSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGV4cGVjdGVkSXNzdWVyID0gbG9jYXRpb24uaHJlZjtcbiAgICBpZiAocmVnaXN0cnkuaGFzKGV4cGVjdGVkSXNzdWVyKSkge1xuICAgICAgcmV0dXJuIHJlZ2lzdHJ5LmdldChleHBlY3RlZElzc3Vlcik7XG4gICAgfVxuXG4gICAgY29uc3QgaXNzdWVyID0gYXdhaXQgdGhpcy5kaXNjb3ZlcihleHBlY3RlZElzc3Vlcik7XG5cbiAgICBpZiAoaXNzdWVyLmlzc3VlciAhPT0gZXhwZWN0ZWRJc3N1ZXIpIHtcbiAgICAgIHJlZ2lzdHJ5LmRlbChpc3N1ZXIuaXNzdWVyKTtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKFxuICAgICAgICAnZGlzY292ZXJlZCBpc3N1ZXIgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJyxcbiAgICAgICAgZXhwZWN0ZWRJc3N1ZXIsXG4gICAgICAgIGlzc3Vlci5pc3N1ZXIsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaXNzdWVyO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGRpc2NvdmVyKHVyaSkge1xuICAgIGNvbnN0IHdlbGxLbm93blVyaSA9IHJlc29sdmVXZWxsS25vd25VcmkodXJpKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5jYWxsKHRoaXMsIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgIHVybDogd2VsbEtub3duVXJpLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgYm9keSA9IHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSk7XG4gICAgcmV0dXJuIG5ldyBJc3N1ZXIoe1xuICAgICAgLi4uSVNTVUVSX0RFRkFVTFRTLFxuICAgICAgLi4uYm9keSxcbiAgICAgIFtBQURfTVVMVElURU5BTlRdOiAhIUFBRF9NVUxUSVRFTkFOVF9ESVNDT1ZFUlkuZmluZCgoZGlzY292ZXJ5VVJMKSA9PlxuICAgICAgICB3ZWxsS25vd25Vcmkuc3RhcnRzV2l0aChkaXNjb3ZlcnlVUkwpLFxuICAgICAgKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJlbG9hZEp3a3NVcmkoKSB7XG4gICAgYXdhaXQga2V5c3RvcmUuY2FsbCh0aGlzLCB0cnVlKTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIFtpbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gJHtpbnNwZWN0KHRoaXMubWV0YWRhdGEsIHtcbiAgICAgIGRlcHRoOiBJbmZpbml0eSxcbiAgICAgIGNvbG9yczogcHJvY2Vzcy5zdGRvdXQuaXNUVFksXG4gICAgICBjb21wYWN0OiBmYWxzZSxcbiAgICAgIHNvcnRlZDogdHJ1ZSxcbiAgICB9KX1gO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVXZWxsS25vd25VcmkodXJpKSB7XG4gIGNvbnN0IHBhcnNlZCA9IHVybC5wYXJzZSh1cmkpO1xuICBpZiAocGFyc2VkLnBhdGhuYW1lLmluY2x1ZGVzKCcvLndlbGwta25vd24vJykpIHtcbiAgICByZXR1cm4gdXJpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwYXRobmFtZTtcbiAgICBpZiAocGFyc2VkLnBhdGhuYW1lLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgIHBhdGhuYW1lID0gYCR7cGFyc2VkLnBhdGhuYW1lfS53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aG5hbWUgPSBgJHtwYXJzZWQucGF0aG5hbWV9Ly53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uYDtcbiAgICB9XG4gICAgcmV0dXJuIHVybC5mb3JtYXQoeyAuLi5wYXJzZWQsIHBhdGhuYW1lIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSXNzdWVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/issuer.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/issuer_registry.js":
/*!************************************************************!*\
  !*** ../node_modules/openid-client/lib/issuer_registry.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/../node_modules/lru-cache/index.js\");\n\nmodule.exports = new LRU({ max: 100 });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2lzc3Vlcl9yZWdpc3RyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsMkRBQVc7O0FBRS9CLDJCQUEyQixVQUFVIiwic291cmNlcyI6WyIvVXNlcnMvamFtYWx3YXJkL2F4aXMucG9pbnQvbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2lzc3Vlcl9yZWdpc3RyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgTFJVKHsgbWF4OiAxMDAgfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/issuer_registry.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/passport_strategy.js":
/*!**************************************************************!*\
  !*** ../node_modules/openid-client/lib/passport_strategy.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const url = __webpack_require__(/*! url */ \"url\");\nconst { format } = __webpack_require__(/*! util */ \"util\");\n\nconst cloneDeep = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { RPError, OPError } = __webpack_require__(/*! ./errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst { BaseClient } = __webpack_require__(/*! ./client */ \"(rsc)/../node_modules/openid-client/lib/client.js\");\nconst { random, codeChallenge } = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/../node_modules/openid-client/lib/helpers/generators.js\");\nconst pick = __webpack_require__(/*! ./helpers/pick */ \"(rsc)/../node_modules/openid-client/lib/helpers/pick.js\");\nconst { resolveResponseType, resolveRedirectUri } = __webpack_require__(/*! ./helpers/client */ \"(rsc)/../node_modules/openid-client/lib/helpers/client.js\");\n\nfunction verified(err, user, info = {}) {\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(info);\n  } else {\n    this.success(user, info);\n  }\n}\n\nfunction OpenIDConnectStrategy(\n  { client, params = {}, passReqToCallback = false, sessionKey, usePKCE = true, extras = {} } = {},\n  verify,\n) {\n  if (!(client instanceof BaseClient)) {\n    throw new TypeError('client must be an instance of openid-client Client');\n  }\n\n  if (typeof verify !== 'function') {\n    throw new TypeError('verify callback must be a function');\n  }\n\n  if (!client.issuer || !client.issuer.issuer) {\n    throw new TypeError('client must have an issuer with an identifier');\n  }\n\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._passReqToCallback = passReqToCallback;\n  this._usePKCE = usePKCE;\n  this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n  this._params = cloneDeep(params);\n\n  // state and nonce are handled in authenticate()\n  delete this._params.state;\n  delete this._params.nonce;\n\n  this._extras = cloneDeep(extras);\n\n  if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);\n  if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);\n  if (!this._params.scope) this._params.scope = 'openid';\n\n  if (this._usePKCE === true) {\n    const supportedMethods = Array.isArray(this._issuer.code_challenge_methods_supported)\n      ? this._issuer.code_challenge_methods_supported\n      : false;\n\n    if (supportedMethods && supportedMethods.includes('S256')) {\n      this._usePKCE = 'S256';\n    } else if (supportedMethods && supportedMethods.includes('plain')) {\n      this._usePKCE = 'plain';\n    } else if (supportedMethods) {\n      throw new TypeError(\n        'neither code_challenge_method supported by the client is supported by the issuer',\n      );\n    } else {\n      this._usePKCE = 'S256';\n    }\n  } else if (typeof this._usePKCE === 'string' && !['plain', 'S256'].includes(this._usePKCE)) {\n    throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n  }\n\n  this.name = url.parse(client.issuer.issuer).hostname;\n}\n\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  (async () => {\n    const client = this._client;\n    if (!req.session) {\n      throw new TypeError('authentication requires session support');\n    }\n    const reqParams = client.callbackParams(req);\n    const sessionKey = this._key;\n\n    const { 0: parameter, length } = Object.keys(reqParams);\n\n    /**\n     * Start authentication request if this has no authorization response parameters or\n     * this might a login initiated from a third party as per\n     * https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin.\n     */\n    if (length === 0 || (length === 1 && parameter === 'iss')) {\n      // provide options object with extra authentication parameters\n      const params = {\n        state: random(),\n        ...this._params,\n        ...options,\n      };\n\n      if (!params.nonce && params.response_type.includes('id_token')) {\n        params.nonce = random();\n      }\n\n      req.session[sessionKey] = pick(params, 'nonce', 'state', 'max_age', 'response_type');\n\n      if (this._usePKCE && params.response_type.includes('code')) {\n        const verifier = random();\n        req.session[sessionKey].code_verifier = verifier;\n\n        switch (this._usePKCE) {\n          case 'S256':\n            params.code_challenge = codeChallenge(verifier);\n            params.code_challenge_method = 'S256';\n            break;\n          case 'plain':\n            params.code_challenge = verifier;\n            break;\n        }\n      }\n\n      this.redirect(client.authorizationUrl(params));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n\n    const session = req.session[sessionKey];\n    if (Object.keys(session || {}).length === 0) {\n      throw new Error(\n        format(\n          'did not find expected authorization request details in session, req.session[\"%s\"] is %j',\n          sessionKey,\n          session,\n        ),\n      );\n    }\n\n    const {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType,\n    } = session;\n\n    try {\n      delete req.session[sessionKey];\n    } catch (err) {}\n\n    const opts = {\n      redirect_uri: this._params.redirect_uri,\n      ...options,\n    };\n\n    const checks = {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType,\n    };\n\n    const tokenset = await client.callback(opts.redirect_uri, reqParams, checks, this._extras);\n\n    const passReq = this._passReqToCallback;\n    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n\n    const args = [tokenset, verified.bind(this)];\n\n    if (loadUserinfo) {\n      if (!tokenset.access_token) {\n        throw new RPError({\n          message:\n            'expected access_token to be returned when asking for userinfo in verify callback',\n          tokenset,\n        });\n      }\n      const userinfo = await client.userinfo(tokenset);\n      args.splice(1, 0, userinfo);\n    }\n\n    if (passReq) {\n      args.unshift(req);\n    }\n\n    this._verify(...args);\n    /* end authentication response */\n  })().catch((error) => {\n    if (\n      (error instanceof OPError &&\n        error.error !== 'server_error' &&\n        !error.error.startsWith('invalid')) ||\n      error instanceof RPError\n    ) {\n      this.fail(error);\n    } else {\n      this.error(error);\n    }\n  });\n};\n\nmodule.exports = OpenIDConnectStrategy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL3Bhc3Nwb3J0X3N0cmF0ZWd5LmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLGtCQUFNOztBQUVqQyxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBc0I7QUFDaEQsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLG1FQUFVO0FBQy9DLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsbUVBQVU7QUFDekMsUUFBUSx3QkFBd0IsRUFBRSxtQkFBTyxDQUFDLDJGQUFzQjtBQUNoRSxhQUFhLG1CQUFPLENBQUMsK0VBQWdCO0FBQ3JDLFFBQVEsMENBQTBDLEVBQUUsbUJBQU8sQ0FBQyxtRkFBa0I7O0FBRTlFLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksbUJBQW1CLHVFQUF1RSxJQUFJO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLGVBQWU7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksdUJBQXVCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phbWFsd2FyZC9heGlzLnBvaW50L25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9wYXNzcG9ydF9zdHJhdGVneS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHsgZm9ybWF0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IGNsb25lRGVlcCA9IHJlcXVpcmUoJy4vaGVscGVycy9kZWVwX2Nsb25lJyk7XG5jb25zdCB7IFJQRXJyb3IsIE9QRXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCB7IEJhc2VDbGllbnQgfSA9IHJlcXVpcmUoJy4vY2xpZW50Jyk7XG5jb25zdCB7IHJhbmRvbSwgY29kZUNoYWxsZW5nZSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dlbmVyYXRvcnMnKTtcbmNvbnN0IHBpY2sgPSByZXF1aXJlKCcuL2hlbHBlcnMvcGljaycpO1xuY29uc3QgeyByZXNvbHZlUmVzcG9uc2VUeXBlLCByZXNvbHZlUmVkaXJlY3RVcmkgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbGllbnQnKTtcblxuZnVuY3Rpb24gdmVyaWZpZWQoZXJyLCB1c2VyLCBpbmZvID0ge30pIHtcbiAgaWYgKGVycikge1xuICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIGlmICghdXNlcikge1xuICAgIHRoaXMuZmFpbChpbmZvKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN1Y2Nlc3ModXNlciwgaW5mbyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gT3BlbklEQ29ubmVjdFN0cmF0ZWd5KFxuICB7IGNsaWVudCwgcGFyYW1zID0ge30sIHBhc3NSZXFUb0NhbGxiYWNrID0gZmFsc2UsIHNlc3Npb25LZXksIHVzZVBLQ0UgPSB0cnVlLCBleHRyYXMgPSB7fSB9ID0ge30sXG4gIHZlcmlmeSxcbikge1xuICBpZiAoIShjbGllbnQgaW5zdGFuY2VvZiBCYXNlQ2xpZW50KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NsaWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIG9wZW5pZC1jbGllbnQgQ2xpZW50Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZlcmlmeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZlcmlmeSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghY2xpZW50Lmlzc3VlciB8fCAhY2xpZW50Lmlzc3Vlci5pc3N1ZXIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjbGllbnQgbXVzdCBoYXZlIGFuIGlzc3VlciB3aXRoIGFuIGlkZW50aWZpZXInKTtcbiAgfVxuXG4gIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgdGhpcy5faXNzdWVyID0gY2xpZW50Lmlzc3VlcjtcbiAgdGhpcy5fdmVyaWZ5ID0gdmVyaWZ5O1xuICB0aGlzLl9wYXNzUmVxVG9DYWxsYmFjayA9IHBhc3NSZXFUb0NhbGxiYWNrO1xuICB0aGlzLl91c2VQS0NFID0gdXNlUEtDRTtcbiAgdGhpcy5fa2V5ID0gc2Vzc2lvbktleSB8fCBgb2lkYzoke3VybC5wYXJzZSh0aGlzLl9pc3N1ZXIuaXNzdWVyKS5ob3N0bmFtZX1gO1xuICB0aGlzLl9wYXJhbXMgPSBjbG9uZURlZXAocGFyYW1zKTtcblxuICAvLyBzdGF0ZSBhbmQgbm9uY2UgYXJlIGhhbmRsZWQgaW4gYXV0aGVudGljYXRlKClcbiAgZGVsZXRlIHRoaXMuX3BhcmFtcy5zdGF0ZTtcbiAgZGVsZXRlIHRoaXMuX3BhcmFtcy5ub25jZTtcblxuICB0aGlzLl9leHRyYXMgPSBjbG9uZURlZXAoZXh0cmFzKTtcblxuICBpZiAoIXRoaXMuX3BhcmFtcy5yZXNwb25zZV90eXBlKSB0aGlzLl9wYXJhbXMucmVzcG9uc2VfdHlwZSA9IHJlc29sdmVSZXNwb25zZVR5cGUuY2FsbChjbGllbnQpO1xuICBpZiAoIXRoaXMuX3BhcmFtcy5yZWRpcmVjdF91cmkpIHRoaXMuX3BhcmFtcy5yZWRpcmVjdF91cmkgPSByZXNvbHZlUmVkaXJlY3RVcmkuY2FsbChjbGllbnQpO1xuICBpZiAoIXRoaXMuX3BhcmFtcy5zY29wZSkgdGhpcy5fcGFyYW1zLnNjb3BlID0gJ29wZW5pZCc7XG5cbiAgaWYgKHRoaXMuX3VzZVBLQ0UgPT09IHRydWUpIHtcbiAgICBjb25zdCBzdXBwb3J0ZWRNZXRob2RzID0gQXJyYXkuaXNBcnJheSh0aGlzLl9pc3N1ZXIuY29kZV9jaGFsbGVuZ2VfbWV0aG9kc19zdXBwb3J0ZWQpXG4gICAgICA/IHRoaXMuX2lzc3Vlci5jb2RlX2NoYWxsZW5nZV9tZXRob2RzX3N1cHBvcnRlZFxuICAgICAgOiBmYWxzZTtcblxuICAgIGlmIChzdXBwb3J0ZWRNZXRob2RzICYmIHN1cHBvcnRlZE1ldGhvZHMuaW5jbHVkZXMoJ1MyNTYnKSkge1xuICAgICAgdGhpcy5fdXNlUEtDRSA9ICdTMjU2JztcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnRlZE1ldGhvZHMgJiYgc3VwcG9ydGVkTWV0aG9kcy5pbmNsdWRlcygncGxhaW4nKSkge1xuICAgICAgdGhpcy5fdXNlUEtDRSA9ICdwbGFpbic7XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0ZWRNZXRob2RzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnbmVpdGhlciBjb2RlX2NoYWxsZW5nZV9tZXRob2Qgc3VwcG9ydGVkIGJ5IHRoZSBjbGllbnQgaXMgc3VwcG9ydGVkIGJ5IHRoZSBpc3N1ZXInLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXNlUEtDRSA9ICdTMjU2JztcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX3VzZVBLQ0UgPT09ICdzdHJpbmcnICYmICFbJ3BsYWluJywgJ1MyNTYnXS5pbmNsdWRlcyh0aGlzLl91c2VQS0NFKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dGhpcy5fdXNlUEtDRX0gaXMgbm90IHZhbGlkL2ltcGxlbWVudGVkIFBLQ0UgY29kZV9jaGFsbGVuZ2VfbWV0aG9kYCk7XG4gIH1cblxuICB0aGlzLm5hbWUgPSB1cmwucGFyc2UoY2xpZW50Lmlzc3Vlci5pc3N1ZXIpLmhvc3RuYW1lO1xufVxuXG5PcGVuSURDb25uZWN0U3RyYXRlZ3kucHJvdG90eXBlLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZShyZXEsIG9wdGlvbnMpIHtcbiAgKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLl9jbGllbnQ7XG4gICAgaWYgKCFyZXEuc2Vzc2lvbikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXV0aGVudGljYXRpb24gcmVxdWlyZXMgc2Vzc2lvbiBzdXBwb3J0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHJlcVBhcmFtcyA9IGNsaWVudC5jYWxsYmFja1BhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHNlc3Npb25LZXkgPSB0aGlzLl9rZXk7XG5cbiAgICBjb25zdCB7IDA6IHBhcmFtZXRlciwgbGVuZ3RoIH0gPSBPYmplY3Qua2V5cyhyZXFQYXJhbXMpO1xuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYXV0aGVudGljYXRpb24gcmVxdWVzdCBpZiB0aGlzIGhhcyBubyBhdXRob3JpemF0aW9uIHJlc3BvbnNlIHBhcmFtZXRlcnMgb3JcbiAgICAgKiB0aGlzIG1pZ2h0IGEgbG9naW4gaW5pdGlhdGVkIGZyb20gYSB0aGlyZCBwYXJ0eSBhcyBwZXJcbiAgICAgKiBodHRwczovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtY29yZS0xXzAuaHRtbCNUaGlyZFBhcnR5SW5pdGlhdGVkTG9naW4uXG4gICAgICovXG4gICAgaWYgKGxlbmd0aCA9PT0gMCB8fCAobGVuZ3RoID09PSAxICYmIHBhcmFtZXRlciA9PT0gJ2lzcycpKSB7XG4gICAgICAvLyBwcm92aWRlIG9wdGlvbnMgb2JqZWN0IHdpdGggZXh0cmEgYXV0aGVudGljYXRpb24gcGFyYW1ldGVyc1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBzdGF0ZTogcmFuZG9tKCksXG4gICAgICAgIC4uLnRoaXMuX3BhcmFtcyxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIH07XG5cbiAgICAgIGlmICghcGFyYW1zLm5vbmNlICYmIHBhcmFtcy5yZXNwb25zZV90eXBlLmluY2x1ZGVzKCdpZF90b2tlbicpKSB7XG4gICAgICAgIHBhcmFtcy5ub25jZSA9IHJhbmRvbSgpO1xuICAgICAgfVxuXG4gICAgICByZXEuc2Vzc2lvbltzZXNzaW9uS2V5XSA9IHBpY2socGFyYW1zLCAnbm9uY2UnLCAnc3RhdGUnLCAnbWF4X2FnZScsICdyZXNwb25zZV90eXBlJyk7XG5cbiAgICAgIGlmICh0aGlzLl91c2VQS0NFICYmIHBhcmFtcy5yZXNwb25zZV90eXBlLmluY2x1ZGVzKCdjb2RlJykpIHtcbiAgICAgICAgY29uc3QgdmVyaWZpZXIgPSByYW5kb20oKTtcbiAgICAgICAgcmVxLnNlc3Npb25bc2Vzc2lvbktleV0uY29kZV92ZXJpZmllciA9IHZlcmlmaWVyO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5fdXNlUEtDRSkge1xuICAgICAgICAgIGNhc2UgJ1MyNTYnOlxuICAgICAgICAgICAgcGFyYW1zLmNvZGVfY2hhbGxlbmdlID0gY29kZUNoYWxsZW5nZSh2ZXJpZmllcik7XG4gICAgICAgICAgICBwYXJhbXMuY29kZV9jaGFsbGVuZ2VfbWV0aG9kID0gJ1MyNTYnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncGxhaW4nOlxuICAgICAgICAgICAgcGFyYW1zLmNvZGVfY2hhbGxlbmdlID0gdmVyaWZpZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlZGlyZWN0KGNsaWVudC5hdXRob3JpemF0aW9uVXJsKHBhcmFtcykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBlbmQgYXV0aGVudGljYXRpb24gcmVxdWVzdCAqL1xuXG4gICAgLyogc3RhcnQgYXV0aGVudGljYXRpb24gcmVzcG9uc2UgKi9cblxuICAgIGNvbnN0IHNlc3Npb24gPSByZXEuc2Vzc2lvbltzZXNzaW9uS2V5XTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2Vzc2lvbiB8fCB7fSkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdChcbiAgICAgICAgICAnZGlkIG5vdCBmaW5kIGV4cGVjdGVkIGF1dGhvcml6YXRpb24gcmVxdWVzdCBkZXRhaWxzIGluIHNlc3Npb24sIHJlcS5zZXNzaW9uW1wiJXNcIl0gaXMgJWonLFxuICAgICAgICAgIHNlc3Npb25LZXksXG4gICAgICAgICAgc2Vzc2lvbixcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgc3RhdGUsXG4gICAgICBub25jZSxcbiAgICAgIG1heF9hZ2U6IG1heEFnZSxcbiAgICAgIGNvZGVfdmVyaWZpZXI6IGNvZGVWZXJpZmllcixcbiAgICAgIHJlc3BvbnNlX3R5cGU6IHJlc3BvbnNlVHlwZSxcbiAgICB9ID0gc2Vzc2lvbjtcblxuICAgIHRyeSB7XG4gICAgICBkZWxldGUgcmVxLnNlc3Npb25bc2Vzc2lvbktleV07XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHJlZGlyZWN0X3VyaTogdGhpcy5fcGFyYW1zLnJlZGlyZWN0X3VyaSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcblxuICAgIGNvbnN0IGNoZWNrcyA9IHtcbiAgICAgIHN0YXRlLFxuICAgICAgbm9uY2UsXG4gICAgICBtYXhfYWdlOiBtYXhBZ2UsXG4gICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICByZXNwb25zZV90eXBlOiByZXNwb25zZVR5cGUsXG4gICAgfTtcblxuICAgIGNvbnN0IHRva2Vuc2V0ID0gYXdhaXQgY2xpZW50LmNhbGxiYWNrKG9wdHMucmVkaXJlY3RfdXJpLCByZXFQYXJhbXMsIGNoZWNrcywgdGhpcy5fZXh0cmFzKTtcblxuICAgIGNvbnN0IHBhc3NSZXEgPSB0aGlzLl9wYXNzUmVxVG9DYWxsYmFjaztcbiAgICBjb25zdCBsb2FkVXNlcmluZm8gPSB0aGlzLl92ZXJpZnkubGVuZ3RoID4gKHBhc3NSZXEgPyAzIDogMikgJiYgY2xpZW50Lmlzc3Vlci51c2VyaW5mb19lbmRwb2ludDtcblxuICAgIGNvbnN0IGFyZ3MgPSBbdG9rZW5zZXQsIHZlcmlmaWVkLmJpbmQodGhpcyldO1xuXG4gICAgaWYgKGxvYWRVc2VyaW5mbykge1xuICAgICAgaWYgKCF0b2tlbnNldC5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAnZXhwZWN0ZWQgYWNjZXNzX3Rva2VuIHRvIGJlIHJldHVybmVkIHdoZW4gYXNraW5nIGZvciB1c2VyaW5mbyBpbiB2ZXJpZnkgY2FsbGJhY2snLFxuICAgICAgICAgIHRva2Vuc2V0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVzZXJpbmZvID0gYXdhaXQgY2xpZW50LnVzZXJpbmZvKHRva2Vuc2V0KTtcbiAgICAgIGFyZ3Muc3BsaWNlKDEsIDAsIHVzZXJpbmZvKTtcbiAgICB9XG5cbiAgICBpZiAocGFzc1JlcSkge1xuICAgICAgYXJncy51bnNoaWZ0KHJlcSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdmVyaWZ5KC4uLmFyZ3MpO1xuICAgIC8qIGVuZCBhdXRoZW50aWNhdGlvbiByZXNwb25zZSAqL1xuICB9KSgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgIGlmIChcbiAgICAgIChlcnJvciBpbnN0YW5jZW9mIE9QRXJyb3IgJiZcbiAgICAgICAgZXJyb3IuZXJyb3IgIT09ICdzZXJ2ZXJfZXJyb3InICYmXG4gICAgICAgICFlcnJvci5lcnJvci5zdGFydHNXaXRoKCdpbnZhbGlkJykpIHx8XG4gICAgICBlcnJvciBpbnN0YW5jZW9mIFJQRXJyb3JcbiAgICApIHtcbiAgICAgIHRoaXMuZmFpbChlcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9wZW5JRENvbm5lY3RTdHJhdGVneTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/passport_strategy.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/token_set.js":
/*!******************************************************!*\
  !*** ../node_modules/openid-client/lib/token_set.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const base64url = __webpack_require__(/*! ./helpers/base64url */ \"(rsc)/../node_modules/openid-client/lib/helpers/base64url.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js\");\n\nclass TokenSet {\n  constructor(values) {\n    Object.assign(this, values);\n    const { constructor, ...properties } = Object.getOwnPropertyDescriptors(\n      this.constructor.prototype,\n    );\n\n    Object.defineProperties(this, properties);\n  }\n\n  set expires_in(value) {\n    this.expires_at = now() + Number(value);\n  }\n\n  get expires_in() {\n    return Math.max.apply(null, [this.expires_at - now(), 0]);\n  }\n\n  expired() {\n    return this.expires_in === 0;\n  }\n\n  claims() {\n    if (!this.id_token) {\n      throw new TypeError('id_token not present in TokenSet');\n    }\n\n    return JSON.parse(base64url.decode(this.id_token.split('.')[1]));\n  }\n}\n\nmodule.exports = TokenSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL3Rva2VuX3NldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyx5RkFBcUI7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLG1HQUEwQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phbWFsd2FyZC9heGlzLnBvaW50L25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi90b2tlbl9zZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmFzZTY0dXJsID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Jhc2U2NHVybCcpO1xuY29uc3Qgbm93ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3VuaXhfdGltZXN0YW1wJyk7XG5cbmNsYXNzIFRva2VuU2V0IHtcbiAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB2YWx1ZXMpO1xuICAgIGNvbnN0IHsgY29uc3RydWN0b3IsIC4uLnByb3BlcnRpZXMgfSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsXG4gICAgKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHByb3BlcnRpZXMpO1xuICB9XG5cbiAgc2V0IGV4cGlyZXNfaW4odmFsdWUpIHtcbiAgICB0aGlzLmV4cGlyZXNfYXQgPSBub3coKSArIE51bWJlcih2YWx1ZSk7XG4gIH1cblxuICBnZXQgZXhwaXJlc19pbigpIHtcbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgW3RoaXMuZXhwaXJlc19hdCAtIG5vdygpLCAwXSk7XG4gIH1cblxuICBleHBpcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGlyZXNfaW4gPT09IDA7XG4gIH1cblxuICBjbGFpbXMoKSB7XG4gICAgaWYgKCF0aGlzLmlkX3Rva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZF90b2tlbiBub3QgcHJlc2VudCBpbiBUb2tlblNldCcpO1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnBhcnNlKGJhc2U2NHVybC5kZWNvZGUodGhpcy5pZF90b2tlbi5zcGxpdCgnLicpWzFdKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUb2tlblNldDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/token_set.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/package.json":
/*!**************************************************!*\
  !*** ../node_modules/openid-client/package.json ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"openid-client","version":"5.7.1","description":"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs","keywords":["auth","authentication","basic","certified","client","connect","dynamic","electron","hybrid","identity","implicit","oauth","oauth2","oidc","openid","passport","relying party","strategy"],"homepage":"https://github.com/panva/openid-client","repository":"panva/openid-client","funding":{"url":"https://github.com/sponsors/panva"},"license":"MIT","author":"Filip Skokan <panva.ip@gmail.com>","exports":{"types":"./types/index.d.ts","import":"./lib/index.mjs","require":"./lib/index.js"},"main":"./lib/index.js","types":"./types/index.d.ts","files":["lib","types/index.d.ts"],"scripts":{"format":"npx prettier --loglevel silent --write ./lib ./test ./certification ./types","test":"mocha test/**/*.test.js"},"dependencies":{"jose":"^4.15.9","lru-cache":"^6.0.0","object-hash":"^2.2.0","oidc-token-hash":"^5.0.3"},"devDependencies":{"@types/node":"^16.18.106","@types/passport":"^1.0.16","base64url":"^3.0.1","chai":"^4.5.0","mocha":"^10.7.3","nock":"^13.5.5","prettier":"^2.8.8","readable-mock-req":"^0.2.2","sinon":"^9.2.4","timekeeper":"^2.3.1"},"standard-version":{"scripts":{"postchangelog":"sed -i \'\' -e \'s/### \\\\[/## [/g\' CHANGELOG.md"},"types":[{"type":"feat","section":"Features"},{"type":"fix","section":"Fixes"},{"type":"chore","hidden":true},{"type":"docs","hidden":true},{"type":"style","hidden":true},{"type":"refactor","section":"Refactor","hidden":false},{"type":"perf","section":"Performance","hidden":false},{"type":"test","hidden":true}]}}');

/***/ })

};
;